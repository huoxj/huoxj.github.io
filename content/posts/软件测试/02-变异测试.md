---
title: "02-变异测试"
date: 2025-01-03T14:26:30-08:00
categories: 
- "软件测试"
featureimage: https://runzblog.oss-cn-hangzhou.aliyuncs.com/postimg/202501031720816.png
summary: "一言以蔽之，变异测试研究如何编写能够的测试用例，以及如何提升测试。 将这些测试用例应用到待测程序中，就很有可能会发现待测程序的缺陷。 基于一定的语法（Syntax）变换规则，通过对源程序进行程序变换（..."
---

一言以蔽之，变异测试研究如何编写能够**暴露缺陷**的测试用例，以及如何提升测试**可信度**。

将这些测试用例应用到待测程序中，就很有可能会发现待测程序的缺陷。

## 概念

### 变异体

基于一定的语法（Syntax）变换规则，通过对源程序进行程序变换（Program Transformation）得到的一系列变体。

源程序不包含 Defect，变异体包含，那这个 Defect 叫`人工缺陷`

### 变异算子

上面所说的变换规则就是变异算子。

### 变异存活、杀死

如果一个变异体无法通过测试用例，这个变异体就被这个测试用例杀死了。

### 变异得分

变异测试对测试套件错误检测能力的量化。

是对于一个测试用例而言的。score 是**所有变异体**在这个测试用例上**运行失败**的比例。

下标 k 代表变体 killed，被检测到了；s 代表 survived，没有被检测到。

$$
score=\frac{mut_k}{mut_s+mut_k}\times100\%
$$

### 假设

基于这些假设，我们可以认为变异测试有效：
- 缺陷是**简单的、可模拟**的
	- 变异体模拟这些缺陷
	- 老练程序员假设：一个老练程序员编写的错误程序与正确程序相差不大
- 缺陷可**叠加**
	- 复杂变异体可以通过耦合简单变异体得到
	- 能够杀死简单变异体的测试用例可以杀死复杂变异体
- 缺陷检测**有效性**
	- 能检测人工缺陷的样例，也能检测真实程序的缺陷
## 步骤

### 1. 变异体筛选

- 对变异体进行筛选
- 通过变异算子筛选

### 2. 变异体生成

将选中的变异体通过算子实例化。

### 3. 变异体优化

去除等价和无效变异体。

目的：减小开销、提高变异得分可信度

形式：静态分析

### 4. 变异体执行

最昂贵的阶段。

### 5. 变异得分计算

计算被杀死的变异体数量，进而得到变异得分、量化测试的充分性。

## 应用与研究

### 传统方向

测试优化、测试生成、调试辅助

### 非传统

非确定系统、行为建模、算子定义

## 总结

这张图给个好评！

![](https://runzblog.oss-cn-hangzhou.aliyuncs.com/postimg/202501031720816.png)
