---
title: "运算符重载"
date: 2024-12-05T15:09:54-08:00
categories: 
- "C++拾遗"
featureimage: https://runzblog.oss-cn-hangzhou.aliyuncs.com/universal/background1.jpg
summary: "大部分运算符都可重载： | 双目算术运算符 | 加)，-(减)，*(乘)，/(除)，% (取模) | | ------ | 关系运算符 | ==(等于)，!= (不等于)， (大于)，=(大于等于) ..."
---

## 可重载的运算符

大部分运算符都可重载：

| 双目算术运算符 | + (加)，-(减)，*(乘)，/(除)，% (取模)                      |
| ------- | ------------------------------------------------ |
| 关系运算符   | ==(等于)，!= (不等于)，< (小于)，> (大于)，<=(小于等于)，>=(大于等于)  |
| 逻辑运算符   | \|\|(逻辑或)，&&(逻辑与)，!(逻辑非)                         |
| 单目运算符   | + (正)，-(负)，*(指针)，&(取地址)                          |
| 自增自减运算符 | ++(自增)，--(自减)                                    |
| 位运算符    | \| (按位或)，& (按位与)，~(按位取反)，^(按位异或),，<< (左移)，>>(右移) |
| 赋值运算符   | =, +=, -=, *=, /= , % = , &=, \|=, ^=, <<=, >>=  |
| 空间申请与释放 | new, delete, new[ ] , delete[]                   |
| 其他运算符   | **()**(函数调用)，**->**(成员访问)，**,**(逗号)，**[]**(下标)   |

至于不可重载的：

- `.`：成员访问
- `.*`, `->*`：指针访问
- `::`: 域运算符
- `sizeof`
- `?:`: 三目运算符
- `#`: 预处理

还有，**不建议重载**的：
- `&&`, `||`: 重载会影响短路机制
- 改变原运算符含义的。比如 `+` 重载成减法

只能用成员函数重载的：
- `=`, `()`, `[]`, `->`

## 类内重载与类外重载

类内重载，表示这个运算符的操作数（中的**第一个**）是这个类的对象。

比如对 Test 类的运算符进行重载，可以实现如下合法运算：

```cpp
class Test{...};
Test t, s;

t + s;
t + 1;
t + "test";
!t;
*t;
```

对于一目运算符，类内重载完全够用了。但是对于二目运算符存在这种情况：`1 + t` 以及 `cout<<t`。这是类内重载无法匹配的，因为类内重载中 this 默认为第一个参数。所以此时需要类外重载。

```cpp
class Test{
	friend Test operator+ (const int a, const Test b);
};

Test operator+ (const int a, const Test b);
```

也可以不用友元函数实现，但要提供对应成员的 get / set 方法。

## 写法细节

这里只提供比较特殊的写法细节。

### 区分单目和双目

相同字符的运算符可能有两种含义，比如 `-` 是减法或者负号, `*` 是乘法或者解引用。重载时怎么区分呢？

既然是重载，同名函数要区分开来自然是靠参数的对应关系。单目运算符对应的函数接受一个参数，双目两个。

```cpp
T operator-(const T x);
T operator-(const T x, const T y);
```

### 流运算符重载

流运算符可以用来 cin 和 cout 输入输出。当然也可以对其他流进行重载。

要引入 iostream 头文件，并且只能在类外重载。
```cpp
istream& operator>>(istream &stream, T &t) {
	stream >> t.x;
	return stream;
}
ostream& operator<<(ostream &stream, T &t) {
	stream << t.x;
	return stream;
}
```

### 自增自减

