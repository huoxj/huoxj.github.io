---
date: '2024-04-22'
series:
- SE操作系统
title: C2 处理器管理
---

# 第二章-处理器管理

- 本章结构

![image-20240422145053555](https://runzblog.oss-cn-hangzhou.aliyuncs.com/postimg/202409271717642.png)

## 2.1-处理器

### 特权指令

- 特权指令：只能被操作系统内核使用的指令
- 比如启动IO指令、置PC指令等

### 处理器模式

- 0=OS内核；1=系统调用；2=共享库程序；3=用户程序
- 现代操作系统：内核模式(特权指令ok)，用户模式(非特权指令)

## 2.2-中断

### 中断概念

- **广义中断**：程序执行过程中，遇到急需处理的事件时，暂时中止当前程序的运行，转去执行相应的事件处理程序。等中断处理完成后再返回原程序中断的地方或调度其他程序执行的过程叫中断。
- **狭义中断**：事件来源于处理器外的广义中断。如IO中断、时钟中断、外部信号中断
- **广义中断 minus 狭义中断**
    - 异常：事件来源于处理器运行指令引起的广义中断。如地址异常、算术异常、处理器硬件故障
    - 系统异常：执行陷入(trap)指令而触发系统调用引起的终端事件。如请求设备、请求IO、创建进程

### 中断驱动下的进程状态机

![](https://runzblog.oss-cn-hangzhou.aliyuncs.com/postimg/202409271717238.png)

### 中断源

- 处理器硬件故障中断
- 程序性中断
- 自愿性中断-系统调用
- IO中断
- 外部中断

## 2.3-进程

### ⭐⭐⭐进程的概念

- 进程是一个具有一定独立功能的**程序**关于某个**数据集合**的一次运行活动
- 进程是操作系统进行**资源分配**和**调度**的一个独立单位
    - 对于多线程系统来说，进程是**资源分配**的独立单位
    - 线程是资源调度的独立单位


### 进程的形式化定义

![](https://runzblog.oss-cn-hangzhou.aliyuncs.com/postimg/202409271718917.png)

### ⭐⭐⭐**进程的三态模型**

![](https://runzblog.oss-cn-hangzhou.aliyuncs.com/postimg/202409271718439.png)

- **运行态**指进程占有处理器运行

- **就绪态**指进程具备运行条件等待处理器运行

- **等待态**指进程由于等待资源、输入输出、信号等而不具备运行条件

### 进程挂起

![](https://runzblog.oss-cn-hangzhou.aliyuncs.com/postimg/202409271719195.png)

- 计算机资源不足，会剥夺某些进程的资源，调入OS管理的堆换区。这些进程就被挂起了。
- 挂起的进程**不参加进程调度**。在适当的时候被调回内存。
- 挂起和非运行态的本质区别是有没有**占用系统资源**

![](https://runzblog.oss-cn-hangzhou.aliyuncs.com/postimg/202409271719451.png)

### ⭐⭐⭐进程控制块 PCB

- OS用于记录和刻画进程状态及环境信息的数据结构。说白了就是面向OS的**进程的花名册**

- 包含**标识信息**、**现场信息**、**控制信息**。

### ⭐⭐⭐进程映像 Process Image

- 进程的**内存级**实体
- 包括：PCB、进程程序空间、进程数据空间、核心栈
    - 核心栈就是在内核态执行指令时用的栈

### 进程上下文 Process Context

- 进程执行所需要的环境信息
- 包括：用户级上下文、寄存器上下文、系统级上下文

### 原语 Primitive

- 若干条指令构成的程序，执行上具有原子性。意思是原语不可能被中断。
- 用于执行一些涉及修改OS核心数据结构的操作。为了防止并发和中断等时间上的错误，原语必须整块执行。
- 常用原语：进程控制原语、进程通信原语

## 2.4-多线程技术

### 为什么要多线程

- 单线程能一定程度上实现并发了，但我们还想更进一步。
- 限制单线程并发程度的要素：
    - 进程切换开销大。想切换执行路径就必须换进程，开销很大。
    - 进程通信开销大。进程通信要陷入系统调用，涉及模式转换，开销大。
- 解决：
    - 分离**资源分配**和**调度**。因为资源分配比较静态，不会很频繁。相对而言，(如果想更加并发的话)调度比资源分配频繁多了。
    - 两者分离的结果就是**进程**和**线程**

### 进程和线程

#### 进程

- 操作系统的视角：是OS进行保护和**资源分配**的独立单位。

- 是线程的容器。给线程提供运行环境和系统资源，包括内存等资源。

#### 线程

- 操作系统视角：是OS**调度**的基本单位

- 是进程的一条执行路径

### 并发多线程的优点

- 线程切换快
- 管理比进程方便(因为线程比较小)
- 通信容易实现，因为有进程这个容器的支
- 并行程度高
- 节省内存空间

### 线程的实现-KLT和ULT

#### KLT-内核级线程

- 线程是OS实现并管理的
- **优点**：线程的阻塞不会引起进程的阻塞(内核进程内部知道发生了什么并且还能给进程切换线程)、多处理器支持、使内核自身也可KLT实现
- **缺点**：由于线程管理是OS实现的，相关操作要切换模式，开销较大(但应该还是比单线程系统管理进程要快，不然这样KLT就没意义了)。

#### ULT-用户级线程

- 线程由用户实现并管理
- OS感知不到多线程的存在。这样会带来一些问题。
- **优点**：自定义程度高、多平台支持(可以移植到单线程的OS)、用户模式就能管理，开销小
- **缺点**：多处理器不支持、线程阻塞会被OS视为进程阻塞

#### Jacketing技术

- 当线程陷入系统调用时，执行jacketing程序。由jacketing程序来检查资源使用情况，以决定是否**执行进程切换**或**传递控制权给另一个线程**

#### 混合策略

- 单应用的多个ULT可以映射成一些KLT，通过调整KLT数目，可以达到较好的并行效果

## 2.5-处理器调度

### 处理器调度的层次

- 高级调度
    - 决定进程的创建和终止
- 中级调度
    - 决定进程的挂起和恢复
    - 为了提高内存利用率和作业吞吐量，短期内调整系统负载
- 低级调度
    - 决定哪个进程交给处理器运行
    - 最核心、最影响系统性能的调度