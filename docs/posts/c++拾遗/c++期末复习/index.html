<!DOCTYPE html>
<html lang="cn">

<head>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">
  <meta name="viewport" content="width=device-width,minimum-scale=1">
  <meta name="generator" content="Hugo 0.135.0">

  <title>C&#43;&#43;期末复习 | Runz&#39;s Blog</title>
  <meta name="description"
        content="">

  
  <meta name="robots" content="noindex, nofollow">
  

  

  
  
  
  <link href="/output/css/main.5bd88448bb2283387efc5607182f861c30204235e471eaa05d2911cd95a93170.css" integrity="sha256-W9iESLsigzh&#43;/FYHGC&#43;GHDAgQjXkceqgXSkRzZWpMXA=" rel="stylesheet" crossorigin="anonymous">
    
  <link rel="stylesheet" href="https://rsms.me/inter/inter.css"><meta property="og:url" content="https://huoxj.github.io/posts/c&#43;&#43;%E6%8B%BE%E9%81%97/c&#43;&#43;%E6%9C%9F%E6%9C%AB%E5%A4%8D%E4%B9%A0/">
  <meta property="og:site_name" content="Runz&#39;s Blog">
  <meta property="og:title" content="C&#43;&#43;期末复习">
  <meta property="og:description" content="根据上课 PPT 和同学与学长的笔记整理而成。
介绍 C&#43;&#43; 历史 先跳过。。。
结构化编程部分 强制类型转换 article link=&#34;/posts/C&#43;&#43;拾遗/C&#43;&#43;-强制类型转换&#34; &gt;}}
表达式的副作用 副作用，就是一个过程是否会修改参与的变量的性质。
在表达式中，有副作用的运算符：= &#43;= &#43;&#43; &lt;&lt; 等等 无副作用的运算符：&#43; &amp;&amp; 等等
decltype 和 auto 有相似之处。
auto 和 decltype 都用在声明变量上，都是基于 RTTI 机制实现的。
auto 是对初始化的右值进行类型推导，然后给声明的变量确定类型、赋值。
decltype 是对传入的参数类型进行类型推导，然后本身就作为这个类型的名称。
int x = 0; int&amp; ref = x; auto ref1 = x; decltype(ref) ref2 = x; // equals to &#34;int&amp; ref2 = x&#34; 既然本身就作为这个类型的名称，我们也可以结合 using 和 typedef：
int x = 0; int&amp; ref = x; using int_ref = decltype(ref); 参考 C&#43;&#43;11特性：decltype关键字 - melonstreet - 博客园">
  <meta property="og:locale" content="cn">
  <meta property="og:type" content="article">
    <meta property="article:section" content="posts">
    <meta property="article:published_time" content="2024-12-24T00:00:00+00:00">
    <meta property="article:modified_time" content="2024-12-24T00:00:00+00:00">
      <meta property="og:see_also" content="https://huoxj.github.io/posts/c&#43;&#43;%E6%8B%BE%E9%81%97/%E6%99%BA%E8%83%BD%E6%8C%87%E9%92%88%E8%B8%A9%E5%9D%91/">
      <meta property="og:see_also" content="https://huoxj.github.io/posts/c&#43;&#43;%E6%8B%BE%E9%81%97/%E6%99%BA%E8%83%BD%E6%8C%87%E9%92%88%E8%A3%B8%E6%8C%87%E9%92%88%E5%92%8C%E5%BC%95%E7%94%A8/">
      <meta property="og:see_also" content="https://huoxj.github.io/posts/c&#43;&#43;%E6%8B%BE%E9%81%97/%E5%AE%8F/">
      <meta property="og:see_also" content="https://huoxj.github.io/posts/c&#43;&#43;%E6%8B%BE%E9%81%97/stl-%E7%AE%97%E6%B3%95/">
      <meta property="og:see_also" content="https://huoxj.github.io/posts/c&#43;&#43;%E6%8B%BE%E9%81%97/%E5%BC%82%E5%B8%B8%E5%A4%84%E7%90%86/">
      <meta property="og:see_also" content="https://huoxj.github.io/posts/c&#43;&#43;%E6%8B%BE%E9%81%97/c&#43;&#43;-%E5%BC%BA%E5%88%B6%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2/">

  <meta itemprop="name" content="C&#43;&#43;期末复习">
  <meta itemprop="description" content="根据上课 PPT 和同学与学长的笔记整理而成。
介绍 C&#43;&#43; 历史 先跳过。。。
结构化编程部分 强制类型转换 article link=&#34;/posts/C&#43;&#43;拾遗/C&#43;&#43;-强制类型转换&#34; &gt;}}
表达式的副作用 副作用，就是一个过程是否会修改参与的变量的性质。
在表达式中，有副作用的运算符：= &#43;= &#43;&#43; &lt;&lt; 等等 无副作用的运算符：&#43; &amp;&amp; 等等
decltype 和 auto 有相似之处。
auto 和 decltype 都用在声明变量上，都是基于 RTTI 机制实现的。
auto 是对初始化的右值进行类型推导，然后给声明的变量确定类型、赋值。
decltype 是对传入的参数类型进行类型推导，然后本身就作为这个类型的名称。
int x = 0; int&amp; ref = x; auto ref1 = x; decltype(ref) ref2 = x; // equals to &#34;int&amp; ref2 = x&#34; 既然本身就作为这个类型的名称，我们也可以结合 using 和 typedef：
int x = 0; int&amp; ref = x; using int_ref = decltype(ref); 参考 C&#43;&#43;11特性：decltype关键字 - melonstreet - 博客园">
  <meta itemprop="datePublished" content="2024-12-24T00:00:00+00:00">
  <meta itemprop="dateModified" content="2024-12-24T00:00:00+00:00">
  <meta itemprop="wordCount" content="1317">
  <meta itemprop="keywords" content="C&#43;&#43;拾遗">
  <meta name="twitter:card" content="summary">
  <meta name="twitter:title" content="C&#43;&#43;期末复习">
  <meta name="twitter:description" content="根据上课 PPT 和同学与学长的笔记整理而成。
介绍 C&#43;&#43; 历史 先跳过。。。
结构化编程部分 强制类型转换 article link=&#34;/posts/C&#43;&#43;拾遗/C&#43;&#43;-强制类型转换&#34; &gt;}}
表达式的副作用 副作用，就是一个过程是否会修改参与的变量的性质。
在表达式中，有副作用的运算符：= &#43;= &#43;&#43; &lt;&lt; 等等 无副作用的运算符：&#43; &amp;&amp; 等等
decltype 和 auto 有相似之处。
auto 和 decltype 都用在声明变量上，都是基于 RTTI 机制实现的。
auto 是对初始化的右值进行类型推导，然后给声明的变量确定类型、赋值。
decltype 是对传入的参数类型进行类型推导，然后本身就作为这个类型的名称。
int x = 0; int&amp; ref = x; auto ref1 = x; decltype(ref) ref2 = x; // equals to &#34;int&amp; ref2 = x&#34; 既然本身就作为这个类型的名称，我们也可以结合 using 和 typedef：
int x = 0; int&amp; ref = x; using int_ref = decltype(ref); 参考 C&#43;&#43;11特性：decltype关键字 - melonstreet - 博客园">


  
</head>

<body class="bg-nord0 font-sans text-nord6 subpixel-antialiased flex flex-col h-screen justify-between tracking-wide">
  <header class="bg-nord1 py-3">
    <div class="container flex justify-between items-center flex-wrap">
  <div class="text-lg font-bold">
    <a href="/">
      
      Runz&#39;s Blog
      
    </a>
  </div>
  <div class="flex items-center flex-wrap">
    

    
    <ul class="flex items-center flex-wrap">
      
      <li class="ml-4">
        <a class="hover:text-white" href="/" title="Home page">Home</a>
      </li>
      
      <li class="ml-4">
        <a class="hover:text-white" href="/posts/" title="Posts page">Posts</a>
      </li>
      
      <li class="ml-4">
        <a class="hover:text-white" href="/series/" title="Series page">Series</a>
      </li>
      
      <li class="ml-4">
        <a class="hover:text-white" href="/about/" title="About page">About</a>
      </li>
      
    </ul>
    
  </div>
</div>

  </header>
  
  <main class="container mb-auto mt-20">
  
  <article>
    <header class="text-center py-20">
      <h1 class="text-5xl pb-2">C&#43;&#43;期末复习</h1>

      <div class="flex place-content-center">
        

        <time datetime="2024-12-24T00:00:00Z">
          December 24, 2024
        </time>
      </div>
    </header>

    <section class="bg-nord1 rounded-lg p-32 shadow">
      <p>根据上课 PPT 和同学与学长的笔记整理而成。</p>
<h2 id="介绍">介绍</h2>
<h3 id="c-历史">C++ 历史</h3>
<p>先跳过。。。</p>
<h2 id="结构化编程部分">结构化编程部分</h2>
<h3 id="强制类型转换">强制类型转换</h3>
<p>article link=&quot;/posts/C++拾遗/C++-强制类型转换&quot; &gt;}}</p>
<h3 id="表达式的副作用">表达式的副作用</h3>
<p>副作用，就是一个过程是否会修改参与的变量的性质。</p>
<p>在表达式中，有副作用的运算符：<code>=</code> <code>+=</code> <code>++</code> <code>&lt;&lt;</code> 等等
无副作用的运算符：<code>+</code> <code>&amp;&amp;</code> 等等</p>
<hr>
<h3 id="decltype">decltype</h3>
<p>和 auto 有相似之处。</p>
<p>auto 和 decltype 都用在声明变量上，都是基于 RTTI 机制实现的。</p>
<p>auto 是对<strong>初始化</strong>的右值进行类型推导，然后给声明的变量确定类型、赋值。</p>
<p>decltype 是对传入的参数类型进行类型推导，然后本身就作为这个类型的名称。</p>
<div class="highlight"><pre tabindex="0" style="color:#d8dee9;background-color:#2e3440;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="color:#81a1c1">int</span> x <span style="color:#81a1c1">=</span> <span style="color:#b48ead">0</span><span style="color:#eceff4">;</span>
</span></span><span style="display:flex;"><span><span style="color:#81a1c1">int</span><span style="color:#81a1c1">&amp;</span> ref <span style="color:#81a1c1">=</span> x<span style="color:#eceff4">;</span>
</span></span><span style="display:flex;"><span><span style="color:#81a1c1;font-weight:bold">auto</span> ref1 <span style="color:#81a1c1">=</span> x<span style="color:#eceff4">;</span>
</span></span><span style="display:flex;"><span><span style="color:#81a1c1;font-weight:bold">decltype</span><span style="color:#eceff4">(</span>ref<span style="color:#eceff4">)</span> ref2 <span style="color:#81a1c1">=</span> x<span style="color:#eceff4">;</span>  <span style="color:#616e87;font-style:italic">// equals to &#34;int&amp; ref2 = x&#34;
</span></span></span></code></pre></div><p>既然本身就作为这个类型的名称，我们也可以结合 using 和 typedef：</p>
<div class="highlight"><pre tabindex="0" style="color:#d8dee9;background-color:#2e3440;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="color:#81a1c1">int</span> x <span style="color:#81a1c1">=</span> <span style="color:#b48ead">0</span><span style="color:#eceff4">;</span>
</span></span><span style="display:flex;"><span><span style="color:#81a1c1">int</span><span style="color:#81a1c1">&amp;</span> ref <span style="color:#81a1c1">=</span> x<span style="color:#eceff4">;</span>
</span></span><span style="display:flex;"><span><span style="color:#81a1c1;font-weight:bold">using</span> int_ref <span style="color:#81a1c1">=</span> <span style="color:#81a1c1;font-weight:bold">decltype</span><span style="color:#eceff4">(</span>ref<span style="color:#eceff4">);</span>
</span></span></code></pre></div><h4 id="参考">参考</h4>
<p><a href="https://www.cnblogs.com/QG-whz/p/4952980.html">C++11特性：decltype关键字 - melonstreet - 博客园</a></p>
<h3 id="聚合初始化">聚合初始化</h3>
<p>聚合初始化的规则比较复杂，考试应该不涉及。下面简单举几个例子：</p>
<div class="highlight"><pre tabindex="0" style="color:#d8dee9;background-color:#2e3440;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="color:#81a1c1">int</span><span style="color:#eceff4">[]</span> arr <span style="color:#81a1c1">=</span> <span style="color:#eceff4">{</span><span style="color:#b48ead">1</span><span style="color:#eceff4">,</span> <span style="color:#b48ead">2</span><span style="color:#eceff4">,</span> <span style="color:#b48ead">3</span><span style="color:#eceff4">};</span>
</span></span><span style="display:flex;"><span><span style="color:#81a1c1">int</span><span style="color:#eceff4">[</span><span style="color:#b48ead">5</span><span style="color:#eceff4">]</span> arr1 <span style="color:#81a1c1">=</span> <span style="color:#eceff4">{</span><span style="color:#b48ead">1</span><span style="color:#eceff4">,</span> <span style="color:#b48ead">2</span><span style="color:#eceff4">,</span> <span style="color:#b48ead">3</span><span style="color:#eceff4">,</span> <span style="color:#b48ead">4</span><span style="color:#eceff4">};</span>
</span></span><span style="display:flex;"><span>vector<span style="color:#81a1c1">&lt;</span><span style="color:#81a1c1">int</span><span style="color:#81a1c1">&gt;</span> arr2<span style="color:#eceff4">{</span><span style="color:#b48ead">1</span><span style="color:#eceff4">,</span> <span style="color:#b48ead">2</span><span style="color:#eceff4">,</span> <span style="color:#b48ead">3</span><span style="color:#eceff4">};</span>
</span></span><span style="display:flex;"><span>vector<span style="color:#81a1c1">&lt;</span>vector<span style="color:#81a1c1">&lt;</span><span style="color:#81a1c1">int</span><span style="color:#81a1c1">&gt;&gt;</span> arr3<span style="color:#eceff4">{{</span><span style="color:#b48ead">1</span><span style="color:#eceff4">,</span> <span style="color:#b48ead">2</span><span style="color:#eceff4">,</span> <span style="color:#b48ead">3</span><span style="color:#eceff4">},</span> <span style="color:#eceff4">{</span><span style="color:#b48ead">4</span><span style="color:#eceff4">,</span> <span style="color:#b48ead">5</span><span style="color:#eceff4">},</span> <span style="color:#eceff4">{</span><span style="color:#b48ead">6</span><span style="color:#eceff4">}};</span>
</span></span></code></pre></div><h3 id="union-实现多态">Union 实现多态</h3>
<p>父类联合体包含所有子类结构体。然后记得给子类加上类型的枚举。</p>
<p>例子中的声明顺序只是为了方便查看，不用在意是否能编译通过。</p>
<div class="highlight"><pre tabindex="0" style="color:#d8dee9;background-color:#2e3440;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="color:#616e87;font-style:italic">// Base
</span></span></span><span style="display:flex;"><span><span style="color:#616e87;font-style:italic"></span><span style="color:#81a1c1;font-weight:bold">union</span> <span style="color:#8fbcbb">FIGURE</span>
</span></span><span style="display:flex;"><span><span style="color:#eceff4">{</span>
</span></span><span style="display:flex;"><span>	FIGURE_TYPE t<span style="color:#eceff4">;</span>
</span></span><span style="display:flex;"><span>	Line line<span style="color:#eceff4">;</span>
</span></span><span style="display:flex;"><span>	Rectangle rect<span style="color:#eceff4">;</span>
</span></span><span style="display:flex;"><span>	Ellipse ellipse<span style="color:#eceff4">;</span>
</span></span><span style="display:flex;"><span><span style="color:#eceff4">};</span>
</span></span><span style="display:flex;"><span><span style="color:#616e87;font-style:italic">// Derived
</span></span></span><span style="display:flex;"><span><span style="color:#616e87;font-style:italic"></span><span style="color:#81a1c1;font-weight:bold">struct</span> <span style="color:#8fbcbb">Line</span><span style="color:#eceff4">{</span>
</span></span><span style="display:flex;"><span>	FIGURE_TYPE t<span style="color:#eceff4">;</span>
</span></span><span style="display:flex;"><span>	<span style="color:#81a1c1">int</span> x<span style="color:#eceff4">,</span> y<span style="color:#eceff4">;</span>
</span></span><span style="display:flex;"><span><span style="color:#eceff4">};</span>
</span></span><span style="display:flex;"><span><span style="color:#81a1c1;font-weight:bold">struct</span> <span style="color:#8fbcbb">Ellipse</span>
</span></span><span style="display:flex;"><span><span style="color:#eceff4">{</span> 
</span></span><span style="display:flex;"><span>	FIGURE_TYPE t<span style="color:#eceff4">;</span>
</span></span><span style="display:flex;"><span>	<span style="color:#81a1c1">int</span> x<span style="color:#eceff4">,</span> y<span style="color:#eceff4">,</span> r<span style="color:#eceff4">;</span>
</span></span><span style="display:flex;"><span><span style="color:#eceff4">};</span>
</span></span><span style="display:flex;"><span><span style="color:#81a1c1;font-weight:bold">struct</span> <span style="color:#8fbcbb">Rectangle</span><span style="color:#eceff4">{</span>
</span></span><span style="display:flex;"><span>	FIGURE_TYPE t<span style="color:#eceff4">;</span>
</span></span><span style="display:flex;"><span>	<span style="color:#81a1c1">int</span> left<span style="color:#eceff4">,</span> top<span style="color:#eceff4">,</span> right<span style="color:#eceff4">,</span> bottom<span style="color:#eceff4">;</span>
</span></span><span style="display:flex;"><span><span style="color:#eceff4">};</span>
</span></span></code></pre></div><h3 id="struct-对齐">Struct 对齐</h3>
<p>先讨论没有 <code>#pragma pack</code>  的情况，如何确定 struct 的对齐与大小。</p>
<p>首先有如下规则：</p>
<ul>
<li>结构体的成员<strong>声明的顺序</strong>就是在<strong>内存中的顺序</strong></li>
<li>某一个成员相较于 struct 开头的偏移量，必须是自身大小的整数倍</li>
<li>整个结构体大小必须是最大成员大小的整数倍</li>
</ul>
<p>第一条规则，确定了成员的顺序就是声明的顺序。</p>
<p>我们按照声明的顺序，一个一个地应用第二条规则。不满足规则的，就补齐。</p>
<p>最后，看满不满足第三条规则。不满足就补齐。</p>
<p>有了 pragma 之后，每个数据成员的对齐，按照#pragma pack指定的数值和自身对齐模数中较小的那个。</p>
<hr>
<h3 id="cincout-输入输出操纵符">cin/cout 输入/输出操纵符</h3>
<p>操纵符是令代码能以 operator&laquo; 或 operator&raquo; 控制输入/输出流的帮助函数。</p>
<p>包括的一些感觉比较重要的操纵符如下
输入用：</p>
<ul>
<li><code>skipws</code></li>
<li><code>get_time</code>
输出用</li>
<li><code>showbase</code> <code>setbase</code></li>
<li><code>uppercase</code></li>
<li><code>dec</code> <code>hex</code> <code>oct</code></li>
<li><code>setprecision</code></li>
<li><code>setw</code></li>
<li><code>put_time</code></li>
</ul>
<p>可以翻阅 cppreference -&gt; 输入输出库 -&gt; 输入输出操纵符</p>
<h3 id="tuple">Tuple</h3>
<p>大名叫 <code>std::tuple</code>。元组。能保存任意数量的任意类型的成员变量。可以看成一个类型安全、使用灵活便捷的结构体。</p>
<p>头文件 <code>&lt;tuple&gt;</code></p>
<p>tuple 是静态的，需要在声明的时候就确定要保存哪些类型：</p>
<div class="highlight"><pre tabindex="0" style="color:#d8dee9;background-color:#2e3440;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span>std<span style="color:#81a1c1">::</span>tuple<span style="color:#81a1c1">&lt;</span><span style="color:#81a1c1">int</span><span style="color:#eceff4">,</span> <span style="color:#81a1c1">double</span><span style="color:#eceff4">,</span> std<span style="color:#81a1c1">::</span>string<span style="color:#eceff4">,</span> <span style="color:#81a1c1">char</span><span style="color:#81a1c1">&gt;</span> t<span style="color:#eceff4">;</span>
</span></span></code></pre></div><p>初始化：</p>
<div class="highlight"><pre tabindex="0" style="color:#d8dee9;background-color:#2e3440;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="color:#616e87;font-style:italic">// constructor
</span></span></span><span style="display:flex;"><span><span style="color:#616e87;font-style:italic"></span>std<span style="color:#81a1c1">::</span>tuple<span style="color:#81a1c1">&lt;</span><span style="color:#81a1c1">int</span><span style="color:#eceff4">,</span> <span style="color:#81a1c1">double</span><span style="color:#eceff4">,</span> std<span style="color:#81a1c1">::</span>string<span style="color:#eceff4">,</span> <span style="color:#81a1c1">char</span><span style="color:#81a1c1">&gt;</span> t<span style="color:#eceff4">(</span><span style="color:#b48ead">1</span><span style="color:#eceff4">,</span> <span style="color:#b48ead">2.0</span><span style="color:#eceff4">,</span> <span style="color:#a3be8c">&#34;hello&#34;</span><span style="color:#eceff4">,</span> <span style="color:#a3be8c">&#39;c&#39;</span><span style="color:#eceff4">);</span>
</span></span><span style="display:flex;"><span><span style="color:#616e87;font-style:italic">// make_tuple
</span></span></span><span style="display:flex;"><span><span style="color:#616e87;font-style:italic"></span>t <span style="color:#81a1c1">=</span> make_tuple<span style="color:#eceff4">(</span><span style="color:#b48ead">1</span><span style="color:#eceff4">,</span> <span style="color:#b48ead">2.0</span><span style="color:#eceff4">,</span> <span style="color:#a3be8c">&#34;hello&#34;</span><span style="color:#eceff4">,</span> <span style="color:#a3be8c">&#39;c&#39;</span><span style="color:#eceff4">);</span>
</span></span></code></pre></div><p>使用 <code>std::get&lt;&gt;</code> 获取元素：</p>
<div class="highlight"><pre tabindex="0" style="color:#d8dee9;background-color:#2e3440;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="color:#81a1c1">int</span> first <span style="color:#81a1c1">=</span> std<span style="color:#81a1c1">::</span>get<span style="color:#81a1c1">&lt;</span><span style="color:#b48ead">0</span><span style="color:#81a1c1">&gt;</span><span style="color:#eceff4">(</span>t<span style="color:#eceff4">);</span>
</span></span><span style="display:flex;"><span><span style="color:#81a1c1">int</span> i <span style="color:#81a1c1">=</span> <span style="color:#b48ead">1</span><span style="color:#eceff4">;</span>
</span></span><span style="display:flex;"><span>std<span style="color:#81a1c1">::</span>get<span style="color:#81a1c1">&lt;</span>i<span style="color:#81a1c1">&gt;</span><span style="color:#eceff4">(</span>t<span style="color:#eceff4">);</span> <span style="color:#616e87;font-style:italic">// Wrong!!! Cannot use variable
</span></span></span></code></pre></div><p>使用 <code>std::tie</code> 解包：</p>
<div class="highlight"><pre tabindex="0" style="color:#d8dee9;background-color:#2e3440;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="color:#81a1c1">int</span> a<span style="color:#eceff4">;</span>
</span></span><span style="display:flex;"><span><span style="color:#81a1c1">double</span> b<span style="color:#eceff4">;</span>
</span></span><span style="display:flex;"><span>std<span style="color:#81a1c1">::</span>string c<span style="color:#eceff4">;</span>
</span></span><span style="display:flex;"><span><span style="color:#81a1c1">char</span> d<span style="color:#eceff4">;</span>
</span></span><span style="display:flex;"><span>std<span style="color:#81a1c1">::</span>tie<span style="color:#eceff4">(</span>a<span style="color:#eceff4">,</span> b<span style="color:#eceff4">,</span> c<span style="color:#eceff4">,</span> d<span style="color:#eceff4">)</span> <span style="color:#81a1c1">=</span> t<span style="color:#eceff4">;</span>
</span></span></code></pre></div><p>使用 <code>std::tuple_size</code> 获取 tuple 元素个数：</p>
<div class="highlight"><pre tabindex="0" style="color:#d8dee9;background-color:#2e3440;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="color:#81a1c1">int</span> el_count <span style="color:#81a1c1">=</span> std<span style="color:#81a1c1">::</span>tuple_size<span style="color:#81a1c1">&lt;</span><span style="color:#81a1c1;font-weight:bold">decltype</span><span style="color:#eceff4">(</span>t<span style="color:#eceff4">)</span><span style="color:#81a1c1">&gt;::</span>value<span style="color:#eceff4">;</span>
</span></span></code></pre></div><h4 id="参考-1">参考</h4>
<p><a href="https://www.cnblogs.com/RioTian/p/14325292.html">C++ tuple（STL tuple）模板用法详解 - RioTian - 博客园</a></p>
<p><a href="https://blog.csdn.net/sevenjoin/article/details/88420885">C++ tuple元组的基本用法(总结)-CSDN博客</a></p>
<h3 id="optional">Optional</h3>
<p>和 java 的 optional 如出一辙。大致是为了包装函数返回值而生的。</p>
<p>头文件 <code>&lt;optinal&gt;</code></p>
<p>optional 可以理解为包含了两个信息：函数运行信息（成功，失败）、函数返回值</p>
<p>声明 optional：</p>
<div class="highlight"><pre tabindex="0" style="color:#d8dee9;background-color:#2e3440;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span>std<span style="color:#81a1c1">::</span>optional<span style="color:#81a1c1">&lt;</span>T<span style="color:#81a1c1">&gt;</span> opt<span style="color:#eceff4">;</span>         <span style="color:#616e87;font-style:italic">// 不包含值的 optional
</span></span></span><span style="display:flex;"><span><span style="color:#616e87;font-style:italic"></span>std<span style="color:#81a1c1">::</span>nullopt<span style="color:#eceff4">;</span>                 <span style="color:#616e87;font-style:italic">// 不包含值的 optional，宏定义好了
</span></span></span><span style="display:flex;"><span><span style="color:#616e87;font-style:italic"></span>std<span style="color:#81a1c1">::</span>optional<span style="color:#81a1c1">&lt;</span>T<span style="color:#81a1c1">&gt;</span> opt<span style="color:#eceff4">(</span>value<span style="color:#eceff4">);</span>  <span style="color:#616e87;font-style:italic">// 包含 value
</span></span></span><span style="display:flex;"><span><span style="color:#616e87;font-style:italic"></span>make_optional<span style="color:#81a1c1">&lt;</span>T<span style="color:#81a1c1">&gt;</span><span style="color:#eceff4">(</span>value<span style="color:#eceff4">);</span>      <span style="color:#616e87;font-style:italic">// make 方法
</span></span></span></code></pre></div><p>函数失败：</p>
<div class="highlight"><pre tabindex="0" style="color:#d8dee9;background-color:#2e3440;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="color:#81a1c1;font-weight:bold">return</span> std<span style="color:#81a1c1">::</span>nullopt<span style="color:#eceff4">;</span>
</span></span></code></pre></div><p>函数成功，返回 result：</p>
<div class="highlight"><pre tabindex="0" style="color:#d8dee9;background-color:#2e3440;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="color:#81a1c1;font-weight:bold">return</span> make_optional<span style="color:#81a1c1">&lt;</span>T<span style="color:#81a1c1">&gt;</span><span style="color:#eceff4">(</span>result<span style="color:#eceff4">);</span>
</span></span></code></pre></div><p>函数调用方：
使用 <code>has_value</code> 检查函数返回是否为空（函数执行是否失败）
如果成功，可以直接将 optional 当成结果来取值。注意，这里 value 类似迭代器，是一个指向结果的指针。</p>
<div class="highlight"><pre tabindex="0" style="color:#d8dee9;background-color:#2e3440;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="color:#81a1c1;font-weight:bold">auto</span> result <span style="color:#81a1c1">=</span> foo<span style="color:#eceff4">();</span>
</span></span><span style="display:flex;"><span><span style="color:#81a1c1;font-weight:bold">if</span><span style="color:#eceff4">(</span><span style="color:#81a1c1">!</span>result<span style="color:#eceff4">.</span>has_value<span style="color:#eceff4">())</span> <span style="color:#eceff4">{</span>
</span></span><span style="display:flex;"><span>	cout<span style="color:#81a1c1">&lt;&lt;</span> <span style="color:#a3be8c">&#34;failed&#34;</span><span style="color:#eceff4">;</span>
</span></span><span style="display:flex;"><span><span style="color:#eceff4">}</span>
</span></span><span style="display:flex;"><span><span style="color:#81a1c1;font-weight:bold">else</span> <span style="color:#eceff4">{</span>
</span></span><span style="display:flex;"><span>	result<span style="color:#81a1c1">-&gt;</span>xxx <span style="color:#eceff4">...;</span>       <span style="color:#616e87;font-style:italic">// 直接将 optional 对象当成返回结果的指针用
</span></span></span><span style="display:flex;"><span><span style="color:#616e87;font-style:italic"></span><span style="color:#eceff4">}</span>
</span></span></code></pre></div><h4 id="参考-2">参考</h4>
<p><a href="https://zhuanlan.zhihu.com/p/64985296">C++17 新特性之 std::optional（上） - 知乎</a></p>
<p><a href="https://blog.csdn.net/haokan123456789/article/details/136099479">C++三剑客之std::optional(一) : 使用详解_c++ optional-CSDN博客</a></p>
<h3 id="pair">Pair</h3>
<p>特化的 tuple。只能放两个元素。</p>
<p>头文件 <code>&lt;utility&gt;</code></p>
<p>用 first 和 second 来访问两个元素。</p>
<p>make_pair 来创建一个 pair。通过 tie 来解包。和 tuple 一毛一样。</p>
<h3 id="variant">Variant</h3>
<p>类型安全的 union。但不允许包含引用、数组、void。</p>
<p>头文件 <code>&lt;variant&gt;</code></p>
<p>创建与访问：</p>
<div class="highlight"><pre tabindex="0" style="color:#d8dee9;background-color:#2e3440;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span>std<span style="color:#81a1c1">::</span>variant<span style="color:#81a1c1">&lt;</span><span style="color:#81a1c1">int</span><span style="color:#eceff4">,</span> <span style="color:#81a1c1">float</span><span style="color:#eceff4">,</span> <span style="color:#81a1c1">double</span><span style="color:#81a1c1">&gt;</span> var<span style="color:#eceff4">;</span>
</span></span><span style="display:flex;"><span>var <span style="color:#81a1c1">=</span> <span style="color:#a3be8c">&#34;abc&#34;</span><span style="color:#eceff4">;</span>  <span style="color:#616e87;font-style:italic">// or var.emplace(&#34;abc&#34;)
</span></span></span><span style="display:flex;"><span><span style="color:#616e87;font-style:italic"></span>std<span style="color:#81a1c1">::</span>get<span style="color:#81a1c1">&lt;</span>std<span style="color:#81a1c1">::</span>string<span style="color:#81a1c1">&gt;</span><span style="color:#eceff4">(</span>var<span style="color:#eceff4">);</span>  <span style="color:#616e87;font-style:italic">// &#34;abc&#34;
</span></span></span><span style="display:flex;"><span><span style="color:#616e87;font-style:italic"></span>std<span style="color:#81a1c1">::</span>get<span style="color:#81a1c1">&lt;</span><span style="color:#81a1c1">int</span><span style="color:#81a1c1">&gt;</span><span style="color:#eceff4">(</span>var<span style="color:#eceff4">);</span>          <span style="color:#616e87;font-style:italic">// exception std::bad_variant_access
</span></span></span><span style="display:flex;"><span><span style="color:#616e87;font-style:italic"></span>
</span></span><span style="display:flex;"><span>var <span style="color:#81a1c1">=</span> <span style="color:#b48ead">0.1f</span><span style="color:#eceff4">;</span>
</span></span><span style="display:flex;"><span><span style="color:#81a1c1;font-weight:bold">const</span> <span style="color:#81a1c1;font-weight:bold">auto</span> intPtr <span style="color:#81a1c1">=</span> std<span style="color:#81a1c1">::</span>get_if<span style="color:#81a1c1">&lt;</span><span style="color:#81a1c1">float</span><span style="color:#81a1c1">&gt;</span><span style="color:#eceff4">(</span><span style="color:#81a1c1">&amp;</span>var<span style="color:#eceff4">)</span>  <span style="color:#616e87;font-style:italic">// safe get
</span></span></span></code></pre></div><p>检查当前是否持有某类型：</p>
<p>使用 <code>std::holds_alternative</code></p>
<div class="highlight"><pre tabindex="0" style="color:#d8dee9;background-color:#2e3440;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="color:#81a1c1;font-weight:bold">if</span><span style="color:#eceff4">(</span>std<span style="color:#81a1c1">::</span>holds_alternative<span style="color:#81a1c1">&lt;</span><span style="color:#81a1c1">int</span><span style="color:#81a1c1">&gt;</span><span style="color:#eceff4">(</span>var<span style="color:#eceff4">))</span> <span style="color:#eceff4">{</span>
</span></span><span style="display:flex;"><span>	std<span style="color:#81a1c1">::</span>cout<span style="color:#81a1c1">&lt;&lt;</span><span style="color:#a3be8c">&#34;var holds int&#34;</span><span style="color:#81a1c1">&lt;&lt;</span>endl<span style="color:#eceff4">;</span>
</span></span><span style="display:flex;"><span><span style="color:#eceff4">}</span>
</span></span></code></pre></div><p>空状态：</p>
<p>即 variant 什么都没放的 “无值” 状态。用 <code>std::monostate</code> 表示</p>
<div class="highlight"><pre tabindex="0" style="color:#d8dee9;background-color:#2e3440;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span>std<span style="color:#81a1c1">::</span>variant<span style="color:#81a1c1">&lt;</span>std<span style="color:#81a1c1">::</span>monostate<span style="color:#eceff4">,</span> <span style="color:#81a1c1">int</span><span style="color:#81a1c1">&gt;</span> var<span style="color:#eceff4">;</span>
</span></span></code></pre></div><h4 id="参考-3">参考</h4>
<p><a href="https://www.cnblogs.com/linxmouse/p/18436326">C++17 std::variant 详解：概念、用法和实现细节 - 非法关键字 - 博客园</a></p>
<h3 id="any">Any</h3>
<p>类型安全的，能存放任意类型数据的容器(void*)。</p>
<p>头文件 <code>any</code></p>
<p>声明与赋值：</p>
<div class="highlight"><pre tabindex="0" style="color:#d8dee9;background-color:#2e3440;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span>std<span style="color:#81a1c1">::</span>any a<span style="color:#eceff4">;</span>
</span></span><span style="display:flex;"><span>a <span style="color:#81a1c1">=</span> <span style="color:#b48ead">1</span><span style="color:#eceff4">;</span>           <span style="color:#616e87;font-style:italic">// store an integer
</span></span></span><span style="display:flex;"><span><span style="color:#616e87;font-style:italic"></span>a<span style="color:#eceff4">.</span>emplace<span style="color:#eceff4">(</span><span style="color:#b48ead">1</span><span style="color:#eceff4">);</span>    <span style="color:#616e87;font-style:italic">// same effect as above
</span></span></span><span style="display:flex;"><span><span style="color:#616e87;font-style:italic"></span>a <span style="color:#81a1c1">=</span> make_any<span style="color:#eceff4">(</span><span style="color:#b48ead">1</span><span style="color:#eceff4">)</span>  <span style="color:#616e87;font-style:italic">// make method
</span></span></span></code></pre></div><p>取出使用：</p>
<div class="highlight"><pre tabindex="0" style="color:#d8dee9;background-color:#2e3440;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span>a <span style="color:#81a1c1">=</span> <span style="color:#b48ead">1</span><span style="color:#eceff4">;</span>
</span></span><span style="display:flex;"><span>std<span style="color:#81a1c1">::</span>any_cast<span style="color:#81a1c1">&lt;</span><span style="color:#81a1c1">int</span><span style="color:#81a1c1">&gt;</span><span style="color:#eceff4">(</span>a<span style="color:#eceff4">);</span>    <span style="color:#616e87;font-style:italic">// returns 1
</span></span></span><span style="display:flex;"><span><span style="color:#616e87;font-style:italic"></span>std<span style="color:#81a1c1">::</span>any_cast<span style="color:#81a1c1">&lt;</span><span style="color:#81a1c1">char</span><span style="color:#81a1c1">&gt;</span><span style="color:#eceff4">(</span>a<span style="color:#eceff4">);</span>   <span style="color:#616e87;font-style:italic">// throw std::bad_any_cast exception
</span></span></span></code></pre></div><p>检查是否有值：</p>
<p>使用 <code>has_value</code> 成员函数。返回 bool。</p>
<div class="highlight"><pre tabindex="0" style="color:#d8dee9;background-color:#2e3440;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span>std<span style="color:#81a1c1">::</span>any a<span style="color:#eceff4">;</span>
</span></span><span style="display:flex;"><span>a<span style="color:#eceff4">.</span>has_value<span style="color:#eceff4">();</span>  <span style="color:#616e87;font-style:italic">// false
</span></span></span><span style="display:flex;"><span><span style="color:#616e87;font-style:italic"></span>a <span style="color:#81a1c1">=</span> <span style="color:#b48ead">1</span><span style="color:#eceff4">;</span>
</span></span><span style="display:flex;"><span>a<span style="color:#eceff4">.</span>has_value<span style="color:#eceff4">();</span>  <span style="color:#616e87;font-style:italic">// true
</span></span></span></code></pre></div><p>检查所存储元素类型：</p>
<p>使用 type 成员函数。返回成员类型的 typeid</p>
<div class="highlight"><pre tabindex="0" style="color:#d8dee9;background-color:#2e3440;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span>a <span style="color:#81a1c1">=</span> <span style="color:#b48ead">1</span><span style="color:#eceff4">;</span>
</span></span><span style="display:flex;"><span>a<span style="color:#eceff4">.</span>type<span style="color:#eceff4">()</span> <span style="color:#81a1c1">==</span> <span style="color:#81a1c1;font-weight:bold">typeid</span><span style="color:#eceff4">(</span><span style="color:#81a1c1">int</span><span style="color:#eceff4">)</span>  <span style="color:#616e87;font-style:italic">// true
</span></span></span><span style="display:flex;"><span><span style="color:#616e87;font-style:italic"></span>a<span style="color:#eceff4">.</span>type<span style="color:#eceff4">()</span> <span style="color:#81a1c1">==</span> <span style="color:#81a1c1;font-weight:bold">typeid</span><span style="color:#eceff4">(</span><span style="color:#81a1c1">char</span><span style="color:#eceff4">)</span> <span style="color:#616e87;font-style:italic">// false
</span></span></span></code></pre></div><h3 id="newdelete">new/delete</h3>
<p>在使用 new 创建数组时，前 4 个字节会存放声明的数组长度。</p>
<p>方便 delete[] 时，知道要释放多少空间。</p>
<h3 id="raii-与智能指针">RAII 与智能指针</h3>
<p>article link=&quot;/posts/C++拾遗/杂项&quot; &gt;}}</p>
<hr>
<h3 id="c-数组特性">C 数组特性</h3>
<p>article link=&quot;/posts/C++拾遗/指针、引用与数组&quot; &gt;}}</p>
<h3 id="指针作为函数参数">指针作为函数参数</h3>
<p>为什么</p>
<ul>
<li>提高传输效率，不用拷贝传递的实参</li>
<li>使用函数的副作用，改变传入参数的值。如果不想要副作用，可以加 const</li>
</ul>
<h3 id="函数指针">函数指针</h3>
<p>没啥讲的。方便实现函数的动态调用。然后就是 lambda 函数。</p>
<p>函数指针的解析，看：</p>
<p>article link=&quot;/posts/C++拾遗/类型解释&quot; &gt;}}</p>
<h3 id="函数执行机制">函数执行机制</h3>
<p>如下只是大致的步骤，会根据具体的函数调用约定而有些许不同。</p>
<ul>
<li>建立被调用函数的栈空间</li>
<li>参数传递：
<ul>
<li>值传递 (call by value)</li>
<li>引用传递 (call by reference)</li>
</ul>
</li>
<li>保存调用函数的运行状态
<ul>
<li>返回地址</li>
<li>调用者的 ebp</li>
</ul>
</li>
<li>将控制转交被调函数
<ul>
<li>设置新的 ebp 和 esp</li>
</ul>
</li>
<li>恢复上下文
<ul>
<li>恢复调用者 ebp</li>
<li>恢复返回地址</li>
</ul>
</li>
</ul>
<h4 id="函数调用约定">函数调用约定</h4>
<p>函数调用约定回答了如下问题：</p>
<ul>
<li>当参数个数多于一个时，按照什么顺序把参数压入堆栈</li>
<li>函数调用后，由谁来把堆栈恢复原装</li>
</ul>
<h5 id="stdcall">stdcall</h5>
<p>pascal 风格的调用约定。</p>
<div class="highlight"><pre tabindex="0" style="color:#d8dee9;background-color:#2e3440;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="color:#81a1c1">int</span> <span style="color:#81a1c1;font-weight:bold">__stdcall</span> <span style="color:#88c0d0">foo</span><span style="color:#eceff4">(</span><span style="color:#81a1c1">int</span> a<span style="color:#eceff4">,</span> <span style="color:#81a1c1">int</span> b<span style="color:#eceff4">);</span>
</span></span></code></pre></div><ul>
<li>参数从右向左压栈</li>
<li>函数自己恢复堆栈
例子中，被调用者 foo 的返回的汇编为 <code>ret 8</code>，表示清除 a 和 b 参数占的堆栈</li>
<li>函数名的标签变为 <code>_</code> + <code>函数名</code> + <code>@</code> + <code>参数大小</code>
例子中，函数的标签为 <code>_foo@8</code></li>
</ul>
<h5 id="cdecl">cdecl</h5>
<p>C 调用约定。是 C 语言默认的调用约定。</p>
<div class="highlight"><pre tabindex="0" style="color:#d8dee9;background-color:#2e3440;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span><span style="color:#81a1c1">int</span> <span style="color:#81a1c1;font-weight:bold">__cdecl</span> <span style="color:#88c0d0">foo</span><span style="color:#eceff4">(</span><span style="color:#81a1c1">int</span> a<span style="color:#eceff4">,</span> <span style="color:#81a1c1">int</span> b<span style="color:#eceff4">);</span>
</span></span><span style="display:flex;"><span><span style="color:#81a1c1">int</span> <span style="color:#88c0d0">foo</span><span style="color:#eceff4">(</span><span style="color:#81a1c1">int</span> a<span style="color:#eceff4">,</span> <span style="color:#81a1c1">int</span> b<span style="color:#eceff4">);</span>            <span style="color:#616e87;font-style:italic">// default is cdecl
</span></span></span></code></pre></div><ul>
<li>参数从右往左压栈</li>
<li>调用者恢复堆栈
被调用者直接用 <code>ret</code> 返回，不恢复堆栈。
调用者在 <code>call foo</code> 之后，使用 <code>add esp, 8</code> 来恢复两个 int 参数的堆栈。</li>
<li>函数名标签 <code>_</code> + <code>函数名</code></li>
</ul>
<p>这种调用约定能支持可变参数。可变参数在声明里面是放在最右边的，这样保证了左边的参数先入栈，能通过 ebp 确定，从而确认可变参数。并且调用者可以根据自己传的参数大小来恢复堆栈。</p>
<h5 id="fastcall">fastcall</h5>
<p>和 stdcall 类似，但是更 fast，因为用到了寄存器。</p>
<div class="highlight"><pre tabindex="0" style="color:#d8dee9;background-color:#2e3440;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="color:#81a1c1">int</span> <span style="color:#81a1c1;font-weight:bold">__fastcall</span> <span style="color:#88c0d0">foo</span><span style="color:#eceff4">(</span><span style="color:#81a1c1">int</span> a<span style="color:#eceff4">,</span> <span style="color:#81a1c1">int</span> b<span style="color:#eceff4">);</span>
</span></span></code></pre></div><ul>
<li>第一个和第二个声明的大小小于等于 DWORD 的参数，通过 ecx 和 edx 传
例子中，a 和 b 分别放到 ecx 和 edx 中。然后就没有参数需要压栈了。</li>
<li>其他的参数还是按 stdcall 的方式压栈</li>
<li>被调用者清理堆栈</li>
</ul>
<h5 id="thiscall">thiscall</h5>
<p>C++ 默认的调用约定。特殊处理了 this 指针。</p>
<div class="highlight"><pre tabindex="0" style="color:#d8dee9;background-color:#2e3440;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="color:#81a1c1">int</span> <span style="color:#88c0d0">foo</span><span style="color:#eceff4">(</span><span style="color:#81a1c1">int</span> a<span style="color:#eceff4">,</span> <span style="color:#81a1c1">int</span> b<span style="color:#eceff4">);</span>
</span></span><span style="display:flex;"><span><span style="color:#81a1c1">int</span> __thiscall <span style="color:#88c0d0">foo</span><span style="color:#eceff4">(</span><span style="color:#81a1c1">int</span> a<span style="color:#eceff4">,</span> <span style="color:#81a1c1">int</span> b<span style="color:#eceff4">);</span>  <span style="color:#616e87;font-style:italic">// wrong! no need for &#39;__thiscall&#39;
</span></span></span></code></pre></div><ul>
<li>参数从右向左压栈</li>
<li>参数个数确定的情况下，this 指针通过 ecx 传递；有可变参数，this 指针最后被入栈</li>
<li>参数个数确定，被调用者清理堆栈；可变参数，调用者清理堆栈</li>
</ul>
<h4 id="参考-4">参考</h4>
<p><a href="https://blog.csdn.net/hellokandy/article/details/54603055">C/C++ 函数调用约定（__cdecl、__stdcall、__fastcall）-CSDN博客</a></p>
<p><a href="https://blog.imkasen.com/calling-conventions/">关于调用约定 cdecl、stdcall 和 fastcall 的区别 | 拾遗记</a></p>
<p><a href="https://www.cnblogs.com/findumars/p/5143948.html">stdcall、cdecl、fastcall、thiscall 、naked call的汇编详解 - findumars - 博客园</a></p>
<h3 id="格式化串攻击">格式化串攻击</h3>
<p>由于调用约定的存在，不定参数的函数是不知道参数的个数与大小的。这在 scanf 和 printf 上会产生漏洞。</p>
<p>比如，用户在 scanf 输入字符串时，故意包含了格式化字符</p>
<div class="highlight"><pre tabindex="0" style="color:#d8dee9;background-color:#2e3440;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="color:#81a1c1">char</span> str<span style="color:#eceff4">[</span><span style="color:#b48ead">100</span><span style="color:#eceff4">];</span>
</span></span><span style="display:flex;"><span>scanf<span style="color:#eceff4">(</span><span style="color:#a3be8c">&#34;%s&#34;</span><span style="color:#eceff4">,</span> str<span style="color:#eceff4">);</span>  <span style="color:#616e87;font-style:italic">// 输入 %x\n%x\n%x\n
</span></span></span><span style="display:flex;"><span><span style="color:#616e87;font-style:italic"></span>printf<span style="color:#eceff4">(</span>str<span style="color:#eceff4">);</span>
</span></span></code></pre></div><p>printf 只知道你传入了 str 格式串。一旦扫描到了 %x，就将对应偏移量的参数给输出出来，但是调用方并没有传对应的参数，这会导致 printf 输出对应地址上的内容。</p>
<p>所以，当 printf 传入参数不足格式化串中字符的个数时，就会导致这个漏洞。</p>
<ul>
<li>泄露地址</li>
<li>栈上地址任意写入（通过输入 %n）</li>
</ul>
<hr>
<h3 id="函数重载">函数重载</h3>
<p>原则：</p>
<ul>
<li>名同，参数不同（个数、类型、顺序）</li>
<li>返回值类型不作为区别重载函数的依据</li>
</ul>
<p>特殊情况：传入类型没有重载，但是可以隐式转换到多个重载的，编译无法通过</p>
<div class="highlight"><pre tabindex="0" style="color:#d8dee9;background-color:#2e3440;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="color:#81a1c1">void</span> <span style="color:#88c0d0">foo</span><span style="color:#eceff4">(</span><span style="color:#81a1c1">char</span> a<span style="color:#eceff4">){}</span>
</span></span><span style="display:flex;"><span><span style="color:#81a1c1">void</span> <span style="color:#88c0d0">foo</span><span style="color:#eceff4">(</span><span style="color:#81a1c1">double</span> a<span style="color:#eceff4">){}</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>foo<span style="color:#eceff4">(</span><span style="color:#b48ead">1</span><span style="color:#eceff4">);</span>  <span style="color:#616e87;font-style:italic">// Call to &#39;foo&#39; is ambiguous
</span></span></span></code></pre></div><h3 id="默认参数">默认参数</h3>
<p>函数传入的参数可以设置默认参数，在不传默认参数时使用默认参数指定的值。就像 Python 一样。</p>
<p>注意点：</p>
<ul>
<li>默认参数的声明，要在函数原型中给出。如果没有函数原型，就在函数定义中给出。</li>
<li>默认参数从右到左声明，不能间断</li>
</ul>
<div class="highlight"><pre tabindex="0" style="color:#d8dee9;background-color:#2e3440;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="color:#81a1c1">void</span> <span style="color:#88c0d0">foo</span><span style="color:#eceff4">(</span><span style="color:#81a1c1">double</span><span style="color:#eceff4">,</span> <span style="color:#81a1c1">char</span><span style="color:#eceff4">,</span> <span style="color:#81a1c1">int</span><span style="color:#81a1c1">=</span><span style="color:#b48ead">2</span><span style="color:#eceff4">);</span>      <span style="color:#616e87;font-style:italic">// okay
</span></span></span><span style="display:flex;"><span><span style="color:#616e87;font-style:italic"></span><span style="color:#81a1c1">void</span> <span style="color:#88c0d0">foo</span><span style="color:#eceff4">(</span><span style="color:#81a1c1">double</span><span style="color:#81a1c1">=</span><span style="color:#b48ead">1.0</span><span style="color:#eceff4">,</span> <span style="color:#81a1c1">char</span><span style="color:#eceff4">,</span> <span style="color:#81a1c1">int</span><span style="color:#eceff4">);</span>    <span style="color:#616e87;font-style:italic">// wrong!!!
</span></span></span><span style="display:flex;"><span><span style="color:#616e87;font-style:italic"></span><span style="color:#81a1c1">void</span> <span style="color:#88c0d0">foo</span><span style="color:#eceff4">(</span><span style="color:#81a1c1">double</span><span style="color:#81a1c1">=</span><span style="color:#b48ead">1.0</span><span style="color:#eceff4">,</span> <span style="color:#81a1c1">char</span><span style="color:#eceff4">,</span> <span style="color:#81a1c1">int</span><span style="color:#81a1c1">=</span><span style="color:#b48ead">2</span><span style="color:#eceff4">);</span>  <span style="color:#616e87;font-style:italic">// wrong!!!
</span></span></span></code></pre></div><ul>
<li>默认函数和函数重载不能出现 ambiguous</li>
</ul>
<div class="highlight"><pre tabindex="0" style="color:#d8dee9;background-color:#2e3440;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="color:#81a1c1">void</span> <span style="color:#88c0d0">f</span><span style="color:#eceff4">(</span><span style="color:#81a1c1">int</span><span style="color:#eceff4">);</span>
</span></span><span style="display:flex;"><span><span style="color:#81a1c1">void</span> <span style="color:#88c0d0">f</span><span style="color:#eceff4">(</span><span style="color:#81a1c1">int</span><span style="color:#eceff4">,</span> <span style="color:#81a1c1">int</span><span style="color:#81a1c1">=</span><span style="color:#b48ead">2</span><span style="color:#eceff4">);</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>f<span style="color:#eceff4">(</span><span style="color:#b48ead">1</span><span style="color:#eceff4">);</span> <span style="color:#616e87;font-style:italic">// ambiguous!!!
</span></span></span></code></pre></div><h3 id="内联函数">内联函数</h3>
<p>inline 关键字</p>
<p>目的</p>
<ul>
<li>提高可读性</li>
<li>提高效率，因为减少了函数调用的过程</li>
</ul>
<p>限制</p>
<ul>
<li>不能递归</li>
<li>不能作为函数指针</li>
</ul>
<p>适用：频率高、简单、小段的代码</p>
<p>其他：inline 声明仅仅是请求，编译器可以拒绝</p>
<p>缺点</p>
<ul>
<li>增大目标代码</li>
<li>换页抖动</li>
<li>降低指令 cache 的命中率</li>
</ul>
<hr>
<h3 id="namespace">Namespace</h3>
<p>命名空间。限制全局标识符的作用域，方便区分同名函数。</p>
<p>声明形式：</p>
<ul>
<li>declaration</li>
</ul>
<div class="highlight"><pre tabindex="0" style="color:#d8dee9;background-color:#2e3440;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="color:#81a1c1;font-weight:bold">using</span> std<span style="color:#81a1c1">::</span>cout<span style="color:#eceff4">;</span>
</span></span><span style="display:flex;"><span><span style="color:#81a1c1;font-weight:bold">using</span> std<span style="color:#81a1c1">::</span>cin<span style="color:#eceff4">;</span>
</span></span></code></pre></div><ul>
<li>directive
不建议同一文件多次用 directive</li>
</ul>
<div class="highlight"><pre tabindex="0" style="color:#d8dee9;background-color:#2e3440;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="color:#81a1c1;font-weight:bold">using</span> <span style="color:#81a1c1;font-weight:bold">namespace</span> std<span style="color:#eceff4">;</span>
</span></span></code></pre></div><ul>
<li>默认匿名命名空间</li>
</ul>
<div class="highlight"><pre tabindex="0" style="color:#d8dee9;background-color:#2e3440;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="color:#81a1c1;font-weight:bold">using</span> <span style="color:#81a1c1">::</span>variable<span style="color:#eceff4">;</span>
</span></span></code></pre></div><ul>
<li>别名</li>
</ul>
<div class="highlight"><pre tabindex="0" style="color:#d8dee9;background-color:#2e3440;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="color:#81a1c1;font-weight:bold">namespace</span> std_alias<span style="color:#81a1c1">=</span>std<span style="color:#eceff4">;</span>
</span></span></code></pre></div><ul>
<li>全局
只要在某个文件里声明了 namespace，其他文件可以直接访问</li>
<li>开放
namespace 的内容完全公开</li>
<li>可嵌套</li>
</ul>
<div class="highlight"><pre tabindex="0" style="color:#d8dee9;background-color:#2e3440;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="color:#81a1c1;font-weight:bold">namespace</span> A<span style="color:#eceff4">{</span>
</span></span><span style="display:flex;"><span>	<span style="color:#81a1c1">int</span> a<span style="color:#eceff4">;</span>
</span></span><span style="display:flex;"><span>	<span style="color:#81a1c1;font-weight:bold">namespace</span> B<span style="color:#eceff4">{</span>
</span></span><span style="display:flex;"><span>		<span style="color:#81a1c1">int</span> b<span style="color:#eceff4">;</span>
</span></span><span style="display:flex;"><span>	<span style="color:#eceff4">}</span>
</span></span><span style="display:flex;"><span><span style="color:#eceff4">}</span>
</span></span><span style="display:flex;"><span>A<span style="color:#81a1c1">::</span>a<span style="color:#eceff4">;</span>
</span></span><span style="display:flex;"><span>A<span style="color:#81a1c1">::</span>B<span style="color:#81a1c1">::</span>b<span style="color:#eceff4">;</span>
</span></span></code></pre></div><ul>
<li>重载</li>
</ul>
<h3 id="编译预处理">编译预处理</h3>
<p>PPT 上说：与作用域、类型、接口等概念格格不入。</p>
<p>能理解，但理解得不多🫠。</p>
<h4 id="include">include</h4>
<p>作用是复制其中的文件内容到此处。</p>
<ul>
<li>包含头文件
<ul>
<li>防止重定义：用 <code>#ifdef</code> 等</li>
</ul>
</li>
<li>替换操作</li>
</ul>
<div class="highlight"><pre tabindex="0" style="color:#d8dee9;background-color:#2e3440;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span>printf<span style="color:#eceff4">(</span><span style="color:#a3be8c">&#34;#&#34;</span><span style="color:#eceff4">)</span>
</span></span></code></pre></div><ul>
<li><code>&quot;&quot;</code> 与 <code>&lt;&gt;</code>
使用 <code>&lt;&gt;</code> 时，预处理器会按如下顺序寻找文件：</li>
</ul>
<ol>
<li>到编译选项 -l 指定的目录</li>
<li>到环境变量 INCLUDE 指定的目录
使用 <code>&quot;&quot;</code> 时：</li>
<li>Current Workspace Directory</li>
<li>编译选项 -l 目录</li>
<li>环境变量 INCLUDE 目录</li>
</ol>
<h4 id="define">define</h4>
<p>替换文本宏。<code>define</code> 定义替换，<code>undef</code> 取消定义</p>
<ul>
<li>空 define
多用于防止重复定义</li>
<li>预定义宏
比如 c++ 标准版本的宏</li>
<li>功能特性测试宏
比如开优化的宏</li>
<li>仿函数宏
<ul>
<li>含参数的宏，比如之前打 oi 常用的省时间宏</li>
</ul>
</li>
</ul>
<div class="highlight"><pre tabindex="0" style="color:#d8dee9;background-color:#2e3440;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="color:#5e81ac;font-style:italic">#define f(q, w, e) for(int q = w; q &lt; e; q++)
</span></span></span><span style="display:flex;"><span><span style="color:#5e81ac;font-style:italic"></span>
</span></span><span style="display:flex;"><span>f<span style="color:#eceff4">(</span>i<span style="color:#eceff4">,</span> <span style="color:#b48ead">0</span><span style="color:#eceff4">,</span> n<span style="color:#eceff4">)</span> <span style="color:#eceff4">{...}</span>
</span></span></code></pre></div><ul>
<li>还能实现泛型</li>
</ul>
<div class="highlight"><pre tabindex="0" style="color:#d8dee9;background-color:#2e3440;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="color:#5e81ac;font-style:italic">#define add(x, y) (x + y)
</span></span></span></code></pre></div><p>加括号是必要的，为了保证加法不受外部运算符优先级的影响。</p>
<ul>
<li>对于函数体的替换
用 do while(0) 保证函数体的独立性与完整性</li>
</ul>
<div class="highlight"><pre tabindex="0" style="color:#d8dee9;background-color:#2e3440;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="color:#5e81ac;font-style:italic">#define incAndPrint(a) do{\
</span></span></span><span style="display:flex;"><span><span style="color:#5e81ac;font-style:italic">	a++;\
</span></span></span><span style="display:flex;"><span><span style="color:#5e81ac;font-style:italic">	a.print();\
</span></span></span><span style="display:flex;"><span><span style="color:#5e81ac;font-style:italic">} while(0);
</span></span></span></code></pre></div><p>如果没有 do while(0)，放在无花括号的 if 里就出问题了。</p>
<div class="highlight"><pre tabindex="0" style="color:#d8dee9;background-color:#2e3440;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="color:#616e87;font-style:italic">// with out do while(0)
</span></span></span><span style="display:flex;"><span><span style="color:#616e87;font-style:italic"></span><span style="color:#81a1c1;font-weight:bold">if</span><span style="color:#eceff4">(</span>a<span style="color:#eceff4">)</span> 
</span></span><span style="display:flex;"><span>	incAndPrint<span style="color:#eceff4">(</span>a<span style="color:#eceff4">);</span>
</span></span><span style="display:flex;"><span><span style="color:#616e87;font-style:italic">// equals to
</span></span></span><span style="display:flex;"><span><span style="color:#616e87;font-style:italic"></span><span style="color:#81a1c1;font-weight:bold">if</span><span style="color:#eceff4">(</span>a<span style="color:#eceff4">)</span>
</span></span><span style="display:flex;"><span>	a<span style="color:#81a1c1">++</span><span style="color:#eceff4">;</span>
</span></span><span style="display:flex;"><span>	a<span style="color:#eceff4">.</span>print<span style="color:#eceff4">();</span>  <span style="color:#616e87;font-style:italic">// outside of if
</span></span></span></code></pre></div><ul>
<li><code>#</code> 运算符
运算符后跟参数名，将这个参数转换成字符串。</li>
</ul>
<div class="highlight"><pre tabindex="0" style="color:#d8dee9;background-color:#2e3440;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="color:#5e81ac;font-style:italic">#define foo(x) #x
</span></span></span><span style="display:flex;"><span><span style="color:#5e81ac;font-style:italic"></span>
</span></span><span style="display:flex;"><span>foo<span style="color:#eceff4">(</span><span style="color:#b48ead">12345</span><span style="color:#eceff4">);</span>  <span style="color:#616e87;font-style:italic">// &#34;12345&#34;
</span></span></span><span style="display:flex;"><span><span style="color:#616e87;font-style:italic"></span>foo<span style="color:#eceff4">(</span>n<span style="color:#eceff4">);</span>      <span style="color:#616e87;font-style:italic">// &#34;n&#34;
</span></span></span></code></pre></div><ul>
<li><code>##</code> 运算符
运算符后跟参数名，将这个参数的名字作为一个 token 拼接到代码中。</li>
</ul>
<div class="highlight"><pre tabindex="0" style="color:#d8dee9;background-color:#2e3440;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="color:#5e81ac;font-style:italic">#define def_stack(x) typedef stack_##x{}
</span></span></span><span style="display:flex;"><span><span style="color:#5e81ac;font-style:italic"></span>
</span></span><span style="display:flex;"><span>def_stack<span style="color:#eceff4">(</span><span style="color:#81a1c1">int</span><span style="color:#eceff4">);</span> <span style="color:#616e87;font-style:italic">// typedef stack_int{}
</span></span></span></code></pre></div><h4 id="pragma">pragma</h4>
<p>结构体对齐。没研究过，先跳过。</p>
<h3 id="泛型">泛型</h3>
<p>前面说过，可以用宏实现泛型：</p>
<div class="highlight"><pre tabindex="0" style="color:#d8dee9;background-color:#2e3440;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="color:#5e81ac;font-style:italic">#define CREATE_STACK(T) \
</span></span></span><span style="display:flex;"><span><span style="color:#5e81ac;font-style:italic">typedef struct stack_##T { \
</span></span></span><span style="display:flex;"><span><span style="color:#5e81ac;font-style:italic">	T* array; \
</span></span></span><span style="display:flex;"><span><span style="color:#5e81ac;font-style:italic">	int top; \
</span></span></span><span style="display:flex;"><span><span style="color:#5e81ac;font-style:italic">} stack_##T\
</span></span></span><span style="display:flex;"><span><span style="color:#5e81ac;font-style:italic">\
</span></span></span><span style="display:flex;"><span><span style="color:#5e81ac;font-style:italic">void __init(stack_##T *stack, int capacity) {...}\
</span></span></span><span style="display:flex;"><span><span style="color:#5e81ac;font-style:italic">void __push(stack_##T *stack, T data) {...}\
</span></span></span><span style="display:flex;"><span><span style="color:#5e81ac;font-style:italic">...
</span></span></span></code></pre></div><p>但是太麻烦了</p>
<ul>
<li>代码可读性查</li>
<li>难调试</li>
<li>需要显式写出类型参数</li>
<li>手动实例化</li>
</ul>
<p>使用模板实现：</p>
<div class="highlight"><pre tabindex="0" style="color:#d8dee9;background-color:#2e3440;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="color:#81a1c1;font-weight:bold">template</span><span style="color:#81a1c1">&lt;</span><span style="color:#81a1c1;font-weight:bold">typename</span> T<span style="color:#81a1c1">&gt;</span>
</span></span><span style="display:flex;"><span><span style="color:#81a1c1;font-weight:bold">struct</span> <span style="color:#8fbcbb">Stack</span><span style="color:#eceff4">{</span>
</span></span><span style="display:flex;"><span>	T<span style="color:#81a1c1">*</span> array<span style="color:#eceff4">;</span>
</span></span><span style="display:flex;"><span>	<span style="color:#81a1c1">int</span> capacity<span style="color:#eceff4">;</span>
</span></span><span style="display:flex;"><span>	<span style="color:#81a1c1">int</span> top<span style="color:#eceff4">;</span>
</span></span><span style="display:flex;"><span><span style="color:#eceff4">};</span>
</span></span><span style="display:flex;"><span><span style="color:#eceff4">...</span>
</span></span></code></pre></div><p>好写很多。</p>
<h4 id="concept">concept</h4>
<p>约束类模板和函数模板的模板类型和非类型参数的命名要求。</p>
<p>比如，限制函数模板不能是指针：</p>
<div class="highlight"><pre tabindex="0" style="color:#d8dee9;background-color:#2e3440;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="color:#81a1c1;font-weight:bold">template</span><span style="color:#81a1c1">&lt;</span><span style="color:#81a1c1;font-weight:bold">typename</span> T<span style="color:#81a1c1">&gt;</span>
</span></span><span style="display:flex;"><span><span style="color:#81a1c1;font-weight:bold">concept</span> DataAvailable <span style="color:#81a1c1">=</span> <span style="color:#81a1c1">!</span>std<span style="color:#81a1c1">::</span>is_pointer<span style="color:#81a1c1">&lt;</span>T<span style="color:#81a1c1">&gt;::</span>value<span style="color:#eceff4">;</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#81a1c1;font-weight:bold">template</span> <span style="color:#81a1c1">&lt;</span>DataAvailable T<span style="color:#81a1c1">&gt;</span>
</span></span><span style="display:flex;"><span><span style="color:#81a1c1">void</span> function<span style="color:#eceff4">(</span>T t<span style="color:#eceff4">)</span> <span style="color:#eceff4">{...}</span>
</span></span></code></pre></div><p>其他写法：</p>
<div class="highlight"><pre tabindex="0" style="color:#d8dee9;background-color:#2e3440;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="color:#81a1c1;font-weight:bold">template</span> <span style="color:#81a1c1">&lt;</span><span style="color:#81a1c1;font-weight:bold">typename</span> T<span style="color:#81a1c1">&gt;</span>
</span></span><span style="display:flex;"><span><span style="color:#81a1c1;font-weight:bold">requires</span> DataAvilable
</span></span><span style="display:flex;"><span><span style="color:#81a1c1">void</span> function<span style="color:#eceff4">(</span>T t<span style="color:#eceff4">)</span> <span style="color:#eceff4">{...}</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#81a1c1;font-weight:bold">template</span> <span style="color:#81a1c1">&lt;</span><span style="color:#81a1c1;font-weight:bold">typename</span> T<span style="color:#81a1c1">&gt;</span>
</span></span><span style="display:flex;"><span><span style="color:#81a1c1">void</span> function<span style="color:#eceff4">(</span>T t<span style="color:#eceff4">)</span> <span style="color:#81a1c1;font-weight:bold">requires</span> DataAvilable<span style="color:#81a1c1">&lt;</span>T<span style="color:#81a1c1">&gt;</span> <span style="color:#eceff4">{...}</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#81a1c1">void</span> <span style="color:#88c0d0">function</span><span style="color:#eceff4">(</span>DataAvilable <span style="color:#81a1c1;font-weight:bold">auto</span> v<span style="color:#eceff4">)</span> <span style="color:#eceff4">{...}</span>
</span></span></code></pre></div><p>可以用 <code>&amp;&amp;</code> 组合多个约束：</p>
<div class="highlight"><pre tabindex="0" style="color:#d8dee9;background-color:#2e3440;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="color:#bf616a">```</span>cpp
</span></span><span style="display:flex;"><span><span style="color:#81a1c1;font-weight:bold">template</span> <span style="color:#81a1c1">&lt;</span><span style="color:#81a1c1;font-weight:bold">typename</span> T<span style="color:#81a1c1">&gt;</span>
</span></span><span style="display:flex;"><span><span style="color:#81a1c1;font-weight:bold">concept</span> signed_integral <span style="color:#81a1c1">=</span> integral<span style="color:#81a1c1">&lt;</span>T<span style="color:#81a1c1">&gt;</span> <span style="color:#81a1c1">&amp;&amp;</span> std<span style="color:#81a1c1">::</span>is_signed_v<span style="color:#81a1c1">&lt;</span>T<span style="color:#81a1c1">&gt;</span><span style="color:#eceff4">;</span>
</span></span></code></pre></div><h4 id="sfinae">SFINAE</h4>
<p>Substitution Failure Is Not An Error</p>
<p>模板的匹配失败不是错误。在匹配类型失败后，编译器还需要尝试其他的可能性</p>
<p><a href="https://zhuanlan.zhihu.com/p/21314708">C++模板进阶指南：SFINAE - 知乎</a></p>
<h4 id="特化">特化</h4>
<p><a href="https://zhuanlan.zhihu.com/p/346400616">C++ 模板 全特化与偏特化 - 知乎</a></p>
<h4 id="参考-5">参考</h4>
<p><a href="https://zhuanlan.zhihu.com/p/266086040">C++20: Concept详解以及个人理解 - 知乎</a></p>
<p><a href="https://zhuanlan.zhihu.com/p/21314708">C++模板进阶指南：SFINAE - 知乎</a></p>
<hr>
<h3 id="元编程-meta-programming--constexpr">元编程 Meta programming / constexpr</h3>
<p>在编译期就计算出运行时需要的东西。</p>
<hr>
<h2 id="面向对象部分">面向对象部分</h2>
<h3 id="面向对象概念">面向对象概念</h3>
<ul>
<li>
<p>program = Object1 + Object2 +…… + Objectn</p>
</li>
<li>
<p>object: data + operation</p>
</li>
<li>
<p>Message: function call</p>
</li>
<li>
<p>Class</p>
</li>
<li>
<p>OOP classify：</p>
<ul>
<li>Object-Oriented
<ul>
<li>没有 inbuilt objects，但有所有 OO 的特性。如继承、多态</li>
</ul>
</li>
<li>Object-Based
<ul>
<li>基于 inbuilt objects，但没有所有 OO 的特性</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="构造函数">构造函数</h3>
<h4 id="构造函数-1">构造函数</h4>
<p>构造函数有三种：</p>
<ul>
<li>无参构造函数</li>
<li>有参构造函数</li>
<li>拷贝构造函数</li>
</ul>
<h4 id="默认提供">默认提供</h4>
<p>编译器会提供 <strong>默认无参构造函数</strong> 和 <strong>拷贝构造函数</strong>。</p>
<div class="highlight"><pre tabindex="0" style="color:#d8dee9;background-color:#2e3440;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span>Empty<span style="color:#eceff4">();</span>
</span></span><span style="display:flex;"><span>Empty<span style="color:#eceff4">(</span><span style="color:#81a1c1;font-weight:bold">const</span> Empty<span style="color:#81a1c1">&amp;</span><span style="color:#eceff4">);</span>
</span></span></code></pre></div><p>默认的无参构造函数是空函数，什么都不干。</p>
<p>拷贝构造函数，对所有成员进行浅拷贝。</p>
<h3 id="成员初始化表">成员初始化表</h3>
<h3 id="析构函数">析构函数</h3>
<p>编译器默认提供空的析构函数。</p>
<h3 id="拷贝构造函数">拷贝构造函数</h3>
<h3 id="移动构造函数">移动构造函数</h3>
<h3 id="动态内存">动态内存</h3>
<h3 id="const-成员">const 成员</h3>
<h3 id="static-成员">static 成员</h3>
<h3 id="友元">友元</h3>
<h4 id="友元类">友元类</h4>
<h4 id="友元函数">友元函数</h4>
<p>友元函数不是类的成员函数！！！</p>
<h3 id="编译器默认提供的函数">编译器默认提供的函数</h3>
<div class="highlight"><pre tabindex="0" style="color:#d8dee9;background-color:#2e3440;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="color:#81a1c1;font-weight:bold">class</span> <span style="color:#8fbcbb">Empty</span> <span style="color:#eceff4">{</span>
</span></span><span style="display:flex;"><span>	Empty<span style="color:#eceff4">();</span>
</span></span><span style="display:flex;"><span>	Empty<span style="color:#eceff4">(</span><span style="color:#81a1c1;font-weight:bold">const</span> Empty<span style="color:#81a1c1">&amp;</span><span style="color:#eceff4">);</span>
</span></span><span style="display:flex;"><span>	Empty<span style="color:#eceff4">(</span><span style="color:#81a1c1;font-weight:bold">const</span> Empty<span style="color:#81a1c1">&amp;&amp;</span><span style="color:#eceff4">);</span>             <span style="color:#616e87;font-style:italic">// after C++ 11
</span></span></span><span style="display:flex;"><span><span style="color:#616e87;font-style:italic"></span>	<span style="color:#81a1c1">~</span>Empty<span style="color:#eceff4">();</span>
</span></span><span style="display:flex;"><span>	Empty<span style="color:#81a1c1">&amp;</span> <span style="color:#81a1c1;font-weight:bold">operator</span><span style="color:#81a1c1">=</span><span style="color:#eceff4">(</span><span style="color:#81a1c1;font-weight:bold">const</span> Empty<span style="color:#81a1c1">&amp;</span><span style="color:#eceff4">);</span>          
</span></span><span style="display:flex;"><span>	Empty<span style="color:#81a1c1">&amp;</span> <span style="color:#81a1c1;font-weight:bold">operator</span><span style="color:#81a1c1">=</span><span style="color:#eceff4">(</span><span style="color:#81a1c1;font-weight:bold">const</span> Empty<span style="color:#81a1c1">&amp;&amp;</span><span style="color:#eceff4">);</span>  <span style="color:#616e87;font-style:italic">// after C++ 11
</span></span></span><span style="display:flex;"><span><span style="color:#616e87;font-style:italic"></span>	Empty<span style="color:#81a1c1">*</span> <span style="color:#81a1c1;font-weight:bold">operator</span> <span style="color:#81a1c1">&amp;</span><span style="color:#eceff4">();</span>
</span></span><span style="display:flex;"><span>	<span style="color:#81a1c1;font-weight:bold">const</span> Empty<span style="color:#81a1c1">*</span> <span style="color:#81a1c1;font-weight:bold">operator</span> <span style="color:#81a1c1">&amp;</span><span style="color:#eceff4">()</span> <span style="color:#81a1c1;font-weight:bold">const</span><span style="color:#eceff4">;</span>
</span></span><span style="display:flex;"><span><span style="color:#eceff4">}</span>
</span></span></code></pre></div><hr>
<h3 id="继承概念">继承概念</h3>
<p>目的：基于目标代码的复用</p>
<p>思想：对事物进行分类。派生类是基类的具体化。把事物（概念）以层次结构表示出来，有利于描述和解决问题。</p>
<p>可用于：增量开发</p>
<hr>
<h3 id="多态">多态</h3>
<p>同一论域中一个元素可有多种解释</p>
<ul>
<li>提高语言灵活性</li>
<li>程序设计语言
<ul>
<li>一名多用——函数重载</li>
<li>类属——模板</li>
<li>OO 程序设计——虚函数</li>
</ul>
</li>
</ul>
<h3 id="运算符重载">运算符重载</h3>
<ul>
<li>动机：使用操作符的语义。为自定义数据类型提供类似内置类型的操作方式。</li>
<li>作用：提高可读性、可扩充性</li>
</ul>
<p>article link=&quot;/posts/C++拾遗/运算符重载/&quot; &gt;}}</p>
<h3 id="对象切片">对象切片</h3>
<p>将派生类对象赋值给基类对象时，会发生对象切片。派生类对象会变成基类，只有其基类部分的成员被保留。</p>
<div class="highlight"><pre tabindex="0" style="color:#d8dee9;background-color:#2e3440;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="color:#81a1c1;font-weight:bold">class</span> <span style="color:#8fbcbb">Base</span><span style="color:#eceff4">{</span>
</span></span><span style="display:flex;"><span><span style="color:#81a1c1;font-weight:bold">public</span><span style="color:#81a1c1">:</span>
</span></span><span style="display:flex;"><span>	<span style="color:#81a1c1;font-weight:bold">virtual</span> <span style="color:#81a1c1">void</span> foo<span style="color:#eceff4">()</span> <span style="color:#eceff4">{</span> cout<span style="color:#81a1c1">&lt;&lt;</span><span style="color:#a3be8c">&#34;Base&#34;</span><span style="color:#eceff4">;</span> <span style="color:#eceff4">}</span>
</span></span><span style="display:flex;"><span><span style="color:#eceff4">};</span>
</span></span><span style="display:flex;"><span><span style="color:#81a1c1;font-weight:bold">class</span> <span style="color:#8fbcbb">Derived</span><span style="color:#81a1c1">:</span> <span style="color:#81a1c1;font-weight:bold">public</span> Base<span style="color:#eceff4">{</span>
</span></span><span style="display:flex;"><span><span style="color:#81a1c1;font-weight:bold">public</span><span style="color:#81a1c1">:</span>  
</span></span><span style="display:flex;"><span>	<span style="color:#81a1c1">void</span> foo<span style="color:#eceff4">()</span> <span style="color:#81a1c1;font-weight:bold">override</span> <span style="color:#eceff4">{</span> cout<span style="color:#81a1c1">&lt;&lt;</span><span style="color:#a3be8c">&#34;Derived&#34;</span><span style="color:#eceff4">;</span> <span style="color:#eceff4">}</span>
</span></span><span style="display:flex;"><span><span style="color:#eceff4">}</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#81a1c1">void</span> <span style="color:#88c0d0">function</span><span style="color:#eceff4">(</span>Base base<span style="color:#eceff4">){</span>
</span></span><span style="display:flex;"><span>	base<span style="color:#eceff4">.</span>foo<span style="color:#eceff4">();</span>
</span></span><span style="display:flex;"><span><span style="color:#eceff4">}</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>Derived derived<span style="color:#eceff4">;</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>function<span style="color:#eceff4">(</span>derived<span style="color:#eceff4">);</span>  <span style="color:#616e87;font-style:italic">// Base
</span></span></span></code></pre></div><p>从结果上来说，把 derived 的数据赋给一个 base 对象的内存是不现实的，因为一般来说 sizeof Derived 比 sizeof Base 大。</p>
<p>避免发生切片的方法是使用引用或者指针。</p>
<div class="highlight"><pre tabindex="0" style="color:#d8dee9;background-color:#2e3440;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="color:#81a1c1">void</span> <span style="color:#88c0d0">function</span><span style="color:#eceff4">(</span>Base<span style="color:#81a1c1">&amp;</span> base<span style="color:#eceff4">){</span>  <span style="color:#616e87;font-style:italic">// use Reference
</span></span></span><span style="display:flex;"><span><span style="color:#616e87;font-style:italic"></span>	base<span style="color:#eceff4">.</span>foo<span style="color:#eceff4">();</span>
</span></span><span style="display:flex;"><span><span style="color:#eceff4">}</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>Derived derived<span style="color:#eceff4">;</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>function<span style="color:#eceff4">(</span>derived<span style="color:#eceff4">);</span>  <span style="color:#616e87;font-style:italic">// Derived
</span></span></span></code></pre></div><hr>
<h2 id="其他">其他</h2>
<h3 id="异常处理">异常处理</h3>
<p>article link=&quot;/posts/C++拾遗/异常处理/&quot; &gt;}}</p>
<h3 id="右值引用">右值引用</h3>
<p>article link=&quot;/posts/C++拾遗/移动语义与右值引用/&quot; &gt;}}</p>

      <ul class="flex list-none mt-20 ml-0 p-0">
  
</ul>

    </section>

    <div class="mt-20">


</div>
  </article>
</main>
  <footer class="container mt-20 py-10 border-t border-nord2">
    <a class="flex items-center flex-wrap" rel="license" href="http://creativecommons.org/licenses/by-sa/4.0/">
  <span class="pr-2">
  This work is licensed under CC BY-SA 4.0
  </span>
  
  <svg
   xmlns:dc="http://purl.org/dc/elements/1.1/"
   xmlns:cc="http://creativecommons.org/ns#"
   xmlns:rdf="http://www.w3.org/1999/02/22-rdf-syntax-ns#"
   xmlns:svg="http://www.w3.org/2000/svg"
   xmlns="http://www.w3.org/2000/svg"
   width="22px"
   height="22px"
   viewBox="0 0 268.90738 268.90381"
   version="1.1"
   id="svg8">
  <defs
     id="defs2" />
  <metadata
     id="metadata5">
    <rdf:RDF>
      <cc:Work
         rdf:about="">
        <dc:format>image/svg+xml</dc:format>
        <dc:type
           rdf:resource="http://purl.org/dc/dcmitype/StillImage" />
        <dc:title></dc:title>
      </cc:Work>
    </rdf:RDF>
  </metadata>
  <g
     id="layer1"
     transform="translate(60.21326,50.499404)"
     style="fill:#cccccc">
    <path
       style="fill:#cccccc;stroke-width:0.264583"
       d="m 65.326548,218.13993 c -7.408989,-0.46542 -15.690447,-1.74744 -23.081418,-3.57314 -31.593648,-7.80417 -59.50341,-27.196 -78.984789,-54.879 -12.666454,-17.999 -20.584652,-39.56079 -22.979215,-62.573955 -0.588773,-5.658461 -0.669383,-19.38408 -0.146066,-24.870832 3.119592,-32.707523 16.59157,-61.003391 40.247757,-84.534371 15.2616153,-15.18084 31.549653,-25.40687 50.36784,-31.622169 9.975312,-3.29466 18.955768,-5.117077 30.871725,-6.264843 5.078285,-0.48915 20.860791,-0.402168 26.193748,0.144361 17.33888,1.776911 31.24054,5.591623 45.38445,12.4538 13.95995,6.772926 25.0448,14.737531 36.65278,26.335482 7.30053,7.294229 12.4089,13.497668 17.32958,21.0444786 14.76407,22.6435694 22.22029,49.6275974 21.45807,77.6568024 -0.46871,17.235696 -3.45781,32.378206 -9.34888,47.360416 -7.49661,19.06545 -19.6155,35.81838 -36.29386,50.17195 -27.31891,23.51094 -62.27286,35.37477 -97.671722,33.15102 z m 13.890624,-24.58696 c 15.841765,-0.76807 29.708118,-4.37941 44.185418,-11.50762 19.6139,-9.65733 37.13415,-25.89003 47.43961,-43.95329 6.96873,-12.21469 10.946,-24.7316 12.93683,-40.713641 0.67104,-5.386914 0.66827,-21.171823 -0.005,-26.590624 C 180.44549,43.981851 168.68756,20.905587 149.16032,2.8538209 130.13808,-14.731106 108.6227,-24.146325 83.053631,-26.074732 c -5.193633,-0.391701 -17.404794,-0.161974 -22.092708,0.415627 -10.285637,1.267301 -17.71031,3.035425 -26.228057,6.245993 -29.9817139,11.3009174 -56.047005,39.477533 -65.941823,71.2832 -3.208777,10.314217 -4.489061,18.317852 -4.719883,29.506144 -0.208211,10.092276 0.47345,17.242929 2.4713,25.924058 5.622303,24.43025 19.636401,46.44843 39.7820077,62.5033 18.1256193,14.44505 39.8519053,22.67019 62.7062473,23.73934 2.255572,0.10551 4.279635,0.20867 4.497916,0.22922 0.218281,0.0206 2.778125,-0.0781 5.688541,-0.21918 z M 30.118038,125.15173 C 21.434959,123.79805 14.347465,120.33213 8.6867364,114.6714 1.3325742,107.31724 -2.4067819,96.984367 -2.4067819,84.016961 c 0,-8.085137 1.5872327,-15.633104 4.5106217,-21.449926 C 5.4861963,55.83698 12.3068,49.171317 19.11187,45.945369 c 5.23178,-2.48013 9.591952,-3.455662 16.334628,-3.654661 10.82623,-0.319518 18.524856,1.624447 25.857645,6.529271 3.902054,2.61004 7.896228,6.879878 10.578412,11.308498 l 0.835324,1.379219 -2.703478,1.434338 c -6.151456,3.263673 -15.039649,7.845608 -15.215139,7.843528 -0.103587,-0.0013 -0.605057,-0.80305 -1.11438,-1.781828 -1.356468,-2.606757 -4.590515,-5.79732 -7.14375,-7.047696 -2.685235,-1.315019 -4.460541,-1.74471 -7.22381,-1.748435 -7.952604,-0.01072 -13.378049,3.987215 -15.901505,11.717607 -2.048417,6.275159 -2.048491,17.061121 -1.58e-4,23.178173 2.234617,6.673367 6.42223,10.903017 11.955673,12.075697 3.975534,0.84251 9.523997,0.30321 12.537453,-1.21863 3.04397,-1.53725 5.77738,-4.36532 7.552962,-7.814528 l 0.980212,-1.904137 8.146462,4.074875 c 4.617427,2.30964 8.14646,4.22877 8.14646,4.43012 0,0.19539 -0.850363,1.65353 -1.889696,3.24032 -2.416302,3.68905 -7.205178,8.53786 -10.781707,10.91664 -4.746985,3.15726 -9.846024,5.19842 -15.334575,6.13848 -3.582267,0.61356 -11.020075,0.66931 -14.610865,0.10951 z M 109.37967,125.39 c -9.967707,-1.44914 -16.885196,-4.67736 -22.886456,-10.68056 -6.35757,-6.35962 -9.881743,-14.63917 -10.86812,-25.533104 -0.395735,-4.370652 -0.163393,-10.37091 0.568608,-14.684374 2.778691,-16.374044 13.793641,-28.073013 29.696538,-31.540669 2.35918,-0.514426 3.48834,-0.588761 9.04568,-0.595492 5.08055,-0.0062 6.87894,0.09037 8.99583,0.482862 8.18481,1.517523 14.16373,4.460118 19.41412,9.554876 2.48277,2.409169 4.711,5.220872 6.22954,7.86076 l 0.71355,1.240459 -0.61089,0.379408 c -0.75824,0.470913 -16.82726,8.913629 -16.96531,8.913629 -0.0551,0 -0.71109,-0.999651 -1.45771,-2.221447 -1.98393,-3.246591 -4.06947,-5.213273 -7.0223,-6.622071 -3.00807,-1.435158 -4.28275,-1.741035 -7.23118,-1.735222 -11.53755,0.02276 -17.516019,8.036496 -17.538609,23.509366 -0.01246,8.543372 2.160459,15.372349 6.170589,19.392629 1.76767,1.77214 3.20485,2.68168 5.69886,3.60656 2.412,0.89448 7.50413,1.12157 10.45053,0.46605 4.87189,-1.08389 8.65425,-4.09612 11.21874,-8.934495 0.44034,-0.830776 0.84629,-1.647526 0.90212,-1.815002 0.061,-0.182935 3.42501,1.356098 8.42618,3.854957 4.57858,2.2877 8.36683,4.19831 8.41833,4.24579 0.0515,0.0475 -0.58827,1.13561 -1.42171,2.41805 -6.02946,9.27767 -15.04318,15.5516 -25.79172,17.95213 -1.43309,0.32005 -3.56472,0.465 -7.67292,0.52174 -3.1287,0.0432 -6.04573,0.0266 -6.48229,-0.0368 z"
       id="path76" />
  </g>
</svg>

  <svg
   xmlns:dc="http://purl.org/dc/elements/1.1/"
   xmlns:cc="http://creativecommons.org/ns#"
   xmlns:rdf="http://www.w3.org/1999/02/22-rdf-syntax-ns#"
   xmlns:svg="http://www.w3.org/2000/svg"
   xmlns="http://www.w3.org/2000/svg"
   width="22px"
   height="22px"
   viewBox="0 0 269.00082 268.82538"
   version="1.1"
   id="svg8">
  <defs
     id="defs2" />
  <metadata
     id="metadata5">
    <rdf:RDF>
      <cc:Work
         rdf:about="">
        <dc:format>image/svg+xml</dc:format>
        <dc:type
           rdf:resource="http://purl.org/dc/dcmitype/StillImage" />
        <dc:title></dc:title>
      </cc:Work>
    </rdf:RDF>
  </metadata>
  <g
     id="layer1"
     transform="translate(277.24967,233.43254)"
     style="fill:#cccccc">
    <path
       style="fill:#cccccc;stroke-width:0.264583"
       d="m -149.88812,35.335792 c -9.54812,-0.709586 -13.43497,-1.182581 -19.57917,-2.382625 -25.64662,-5.009092 -49.13885,-17.949542 -68.98407,-37.9991525 -26.5694,-26.8430445 -39.77044,-60.0909305 -38.74258,-97.5763345 0.71419,-26.04584 7.61271,-48.56922 21.27127,-69.44973 11.3033,-17.27992 27.54285,-33.0769 44.37171,-43.16244 17.0419,-10.21323 34.85965,-15.87487 56.23888,-17.87006 4.68105,-0.43685 19.92301,-0.43746 24.87083,-9.9e-4 23.29546,2.05501 43.440152,8.87006 61.515625,20.81106 8.102536,5.35269 13.871899,10.1228 21.576764,17.83965 5.840177,5.84927 9.406276,9.91973 13.50451,15.4145 11.558431,15.49712 19.429002,33.37935 23.095227,52.47322 2.6321011,13.70807 3.2228099,30.196009 1.5972099,44.582293 -3.0618639,27.097449 -13.1312699,50.106479 -30.6840929,70.11458 -3.424504,3.9035244 -11.778649,12.04028701 -15.860452,15.4477524 -22.390327,18.6913166 -45.839771,28.5376896 -74.744791,31.3851616 -2.83124,0.278924 -17.04496,0.55163 -19.44687,0.373115 z m 21.70063,-25.212864 c 24.81471,-3.3936646 44.731952,-13.3669 63.986079,-32.039998 16.741491,-16.236285 26.870384,-35.742616 30.300437,-58.352914 1.089226,-7.179971 1.215977,-9.117986 1.219647,-18.648166 0.0037,-9.58791 -0.126844,-11.56948 -1.22877,-18.65312 -4.1636,-26.76532 -18.047795,-50.14601 -40.571778,-68.32203 -15.945913,-12.86775 -33.076085,-19.981 -54.768745,-22.74252 -5.26911,-0.67077 -21.10365,-0.67315 -26.45833,-0.004 -22.46437,2.80738 -39.58177,10.14944 -56.62083,24.28604 -3.60054,2.98721 -11.05809,10.50314 -14.40229,14.51504 -14.6489,17.57365 -22.53661,35.17132 -25.44148,56.76056 -0.69804,5.18785 -0.97446,17.14732 -0.52615,22.764069 1.50416,18.845411 7.19231,35.336288 17.4749,50.662595 7.2509,10.807551 18.27366,22.280127 28.79336,29.9683603 15.54468,11.3607051 33.48114,18.3126609 51.64853,20.0183427 1.67349,0.15712 3.45942,0.332922 3.96875,0.390675 0.50932,0.05775 4.91463,0.06798 9.78958,0.02273 7.13,-0.06618 9.64069,-0.188553 12.83709,-0.625695 z m -35.39178,-54.867643 -0.0672,-32.609894 -7.74703,-0.07015 -7.74703,-0.07015 0.076,-28.372551 c 0.0875,-32.6577 -0.14933,-29.79422 2.69722,-32.60839 2.77504,-2.74348 -0.18284,-2.53055 34.02447,-2.44937 l 29.76091,0.0706 1.40323,0.77737 c 1.74934,0.9691 3.08144,2.42332 3.98496,4.35026 l 0.69722,1.48696 0.0741,28.37255 0.0741,28.372551 -7.74703,0.07015 -7.74703,0.07015 -0.0672,32.609894 -0.0672,32.609894 h -20.76771 -20.76771 z m 15.54323,-104.048245 c -7.65008,-1.44557 -11.96298,-6.02587 -13.11908,-13.93246 -0.39276,-2.68616 -0.16692,-8.71288 0.41469,-11.0658 1.47824,-5.9803 5.56009,-10.02954 11.65337,-11.56027 2.6088,-0.65538 10.07658,-0.65538 12.68538,0 6.09328,1.53073 10.17513,5.57997 11.65337,11.56027 0.5816,2.35292 0.80745,8.37964 0.41468,11.0658 -1.1831,8.09126 -5.79498,12.79495 -13.78053,14.05486 -2.34301,0.36966 -7.66531,0.304 -9.92188,-0.1224 z"
       id="path162" />
  </g>
</svg>

  <svg
   xmlns:dc="http://purl.org/dc/elements/1.1/"
   xmlns:cc="http://creativecommons.org/ns#"
   xmlns:rdf="http://www.w3.org/1999/02/22-rdf-syntax-ns#"
   xmlns:svg="http://www.w3.org/2000/svg"
   xmlns="http://www.w3.org/2000/svg"
   width="22px"
   height="22px"
   viewBox="0 0 269.69287 269.58087"
   version="1.1"
   id="svg8">
  <defs
     id="defs2" />
  <metadata
     id="metadata5">
    <rdf:RDF>
      <cc:Work
         rdf:about="">
        <dc:format>image/svg+xml</dc:format>
        <dc:type
           rdf:resource="http://purl.org/dc/dcmitype/StillImage" />
        <dc:title></dc:title>
      </cc:Work>
    </rdf:RDF>
  </metadata>
  <g
     id="layer1"
     transform="translate(286.69733,236.4116)"
     style="fill:#cccccc">
    <path
       style="fill:#cccccc;stroke-width:0.264583"
       d="m -161.30298,33.024602 c -33.09048,-2.275337 -61.53656,-15.421337 -85.85925,-39.6787667 -23.13623,-23.0741553 -35.77499,-49.4397933 -39.06422,-81.4916623 -0.56025,-5.459325 -0.63923,-20.351693 -0.13611,-25.664583 2.18732,-23.0978 8.90609,-42.53156 21.11666,-61.07911 13.49749,-20.50234 32.53491,-37.66786 53.33663,-48.09219 12.39138,-6.20967 27.03633,-10.63756 40.949,-12.38089 7.27382,-0.91145 9.8864,-1.05528 19.05,-1.0488 9.76011,0.007 13.94787,0.28323 21.68076,1.43061 26.86175,3.98566 50.854862,15.72696 70.728144,34.61162 12.967099,12.32204 22.118798,24.5019 29.154619,38.80147 4.159358,8.45345 6.787467,15.61203 9.148174,24.91826 5.69259,22.44084 5.585037,48.926081 -0.290168,71.460859 -6.55125,25.127756 -20.299915,46.815711 -41.256953,65.08113634 C -79.294349,14.315783 -97.807112,24.118974 -118.04361,29.174835 c -6.92617,1.730428 -13.31731,2.802282 -21.43125,3.594259 -3.87689,0.378407 -17.68934,0.540094 -21.82812,0.255508 z m 22.35729,-24.9728262 c 19.96596,-2.3357495 37.32835,-9.3539755 53.44583,-21.6038688 8.120806,-6.172117 16.051624,-13.895312 22.071422,-21.493598 12.226789,-15.432854 19.150718,-32.788493 21.500646,-53.893886 0.643308,-5.777741 0.645136,-19.426513 0.0034,-25.135413 -2.266039,-20.15775 -8.649808,-36.85369 -19.929413,-52.12292 -5.168206,-6.9962 -13.213839,-15.47523 -20.338723,-21.4343 -19.497682,-16.30735 -42.912242,-24.60104 -69.453122,-24.60104 -32.33809,0 -59.59141,12.15458 -81.43834,36.32031 -9.54048,10.5531 -16.41628,21.18795 -21.47607,33.2172 -7.9215,18.83276 -10.03228,41.93248 -5.78242,63.281162 1.816,9.122476 4.37185,16.555923 8.68781,25.267707 5.27044,10.638417 11.33919,19.154904 20.21348,28.366296 19.8649,20.6194804 43.26805,31.9241944 70.80483,34.2017461 4.18379,0.346038 17.516,0.1189884 21.69071,-0.3693953 z m -22.35729,-35.9004698 c -18.34463,-2.20681 -34.20388,-12.042565 -43.04677,-26.697208 -4.02402,-6.668696 -7.24408,-16.082073 -8.30325,-24.273363 l -0.17961,-1.389063 h 16.96742 c 13.39715,0 16.96757,0.06959 16.96816,0.330729 5.3e-4,0.181901 0.13207,1.402292 0.29256,2.711979 0.40015,3.26525 1.35402,6.396038 2.81645,9.244108 1.56856,3.054765 4.97243,6.573519 8.00275,8.272845 2.50661,1.405644 6.76894,2.834868 10.18709,3.415885 3.3438,0.56838 11.44552,0.657132 13.7577,0.150715 5.83319,-1.277602 10.18482,-3.720688 14.2658,-8.009094 5.82522,-6.121317 9.47131,-14.391747 11.18792,-25.377583 0.38424,-2.459035 0.47544,-4.666845 0.47544,-11.509376 0,-8.65642 -0.15326,-10.67496 -1.21909,-16.05548 -2.68108,-13.53473 -9.23491,-22.43163 -19.02153,-25.82193 -3.71776,-1.28791 -5.43951,-1.51639 -11.24479,-1.49221 -4.6017,0.0192 -5.70565,0.10962 -8.46667,0.69374 -9.34786,1.97762 -15.22863,6.49582 -18.7228,14.38474 -0.68373,1.54367 -1.81825,5.514 -2.16813,7.5875 l -0.16742,0.99218 h 4.97194 4.97195 l -13.3595,13.36147 -13.3595,13.36146 -13.29791,-13.29532 -13.2979,-13.29531 5.22133,-0.1323 5.22133,-0.13229 0.20605,-1.32291 c 0.44498,-2.85704 1.91678,-8.63464 3.03302,-11.90625 7.3673,-21.59293 25.0818,-35.64201 48.234,-38.2536 3.96056,-0.44676 13.14464,-0.36926 17.59479,0.14847 13.45124,1.56491 24.65795,6.06575 34.13256,13.70832 2.88324,2.32572 8.33265,7.99891 10.668208,11.1063 7.586871,10.09407 11.983783,21.16366 13.949335,35.11863 0.58719,4.16892 0.813215,16.101234 0.391986,20.693895 -1.18622,12.933413 -5.001025,24.079699 -11.629445,33.979505 -6.849974,10.230707 -15.360274,17.842414 -25.643104,22.935492 -6.44958,3.194468 -12.65867,5.129411 -20.23855,6.306942 -4.00262,0.621808 -16.44134,0.904742 -20.15182,0.458382 z"
       id="path344" />
  </g>
</svg>

</a>

  </footer>
</body>

</html>
