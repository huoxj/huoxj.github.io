<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Runz&#39;s Blog</title>
    <link>https://huoxj.github.io/posts/</link>
    <description>Recent content on Runz&#39;s Blog</description>
    <generator>Hugo</generator>
    <language>cn</language>
    <lastBuildDate>Thu, 10 Apr 2025 00:00:00 +0000</lastBuildDate>
    <atom:link href="https://huoxj.github.io/posts/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>智能指针踩坑</title>
      <link>https://huoxj.github.io/posts/c&#43;&#43;%E6%8B%BE%E9%81%97/%E6%99%BA%E8%83%BD%E6%8C%87%E9%92%88%E8%B8%A9%E5%9D%91/</link>
      <pubDate>Thu, 10 Apr 2025 00:00:00 +0000</pubDate>
      <guid>https://huoxj.github.io/posts/c&#43;&#43;%E6%8B%BE%E9%81%97/%E6%99%BA%E8%83%BD%E6%8C%87%E9%92%88%E8%B8%A9%E5%9D%91/</guid>
      <description></description>
    </item>
    <item>
      <title>智能指针、裸指针和引用</title>
      <link>https://huoxj.github.io/posts/c&#43;&#43;%E6%8B%BE%E9%81%97/%E6%99%BA%E8%83%BD%E6%8C%87%E9%92%88%E8%A3%B8%E6%8C%87%E9%92%88%E5%92%8C%E5%BC%95%E7%94%A8/</link>
      <pubDate>Wed, 09 Apr 2025 00:00:00 +0000</pubDate>
      <guid>https://huoxj.github.io/posts/c&#43;&#43;%E6%8B%BE%E9%81%97/%E6%99%BA%E8%83%BD%E6%8C%87%E9%92%88%E8%A3%B8%E6%8C%87%E9%92%88%E5%92%8C%E5%BC%95%E7%94%A8/</guid>
      <description>&lt;p&gt;主要讲讲三者的使用场景。以及延伸一下 RAII 和所有权。&lt;/p&gt;</description>
    </item>
    <item>
      <title>AscendC-Tiling</title>
      <link>https://huoxj.github.io/posts/ascendc/ascendc-tiling/</link>
      <pubDate>Wed, 19 Mar 2025 00:00:00 +0000</pubDate>
      <guid>https://huoxj.github.io/posts/ascendc/ascendc-tiling/</guid>
      <description>&lt;h2 id=&#34;32-字节对齐&#34;&gt;32 字节对齐&lt;/h2&gt;&#xA;&lt;p&gt;数据的 shapeLength 需要 32 字节对齐。&lt;/p&gt;&#xA;&lt;h2 id=&#34;系统信息&#34;&gt;系统信息&lt;/h2&gt;</description>
    </item>
    <item>
      <title>AscendC-开发环境</title>
      <link>https://huoxj.github.io/posts/ascendc/ascendc-%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83/</link>
      <pubDate>Wed, 19 Mar 2025 00:00:00 +0000</pubDate>
      <guid>https://huoxj.github.io/posts/ascendc/ascendc-%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83/</guid>
      <description>&lt;p&gt;bisheng -x cce -I ${tikcpp_path} -I ${tikcpp_path}/tikcfw -I ${tikcpp_path}/tikcfw/impl -I ${tikcpp_path}/tikcfw/interface&lt;/p&gt;</description>
    </item>
    <item>
      <title>华为昇腾挑战赛南京大学专场-赛前培训</title>
      <link>https://huoxj.github.io/posts/ascendc/%E5%8D%8E%E4%B8%BA%E6%98%87%E8%85%BE%E6%8C%91%E6%88%98%E8%B5%9B%E5%8D%97%E4%BA%AC%E5%A4%A7%E5%AD%A6%E4%B8%93%E5%9C%BA-%E8%B5%9B%E5%89%8D%E5%9F%B9%E8%AE%AD/</link>
      <pubDate>Wed, 19 Mar 2025 00:00:00 +0000</pubDate>
      <guid>https://huoxj.github.io/posts/ascendc/%E5%8D%8E%E4%B8%BA%E6%98%87%E8%85%BE%E6%8C%91%E6%88%98%E8%B5%9B%E5%8D%97%E4%BA%AC%E5%A4%A7%E5%AD%A6%E4%B8%93%E5%9C%BA-%E8%B5%9B%E5%89%8D%E5%9F%B9%E8%AE%AD/</guid>
      <description>&lt;h1 id=&#34;day-1&#34;&gt;Day 1&lt;/h1&gt;&#xA;&lt;p&gt;基本照着 AscendC 文档讲。主要内容是一些入门知识。&lt;/p&gt;&#xA;&lt;h1 id=&#34;day-2&#34;&gt;Day 2&lt;/h1&gt;&#xA;&lt;h2 id=&#34;算子生成-run-包注意事项&#34;&gt;算子生成 run 包注意事项&lt;/h2&gt;&#xA;&lt;p&gt;&lt;img src=&#34;https://runzblog.oss-cn-hangzhou.aliyuncs.com/postimg/202503191909014.png&#34; alt=&#34;&#34;&gt;&lt;/p&gt;&#xA;&lt;p&gt;要改两个点：&lt;/p&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;芯片改成 &lt;code&gt;ascend910b&lt;/code&gt;&lt;/li&gt;&#xA;&lt;li&gt;改 Cann 包路径&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;h2 id=&#34;msopgen-在哪&#34;&gt;msopgen 在哪&lt;/h2&gt;&#xA;&lt;p&gt;&lt;img src=&#34;https://runzblog.oss-cn-hangzhou.aliyuncs.com/postimg/202503191911437.png&#34; alt=&#34;&#34;&gt;&lt;/p&gt;&#xA;&lt;p&gt;在 toolkit 的 Python package 里面。&lt;/p&gt;&#xA;&lt;h2 id=&#34;考题&#34;&gt;考题&lt;/h2&gt;&#xA;&lt;p&gt;ScatterReduce&lt;/p&gt;&#xA;&lt;h2 id=&#34;gather&#34;&gt;Gather&lt;/h2&gt;&#xA;&lt;p&gt;&lt;code&gt;Gather Api&lt;/code&gt; 取 from_idx 的数据，放到 to_idx 位置。&lt;/p&gt;&#xA;&lt;p&gt;&lt;img src=&#34;https://runzblog.oss-cn-hangzhou.aliyuncs.com/postimg/202503192027923.png&#34; alt=&#34;&#34;&gt;&lt;/p&gt;&#xA;&lt;h2 id=&#34;tiling-key&#34;&gt;Tiling key&lt;/h2&gt;&#xA;&lt;p&gt;对于不同输入 shape，可能有不同的 tiling 逻辑。如果在 device 端进行判断，会造成比较大的开销（因为 GPU 不适合干这个事）。所以在 CPU 里提前判断并设置好 tiling key，device 侧只需根据 tiling key 判断就可以了。&lt;/p&gt;&#xA;&lt;p&gt;图没截到 QAQ&lt;/p&gt;&#xA;&lt;h2 id=&#34;workspace&#34;&gt;Workspace&lt;/h2&gt;&#xA;&lt;p&gt;是 gm 上的一块内存。分为系统 workspace 和用户 workspace。&lt;/p&gt;&#xA;&lt;p&gt;在计算过程中需要的临时 gm 存储空间就从用户 workspace 来。&lt;/p&gt;&#xA;&lt;p&gt;设置 workspace 为 0 时，系统会自动帮你申请系统 workspace，用户 workspace 为 0；否则，你需要同时手动设置系统和用户 workspace。&lt;/p&gt;</description>
    </item>
    <item>
      <title>Clangd 无法识别 CMake 生成的 CUDA --options-file 标识</title>
      <link>https://huoxj.github.io/posts/cuda/clangd-%E6%97%A0%E6%B3%95%E8%AF%86%E5%88%AB-cmake-%E7%94%9F%E6%88%90%E7%9A%84-cuda---options-file-%E6%A0%87%E8%AF%86/</link>
      <pubDate>Thu, 13 Mar 2025 00:00:00 +0000</pubDate>
      <guid>https://huoxj.github.io/posts/cuda/clangd-%E6%97%A0%E6%B3%95%E8%AF%86%E5%88%AB-cmake-%E7%94%9F%E6%88%90%E7%9A%84-cuda---options-file-%E6%A0%87%E8%AF%86/</guid>
      <description>&lt;h1 id=&#34;tldr&#34;&gt;tl.dr&lt;/h1&gt;&#xA;&lt;p&gt;CMake 生成的 compile_commands.json 中，对 .cu 文件会生成 &amp;ndash;options-file 的标识，而 clangd 无法识别，从而导致 clangd 报错无法找到头文件。&lt;/p&gt;&#xA;&lt;p&gt;解决：在 CMake 中关闭为 cuda 生成 &amp;ndash;options-file 的选项&lt;/p&gt;&#xA;&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#d8dee9;background-color:#2e3440;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-cmake&#34; data-lang=&#34;cmake&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#616e87;font-style:italic&#34;&gt;# This would work&#xA;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#616e87;font-style:italic&#34;&gt;&lt;/span&gt;&lt;span style=&#34;color:#81a1c1&#34;&gt;set&lt;/span&gt;&lt;span style=&#34;color:#eceff4&#34;&gt;(&lt;/span&gt;&lt;span style=&#34;color:#a3be8c&#34;&gt;CMAKE_CUDA_USE_RESPONSE_FILE_FOR_INCLUDES&lt;/span&gt; &lt;span style=&#34;color:#a3be8c&#34;&gt;0&lt;/span&gt;&lt;span style=&#34;color:#eceff4&#34;&gt;)&lt;/span&gt;&lt;span style=&#34;color:#bf616a&#34;&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#bf616a&#34;&gt;&lt;/span&gt;&lt;span style=&#34;color:#616e87;font-style:italic&#34;&gt;# You can add below if you like&#xA;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#616e87;font-style:italic&#34;&gt;&lt;/span&gt;&lt;span style=&#34;color:#81a1c1&#34;&gt;set&lt;/span&gt;&lt;span style=&#34;color:#eceff4&#34;&gt;(&lt;/span&gt;&lt;span style=&#34;color:#a3be8c&#34;&gt;CMAKE_CUDA_USE_RESPONSE_FILE_FOR_LIBRARIES&lt;/span&gt; &lt;span style=&#34;color:#a3be8c&#34;&gt;0&lt;/span&gt;&lt;span style=&#34;color:#eceff4&#34;&gt;)&lt;/span&gt;&lt;span style=&#34;color:#bf616a&#34;&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#bf616a&#34;&gt;&lt;/span&gt;&lt;span style=&#34;color:#81a1c1&#34;&gt;set&lt;/span&gt;&lt;span style=&#34;color:#eceff4&#34;&gt;(&lt;/span&gt;&lt;span style=&#34;color:#a3be8c&#34;&gt;CMAKE_CUDA_USE_RESPONSE_FILE_FOR_OBJECTS&lt;/span&gt; &lt;span style=&#34;color:#a3be8c&#34;&gt;0&lt;/span&gt;&lt;span style=&#34;color:#eceff4&#34;&gt;)&lt;/span&gt;&lt;span style=&#34;color:#bf616a&#34;&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;或者用其他能正确生成 compile_commands.json 的工具。比如 bear 或者 xmake。&lt;/p&gt;&#xA;&lt;h1 id=&#34;原因&#34;&gt;原因&lt;/h1&gt;&#xA;&lt;p&gt;使用 CMake(3.25.2) 构建工程，某些 .cu 文件里需要 include header目录下的头文件。&lt;/p&gt;&#xA;&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#d8dee9;background-color:#2e3440;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-cmake&#34; data-lang=&#34;cmake&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#81a1c1&#34;&gt;include_directories&lt;/span&gt;&lt;span style=&#34;color:#eceff4&#34;&gt;(&lt;/span&gt;&lt;span style=&#34;color:#a3be8c&#34;&gt;header&lt;/span&gt;&lt;span style=&#34;color:#eceff4&#34;&gt;)&lt;/span&gt;&lt;span style=&#34;color:#bf616a&#34;&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;生成的 nvcc 编译命令&lt;strong&gt;理应&lt;/strong&gt;长这样：&lt;/p&gt;&#xA;&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#d8dee9;background-color:#2e3440;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-bash&#34; data-lang=&#34;bash&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;nvcc *.cu -I/.../header ...&#xA;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;但是，CMake 实际生成了：&lt;/p&gt;&#xA;&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#d8dee9;background-color:#2e3440;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-bash&#34; data-lang=&#34;bash&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;nvcc *.cu --options-file .../includes_CUDA.rsp&#xA;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;找到 &lt;code&gt;includes_CUDA.rsp&lt;/code&gt;，里面存放了 -I 的 flags。&lt;/p&gt;&#xA;&lt;pre tabindex=&#34;0&#34;&gt;&lt;code class=&#34;language-includes_CUDA.rsp&#34; data-lang=&#34;includes_CUDA.rsp&#34;&gt;-I/.../header&#xA;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;而这个 &lt;code&gt;--options-file&lt;/code&gt; 选项是 nvcc 独有的，并且 clangd(18.1.3) 似乎无法识别。导致 .cu 在 IDE 中无法识别头文件。&lt;/p&gt;</description>
    </item>
    <item>
      <title>宏</title>
      <link>https://huoxj.github.io/posts/c&#43;&#43;%E6%8B%BE%E9%81%97/%E5%AE%8F/</link>
      <pubDate>Tue, 11 Mar 2025 00:00:00 +0000</pubDate>
      <guid>https://huoxj.github.io/posts/c&#43;&#43;%E6%8B%BE%E9%81%97/%E5%AE%8F/</guid>
      <description>&lt;h1 id=&#34;头文件多次-include&#34;&gt;头文件多次 include&lt;/h1&gt;&#xA;&lt;p&gt;&lt;code&gt;#include&lt;/code&gt; 的作用是将对应文件直接拷贝过来。这不可避免地会导致某个头文件被拷贝了多次，从而造成重复定义的问题。&lt;/p&gt;&#xA;&lt;p&gt;目前已知两种解决方法：条件编译 和 &lt;code&gt;pragma once&lt;/code&gt;&lt;/p&gt;&#xA;&lt;h2 id=&#34;方法简述&#34;&gt;方法简述&lt;/h2&gt;&#xA;&lt;h3 id=&#34;条件编译&#34;&gt;条件编译&lt;/h3&gt;&#xA;&lt;p&gt;条件编译可以让宏拥有判断的特性。&lt;/p&gt;&#xA;&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#d8dee9;background-color:#2e3440;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-cpp&#34; data-lang=&#34;cpp&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#5e81ac;font-style:italic&#34;&gt;#define CONDITION&#xA;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#5e81ac;font-style:italic&#34;&gt;&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#5e81ac;font-style:italic&#34;&gt;#ifdef CONDITION&#xA;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#5e81ac;font-style:italic&#34;&gt;&lt;/span&gt;&lt;span style=&#34;color:#eceff4&#34;&gt;...&lt;/span&gt;    &lt;span style=&#34;color:#616e87;font-style:italic&#34;&gt;// section a&#xA;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#616e87;font-style:italic&#34;&gt;&lt;/span&gt;&lt;span style=&#34;color:#5e81ac;font-style:italic&#34;&gt;#else&#xA;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#5e81ac;font-style:italic&#34;&gt;&lt;/span&gt;&lt;span style=&#34;color:#eceff4&#34;&gt;...&lt;/span&gt;    &lt;span style=&#34;color:#616e87;font-style:italic&#34;&gt;// section b&#xA;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#616e87;font-style:italic&#34;&gt;&lt;/span&gt;&lt;span style=&#34;color:#5e81ac;font-style:italic&#34;&gt;#endif&#xA;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;定义了 &lt;code&gt;CONDITION&lt;/code&gt; 宏，编译器会只编译 section a 的内容，丢弃 section b。&lt;/p&gt;&#xA;&lt;p&gt;除此之外，还有 &lt;code&gt;ifndef&lt;/code&gt; &lt;code&gt;elif&lt;/code&gt; 等宏。&lt;/p&gt;&#xA;&lt;blockquote&gt;&#xA;&lt;p&gt;ifndef 即 if not define&lt;/p&gt;&#xA;&lt;/blockquote&gt;&#xA;&lt;p&gt;在可能被多次 include 的头文件开头定义一个宏，并将后面所有的内容包裹在 ifdef 中，可以保证 ifdef 宏包裹的内容不被多次 include。&lt;/p&gt;&#xA;&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#d8dee9;background-color:#2e3440;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-cpp&#34; data-lang=&#34;cpp&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#5e81ac;font-style:italic&#34;&gt;#ifndef __UTILS_H__&#xA;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#5e81ac;font-style:italic&#34;&gt;#define __UTILS_H__&#xA;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#5e81ac;font-style:italic&#34;&gt;&lt;/span&gt;&lt;span style=&#34;color:#eceff4&#34;&gt;...&lt;/span&gt;    &lt;span style=&#34;color:#616e87;font-style:italic&#34;&gt;// contents of the header&#xA;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#616e87;font-style:italic&#34;&gt;&lt;/span&gt;&lt;span style=&#34;color:#5e81ac;font-style:italic&#34;&gt;#endif&#xA;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;blockquote&gt;&#xA;&lt;p&gt;CLion IDE 在创建头文件时会自动帮你生成这段条件编译&lt;/p&gt;&#xA;&lt;/blockquote&gt;&#xA;&lt;h3 id=&#34;pragma-once&#34;&gt;pragma once&lt;/h3&gt;&#xA;&lt;p&gt;使用很简单，在头文件开头加上：&lt;/p&gt;&#xA;&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#d8dee9;background-color:#2e3440;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-cpp&#34; data-lang=&#34;cpp&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#5e81ac;font-style:italic&#34;&gt;#pragma once&#xA;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;结束。&lt;/p&gt;&#xA;&lt;h2 id=&#34;方法对比&#34;&gt;方法对比&lt;/h2&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;pragma once 使用更简单&lt;/li&gt;&#xA;&lt;li&gt;pragma 某些编译器不支持，用小作坊手搓的编译器可能会寄寄&#xA;&lt;ul&gt;&#xA;&lt;li&gt;gcc, clang 是支持的&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;/ul&gt;</description>
    </item>
    <item>
      <title>CUDA warp divergence 的小思考</title>
      <link>https://huoxj.github.io/posts/cuda/cuda-warp-divergence-%E7%9A%84%E5%B0%8F%E6%80%9D%E8%80%83/</link>
      <pubDate>Sat, 08 Mar 2025 00:00:00 +0000</pubDate>
      <guid>https://huoxj.github.io/posts/cuda/cuda-warp-divergence-%E7%9A%84%E5%B0%8F%E6%80%9D%E8%80%83/</guid>
      <description>&lt;p&gt;CUDA 的执行是以 warp 为单位的，一个 warp 内的线程的运行像是一排阵列士兵一样齐刷刷地踢正步。warp 扮演的角色就是给这一排士兵下指令的军官。&lt;/p&gt;&#xA;&lt;p&gt;但是总有例外。比如遇到了线程 id 相关的 if-else，一部分线程走 a 分支，另一部分线程走 b 分支，这就会造成 warp divergence。军官在单位时间内只能下一条指令。为了让士兵完成各自的命令，一个解决方法是：&lt;/p&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;军官下令只让分支 a 的士兵听指令，分支 b 的士兵原地待命。（active mask）&lt;/li&gt;&#xA;&lt;li&gt;军官正常下分支 a 中的命令&lt;/li&gt;&#xA;&lt;li&gt;分支 a 命令结束。下令 a 的士兵待命，b 的士兵听令。&lt;/li&gt;&#xA;&lt;li&gt;军官正常下分支 b 中的命令&lt;/li&gt;&#xA;&lt;li&gt;两分支汇合，过程结束&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;p&gt;这个方法的弊端是将两个分支的执行串行化了，非 active 的线程没有完全利用，浪费了性能。&lt;/p&gt;&#xA;&lt;p&gt;CUDA 早期（pre volta）的 warp divergence 大致是以这样的思路解决的。不过即使是现在的 CUDA，对于这种 divergence 还是会造成一定程度的性能浪费。&lt;/p&gt;</description>
    </item>
    <item>
      <title>CUDA 原子操作</title>
      <link>https://huoxj.github.io/posts/cuda/cuda-%E5%8E%9F%E5%AD%90%E6%93%8D%E4%BD%9C/</link>
      <pubDate>Wed, 05 Mar 2025 00:00:00 +0000</pubDate>
      <guid>https://huoxj.github.io/posts/cuda/cuda-%E5%8E%9F%E5%AD%90%E6%93%8D%E4%BD%9C/</guid>
      <description>&lt;p&gt;CUDA 原子操作和 C++ 的原子操作概念基本是一样的。&lt;/p&gt;&#xA;&lt;p&gt;给出定义：An atomic function performs a read-modify-write atomic operation on one 32-bit, 64-bit, or 128-bit word residing in global or shared memory.&lt;/p&gt;&#xA;&lt;blockquote&gt;&#xA;&lt;p&gt;128 bit 的支持似乎是新版本加的，网上部分资料还仅限于 32 和 64 bit&lt;/p&gt;&#xA;&lt;/blockquote&gt;&#xA;&lt;p&gt;本文记录一些特殊点和坑点。&lt;/p&gt;&#xA;&lt;h2 id=&#34;使用&#34;&gt;使用&lt;/h2&gt;&#xA;&lt;p&gt;CUDA 原子操作被包装成了函数。&lt;/p&gt;&#xA;&lt;p&gt;比如原子加法 &lt;code&gt;atomicAdd(int* addr, int val)&lt;/code&gt;。向 addr 地址加上 val。&lt;/p&gt;&#xA;&lt;p&gt;对于操作的对象，如定义所言，只支持 32, 64, 128 bit 的类型。&lt;/p&gt;&#xA;&lt;h2 id=&#34;返回旧值&#34;&gt;返回旧值&lt;/h2&gt;&#xA;&lt;p&gt;原子函数的返回值是参数地址被修改前的值。&lt;/p&gt;&#xA;&lt;p&gt;利用这一点，可以实现 filter。&lt;/p&gt;&#xA;&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#d8dee9;background-color:#2e3440;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-cpp&#34; data-lang=&#34;cpp&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;__global__ &lt;span style=&#34;color:#81a1c1&#34;&gt;void&lt;/span&gt; &lt;span style=&#34;color:#88c0d0&#34;&gt;myCudaFilter&lt;/span&gt;&lt;span style=&#34;color:#eceff4&#34;&gt;(&lt;/span&gt;&lt;span style=&#34;color:#81a1c1&#34;&gt;int&lt;/span&gt; &lt;span style=&#34;color:#81a1c1&#34;&gt;*&lt;/span&gt;dest&lt;span style=&#34;color:#eceff4&#34;&gt;,&lt;/span&gt; &lt;span style=&#34;color:#81a1c1;font-weight:bold&#34;&gt;const&lt;/span&gt; &lt;span style=&#34;color:#81a1c1&#34;&gt;int&lt;/span&gt; &lt;span style=&#34;color:#81a1c1&#34;&gt;*&lt;/span&gt;arr&lt;span style=&#34;color:#eceff4&#34;&gt;,&lt;/span&gt; &lt;span style=&#34;color:#81a1c1&#34;&gt;int&lt;/span&gt; len&lt;span style=&#34;color:#eceff4&#34;&gt;){&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&#x9;&lt;span style=&#34;color:#81a1c1&#34;&gt;int&lt;/span&gt; idx &lt;span style=&#34;color:#81a1c1&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#eceff4&#34;&gt;...;&lt;/span&gt; &lt;span style=&#34;color:#616e87;font-style:italic&#34;&gt;// linear index of current thread&#xA;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#616e87;font-style:italic&#34;&gt;&lt;/span&gt;&#x9;__shared__ &lt;span style=&#34;color:#81a1c1&#34;&gt;int&lt;/span&gt; sum &lt;span style=&#34;color:#81a1c1&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#b48ead&#34;&gt;0&lt;/span&gt;&lt;span style=&#34;color:#eceff4&#34;&gt;;&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&#x9;&lt;span style=&#34;color:#616e87;font-style:italic&#34;&gt;// filter element that greater than 114&#xA;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#616e87;font-style:italic&#34;&gt;&lt;/span&gt;&#x9;&lt;span style=&#34;color:#81a1c1;font-weight:bold&#34;&gt;if&lt;/span&gt; &lt;span style=&#34;color:#eceff4&#34;&gt;(&lt;/span&gt;arr&lt;span style=&#34;color:#eceff4&#34;&gt;[&lt;/span&gt;idx&lt;span style=&#34;color:#eceff4&#34;&gt;]&lt;/span&gt; &lt;span style=&#34;color:#81a1c1&#34;&gt;&amp;gt;&lt;/span&gt; &lt;span style=&#34;color:#b48ead&#34;&gt;114&lt;/span&gt;&lt;span style=&#34;color:#eceff4&#34;&gt;)&lt;/span&gt; &lt;span style=&#34;color:#eceff4&#34;&gt;{&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&#x9;&#x9;&lt;span style=&#34;color:#616e87;font-style:italic&#34;&gt;// loc is the value before increment&#xA;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#616e87;font-style:italic&#34;&gt;&lt;/span&gt;&#x9;&#x9;&lt;span style=&#34;color:#81a1c1&#34;&gt;int&lt;/span&gt; loc &lt;span style=&#34;color:#81a1c1&#34;&gt;=&lt;/span&gt; atomicAdd&lt;span style=&#34;color:#eceff4&#34;&gt;(&lt;/span&gt;&lt;span style=&#34;color:#81a1c1&#34;&gt;&amp;amp;&lt;/span&gt;sum&lt;span style=&#34;color:#eceff4&#34;&gt;,&lt;/span&gt; &lt;span style=&#34;color:#b48ead&#34;&gt;1&lt;/span&gt;&lt;span style=&#34;color:#eceff4&#34;&gt;);&lt;/span&gt;  &#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&#x9;&#x9;dest&lt;span style=&#34;color:#eceff4&#34;&gt;[&lt;/span&gt;loc&lt;span style=&#34;color:#eceff4&#34;&gt;]&lt;/span&gt; &lt;span style=&#34;color:#81a1c1&#34;&gt;=&lt;/span&gt; arr&lt;span style=&#34;color:#eceff4&#34;&gt;[&lt;/span&gt;idx&lt;span style=&#34;color:#eceff4&#34;&gt;];&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&#x9;&lt;span style=&#34;color:#eceff4&#34;&gt;}&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#eceff4&#34;&gt;}&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;h2 id=&#34;实现任意原子操作&#34;&gt;实现任意原子操作&lt;/h2&gt;&#xA;&lt;h3 id=&#34;atomiccas&#34;&gt;atomicCAS&lt;/h3&gt;&#xA;&lt;p&gt;先介绍 atomicCAS。全称：atomic Compare And Swap&lt;/p&gt;</description>
    </item>
    <item>
      <title>Thrust 库的使用与踩坑</title>
      <link>https://huoxj.github.io/posts/cuda/thrust-%E5%BA%93%E7%9A%84%E4%BD%BF%E7%94%A8%E4%B8%8E%E8%B8%A9%E5%9D%91/</link>
      <pubDate>Wed, 05 Mar 2025 00:00:00 +0000</pubDate>
      <guid>https://huoxj.github.io/posts/cuda/thrust-%E5%BA%93%E7%9A%84%E4%BD%BF%E7%94%A8%E4%B8%8E%E8%B8%A9%E5%9D%91/</guid>
      <description>&lt;p&gt;待研究。&lt;/p&gt;</description>
    </item>
    <item>
      <title>Nvim —— 我的第N代移动开发方案</title>
      <link>https://huoxj.github.io/posts/%E6%9C%89%E6%84%8F%E6%80%9D%E7%9A%84%E6%8A%98%E8%85%BE/nvim--%E6%88%91%E7%9A%84%E7%AC%ACn%E4%BB%A3%E7%A7%BB%E5%8A%A8%E5%BC%80%E5%8F%91%E6%96%B9%E6%A1%88/</link>
      <pubDate>Fri, 28 Feb 2025 00:00:00 +0000</pubDate>
      <guid>https://huoxj.github.io/posts/%E6%9C%89%E6%84%8F%E6%80%9D%E7%9A%84%E6%8A%98%E8%85%BE/nvim--%E6%88%91%E7%9A%84%E7%AC%ACn%E4%BB%A3%E7%A7%BB%E5%8A%A8%E5%BC%80%E5%8F%91%E6%96%B9%E6%A1%88/</guid>
      <description>&lt;ul&gt;&#xA;&lt;li&gt;iPad 原生软件——Code&lt;/li&gt;&#xA;&lt;li&gt;UTM 虚拟机&lt;/li&gt;&#xA;&lt;li&gt;串流&lt;/li&gt;&#xA;&lt;li&gt;ish&lt;/li&gt;&#xA;&lt;li&gt;ssh&lt;/li&gt;&#xA;&lt;/ul&gt;</description>
    </item>
    <item>
      <title>优雅的STL</title>
      <link>https://huoxj.github.io/posts/%E7%AE%97%E6%B3%95%E4%B8%8E%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E4%BC%98%E9%9B%85%E7%9A%84stl/</link>
      <pubDate>Fri, 28 Feb 2025 00:00:00 +0000</pubDate>
      <guid>https://huoxj.github.io/posts/%E7%AE%97%E6%B3%95%E4%B8%8E%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E4%BC%98%E9%9B%85%E7%9A%84stl/</guid>
      <description>&lt;p&gt;同属&lt;em&gt;优雅的&lt;/em&gt;系列。致力于整理优雅、清晰的&lt;strong&gt;处理手法&lt;/strong&gt;，以及一些&lt;strong&gt;注意事项&lt;/strong&gt;。&lt;/p&gt;&#xA;&lt;p&gt;本篇记录了使用 C++ STL 刷题时的一些心得。&lt;/p&gt;&#xA;&lt;h2 id=&#34;容器导致的迭代器--指针失效&#34;&gt;容器导致的迭代器 / 指针失效&lt;/h2&gt;&#xA;&lt;p&gt;蓦然回首，那迭代器 / 指针已经&lt;strong&gt;挂了&lt;/strong&gt;！等待你的是 &lt;code&gt;heap-use-after-free&lt;/code&gt;。&lt;/p&gt;&#xA;&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#d8dee9;background-color:#2e3440;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-cpp&#34; data-lang=&#34;cpp&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#81a1c1;font-weight:bold&#34;&gt;auto&lt;/span&gt; arr &lt;span style=&#34;color:#81a1c1&#34;&gt;=&lt;/span&gt; vector&lt;span style=&#34;color:#81a1c1&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span style=&#34;color:#81a1c1&#34;&gt;int&lt;/span&gt;&lt;span style=&#34;color:#81a1c1&#34;&gt;&amp;gt;&lt;/span&gt;&lt;span style=&#34;color:#eceff4&#34;&gt;(&lt;/span&gt;&lt;span style=&#34;color:#b48ead&#34;&gt;1&lt;/span&gt;&lt;span style=&#34;color:#eceff4&#34;&gt;,&lt;/span&gt; &lt;span style=&#34;color:#b48ead&#34;&gt;1&lt;/span&gt;&lt;span style=&#34;color:#eceff4&#34;&gt;);&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#81a1c1;font-weight:bold&#34;&gt;auto&lt;/span&gt; it &lt;span style=&#34;color:#81a1c1&#34;&gt;=&lt;/span&gt; arr&lt;span style=&#34;color:#eceff4&#34;&gt;.&lt;/span&gt;begin&lt;span style=&#34;color:#eceff4&#34;&gt;()&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;arr&lt;span style=&#34;color:#eceff4&#34;&gt;.&lt;/span&gt;push_back&lt;span style=&#34;color:#eceff4&#34;&gt;(&lt;/span&gt;&lt;span style=&#34;color:#b48ead&#34;&gt;1&lt;/span&gt;&lt;span style=&#34;color:#eceff4&#34;&gt;);&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#81a1c1&#34;&gt;*&lt;/span&gt;it&lt;span style=&#34;color:#eceff4&#34;&gt;;&lt;/span&gt;  &lt;span style=&#34;color:#616e87;font-style:italic&#34;&gt;// BOOM! Heap use after free&#xA;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;容器扩容时偷偷搬家了，房东就不要拿原来的水电气单子去收钱了，会变得不幸（&lt;/p&gt;&#xA;&lt;p&gt;用索引来记录是一个不太完美的解决方案。&lt;/p&gt;&#xA;&lt;p&gt;或者，提前预判搬家后迭代器该指向什么位置。仍然不完美，只能处理部分情况。&lt;/p&gt;&#xA;&lt;p&gt;完美的解决方案？404 not found。&lt;/p&gt;</description>
    </item>
    <item>
      <title>优雅的链表</title>
      <link>https://huoxj.github.io/posts/%E7%AE%97%E6%B3%95%E4%B8%8E%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E4%BC%98%E9%9B%85%E7%9A%84%E9%93%BE%E8%A1%A8/</link>
      <pubDate>Fri, 28 Feb 2025 00:00:00 +0000</pubDate>
      <guid>https://huoxj.github.io/posts/%E7%AE%97%E6%B3%95%E4%B8%8E%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E4%BC%98%E9%9B%85%E7%9A%84%E9%93%BE%E8%A1%A8/</guid>
      <description>&lt;p&gt;当然不会讲链表的概念等等。主要收集一些刷力扣过程中，链表题的一些优雅的处理手法。优雅简洁易懂的代码是信仰和追求。&lt;/p&gt;&#xA;&lt;h2 id=&#34;dummy-node&#34;&gt;Dummy node&lt;/h2&gt;&#xA;&lt;p&gt;在短小精悍的题中，加一堆特判无疑是往刷好的白墙上&lt;strong&gt;扔狗屎&lt;/strong&gt;。在设计链表的算法时，往往是考虑链表的&lt;strong&gt;一般（中间）节点&lt;/strong&gt;，所以算法常常需要给头尾加上特判，这太不好了。&lt;/p&gt;&#xA;&lt;p&gt;于是一个朴素的 trick 诞生了，在头或者尾加上一个 &lt;strong&gt;dummy node&lt;/strong&gt;，这样我们关心的所有节点都是一般的中间结点了，实现了真正的公平和大一统。&lt;/p&gt;&#xA;&lt;p&gt;此法&lt;strong&gt;非常有效&lt;/strong&gt;，建议多加利用。&lt;/p&gt;</description>
    </item>
    <item>
      <title>Asst3</title>
      <link>https://huoxj.github.io/posts/cs149-%E5%B9%B6%E8%A1%8C%E8%AE%A1%E7%AE%97/asst3/</link>
      <pubDate>Mon, 17 Feb 2025 00:00:00 +0000</pubDate>
      <guid>https://huoxj.github.io/posts/cs149-%E5%B9%B6%E8%A1%8C%E8%AE%A1%E7%AE%97/asst3/</guid>
      <description>&lt;h2 id=&#34;part-1-saxpy&#34;&gt;Part 1: SAXPY&lt;/h2&gt;&#xA;&lt;p&gt;使用 CUDA 实现 SAXPY。&lt;/p&gt;&#xA;&lt;p&gt;实现很简单，跟着实验文档和 CUDA 文档做下来就行。&lt;/p&gt;&#xA;&lt;p&gt;Question 2：为什么观测到的带宽约为 5.3 GB/s，远不及 PCIe 3.0 的理论带宽上限？&lt;/p&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;主板芯片组性能限制&lt;/li&gt;&#xA;&lt;li&gt;&lt;strong&gt;Pinned memory&lt;/strong&gt; 机制&#xA;&lt;ul&gt;&#xA;&lt;li&gt;GPU 通过 DMA 访存&lt;/li&gt;&#xA;&lt;li&gt;Pinned memory 是物理内存上一块固定的区域，不会被换出，能通过 DMA 加速通信&lt;/li&gt;&#xA;&lt;li&gt;CPU 内存(host data)上的数据是虚拟内存上的可分页数据，可能存在于物理内存上或者硬盘上（页被换出物理内存了）&lt;/li&gt;&#xA;&lt;li&gt;GPU 直接通过物理地址访存，host data 需要先拷贝到临时的 pinned memory 区上，再拷贝到 GPU (device memory)&lt;/li&gt;&#xA;&lt;li&gt;用 &lt;code&gt;cudaHostAlloc&lt;/code&gt; 或 &lt;code&gt;cudaMallocHost&lt;/code&gt; 分配 pinned memory&lt;/li&gt;&#xA;&lt;li&gt;&lt;a href=&#34;https://www.cnblogs.com/whiteBear/p/17842246.html&#34;&gt;CUDA:页锁定内存(pinned memory)和按页分配内存(pageable memory ) - 牛犁heart - 博客园&lt;/a&gt;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;h2 id=&#34;part-2&#34;&gt;Part 2&lt;/h2&gt;&#xA;&lt;h3 id=&#34;parallel-prefix-sum&#34;&gt;Parallel Prefix-Sum&lt;/h3&gt;&#xA;&lt;p&gt;使用 CUDA 实现一个并行的前缀和算法。&lt;/p&gt;&#xA;&lt;p&gt;&lt;a href=&#34;https://zhuanlan.zhihu.com/p/91089093&#34;&gt;并行算法科普向 系列之二：前缀和，fork-join 和矩阵乘法 - 知乎&lt;/a&gt;&lt;/p&gt;</description>
    </item>
    <item>
      <title>暗喻幻想</title>
      <link>https://huoxj.github.io/posts/van-%E6%B8%B8%E6%88%8F/%E6%9A%97%E5%96%BB%E5%B9%BB%E6%83%B3/</link>
      <pubDate>Fri, 07 Feb 2025 00:00:00 +0000</pubDate>
      <guid>https://huoxj.github.io/posts/van-%E6%B8%B8%E6%88%8F/%E6%9A%97%E5%96%BB%E5%B9%BB%E6%83%B3/</guid>
      <description>&lt;h2 id=&#34;贯彻了-atlus-风格的又一优秀-jrpg&#34;&gt;贯彻了 Atlus 风格的又一优秀 JRPG&lt;/h2&gt;&#xA;&lt;p&gt;先说结论：暗喻幻想是一部贯彻了 Atlus 高制作水准的成功之作。阿特拉斯擅长的美术、音乐、节奏、羁绊叙事都还是原来的那个味道。&lt;/p&gt;&#xA;&lt;p&gt;游戏还未发售时，大胆与前卫的美术（主要指 UI 以及演出）便在宣传片中体现得淋漓尽致。这一点就能明显体会到制作组想要复刻 P5 成功的强烈欲望，二者的美术都是让人眼前一亮的程度。为了配合世界观，暗喻幻想采用了很多中世纪文艺复兴美术元素，包括油画、几何、人体。但同时也融合了张扬与华丽的组织设计，UI 不再是游戏的装饰，而是作为特色和游戏本身的故事、人物特点相辅相成。王道故事配合张扬的 UI 美工实在让人心潮澎湃。不过，过于华丽的 UI 动效主要还是建立良好的第一印象，玩到后面时，有些 UI 过渡动画就稍显繁杂了。比如地图切换时的动画必须播完了才能传送、花钱时长达一秒钟的扣钱动画都会让本就略显平淡的推日常更为拖沓。还有一个不得不吐槽的点是，传送、开箱子时有吃闪死亡白屏，需要背闪保护眼睛。&lt;/p&gt;&#xA;&lt;p&gt;既然是中世纪 + 王道，音乐也变得十分神圣宏伟。虽然不像 UI 那样有着极为强烈的风格，但整体而言水准也是在线甚至值得夸赞的。点名表扬几首曲子的人声，不亚于预告信的小曲一样让人暴起鸡皮疙瘩：&lt;/p&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;荒野を往く者 （开头结尾的小曲）&lt;/li&gt;&#xA;&lt;li&gt;猛き者たちよ （先手攻击的小曲）&lt;/li&gt;&#xA;&lt;li&gt;英雄たちに捧ぐ詩 （伪天鹅绒房间的小曲，最佳之一）&lt;/li&gt;&#xA;&lt;li&gt;自由の翼 （后期铁甲战车的小曲）&lt;/li&gt;&#xA;&lt;/ul&gt;</description>
    </item>
    <item>
      <title>读论文-Vectorized Batch PIR</title>
      <link>https://huoxj.github.io/posts/%E8%8A%9D%E5%A3%AB%E6%94%B6%E5%AE%B9%E6%89%80/%E8%AF%BB%E8%AE%BA%E6%96%87-vectorized-batch-pir/</link>
      <pubDate>Mon, 27 Jan 2025 00:00:00 +0000</pubDate>
      <guid>https://huoxj.github.io/posts/%E8%8A%9D%E5%A3%AB%E6%94%B6%E5%AE%B9%E6%89%80/%E8%AF%BB%E8%AE%BA%E6%96%87-vectorized-batch-pir/</guid>
      <description>&lt;p&gt;传统的 PIR (Private Information Retrieval) 里，客户端一次 PIR 只会请求数据库中的一个项。但在实际使用中，客户端往往会请求多个项，但为每一个项都单独调用一次 PIR 显然不够并行，而且会暴露用户请求的次数，所以诞生了 Batch PIR。这篇论文提出了一个基于向量化优化的 Batch PIR。相较传统的 Batch PIR，沟通开销有 7.5x ~ 98.5x 的提升。&lt;/p&gt;&#xA;&lt;h2 id=&#34;前置知识&#34;&gt;前置知识&lt;/h2&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;Somewhat Homomorphic Encryption&lt;/li&gt;&#xA;&lt;li&gt;Vectorized Homomorphic Encryption&lt;/li&gt;&#xA;&lt;li&gt;Noise Growth and Computation Cost of SHE Operations&lt;/li&gt;&#xA;&lt;li&gt;PIR and Batch PIR&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;h2 id=&#34;previous-batch-pir&#34;&gt;Previous Batch PIR&lt;/h2&gt;&#xA;&lt;blockquote&gt;&#xA;&lt;p&gt;Angel 等人的传统 PIR 方法&lt;/p&gt;&#xA;&lt;/blockquote&gt;&#xA;&lt;p&gt;&lt;img src=&#34;https://runzblog.oss-cn-hangzhou.aliyuncs.com/postimg/202501271758248.png&#34; alt=&#34;&#34;&gt;&lt;/p&gt;&#xA;&lt;p&gt;以论文里的图为例：&lt;/p&gt;&#xA;&lt;p&gt;在所有请求发生之前，server 需要初始化 $w$ 个哈希函数 $h$（图中 $w=3$ 个）。然后将数据库中的每一项的项数编号，分布通过这几个函数来映射到 $w$ 个桶里。&lt;/p&gt;&#xA;&lt;blockquote&gt;&#xA;&lt;p&gt;桶的大小一般取 $B=1.5b$，其中 $b$ 是客户端请求 batch 的宽度。图中 $b=3, B=5$&lt;/p&gt;&#xA;&lt;/blockquote&gt;&#xA;&lt;p&gt;客户端发起请求，目标是生成一个宽度为 $B$ 的请求向量。对客户端请求的 batch 中的每一项，依次尝试使用那几个哈希函数来映射到桶里，只要有一个能映射到空桶（图中用 $\perp$ 表示），就把这一项放进去。&lt;/p&gt;</description>
    </item>
    <item>
      <title>读论文-一种私有信息检索在GPU上的高效实现</title>
      <link>https://huoxj.github.io/posts/%E8%8A%9D%E5%A3%AB%E6%94%B6%E5%AE%B9%E6%89%80/%E8%AF%BB%E8%AE%BA%E6%96%87-%E4%B8%80%E7%A7%8D%E7%A7%81%E6%9C%89%E4%BF%A1%E6%81%AF%E6%A3%80%E7%B4%A2%E5%9C%A8gpu%E4%B8%8A%E7%9A%84%E9%AB%98%E6%95%88%E5%AE%9E%E7%8E%B0/</link>
      <pubDate>Wed, 22 Jan 2025 00:00:00 +0000</pubDate>
      <guid>https://huoxj.github.io/posts/%E8%8A%9D%E5%A3%AB%E6%94%B6%E5%AE%B9%E6%89%80/%E8%AF%BB%E8%AE%BA%E6%96%87-%E4%B8%80%E7%A7%8D%E7%A7%81%E6%9C%89%E4%BF%A1%E6%81%AF%E6%A3%80%E7%B4%A2%E5%9C%A8gpu%E4%B8%8A%E7%9A%84%E9%AB%98%E6%95%88%E5%AE%9E%E7%8E%B0/</guid>
      <description>&lt;p&gt;原文 title：GPU-Based PIR for On-device ML Inference&lt;/p&gt;&#xA;&lt;h2 id=&#34;背景&#34;&gt;背景&lt;/h2&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;&#xA;&lt;p&gt;On-device ML Inference 的 device 有计算与存储限制&lt;/p&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;&#xA;&lt;p&gt;在推荐等场景下，ML 推理需要查 Embedding table&lt;/p&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;&#xA;&lt;p&gt;Embedding table 相当大，不得不存在云端&lt;/p&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;&#xA;&lt;p&gt;用户直接查表，可能会泄露用户隐私&lt;/p&gt;&#xA;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;&#xA;&lt;p&gt;使用 naive DPF-PIR 查表&lt;/p&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;&#xA;&lt;p&gt;通信成本高，表有多长就得传多大的向量&lt;/p&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;&#xA;&lt;p&gt;计算成本高，加密次数多&lt;/p&gt;&#xA;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;h2 id=&#34;优化-dpf-pir&#34;&gt;优化 DPF-PIR&lt;/h2&gt;&#xA;&lt;h3 id=&#34;建模&#34;&gt;建模&lt;/h3&gt;&#xA;&lt;p&gt;DPF-PIR 在单次查询中，主要有三个步骤：&lt;/p&gt;&#xA;&lt;ol&gt;&#xA;&lt;li&gt;&#xA;&lt;p&gt;(client) 生成(gen)密钥&lt;/p&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;&#xA;&lt;p&gt;(server) 评估(eval)密钥，得到秘密分享 secret share&lt;/p&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;&#xA;&lt;p&gt;(server) 计算秘密分享与 Embedding table 矩阵的积，返回给 client&lt;/p&gt;&#xA;&lt;/li&gt;&#xA;&lt;/ol&gt;&#xA;&lt;p&gt;其中，gen 步骤不是瓶颈，目前不需要优化。&lt;/p&gt;&#xA;&lt;p&gt;多个查询之间是独立的，使用 Batch 优化。&lt;/p&gt;&#xA;&lt;h3 id=&#34;eval-的-gpu-优化&#34;&gt;eval 的 GPU 优化&lt;/h3&gt;&#xA;&lt;p&gt;论文里选择了引用 [32] 描述的 DPF 算法。本质上是一个动态规划/dfs。&lt;/p&gt;&#xA;&lt;blockquote&gt;&#xA;&lt;p&gt;我觉得选择这个 DPF 算法的原因主要是考虑了通信开销。开销是随着 Embedding table 的大小对数增长的。&lt;/p&gt;&#xA;&lt;p&gt;只是文章里没细说，也没有列举其他的算法并进行对比。&lt;/p&gt;&#xA;&lt;/blockquote&gt;&#xA;&lt;p&gt;递推公式只取和优化相关的部分，大致长这样：&lt;/p&gt;&#xA;&lt;p&gt;$$&lt;br&gt;&#xA;P(d,j)=f(P(d-1,\lfloor j/2\rfloor))&lt;br&gt;&#xA;$$&lt;/p&gt;</description>
    </item>
    <item>
      <title>STL-算法</title>
      <link>https://huoxj.github.io/posts/c&#43;&#43;%E6%8B%BE%E9%81%97/stl-%E7%AE%97%E6%B3%95/</link>
      <pubDate>Sun, 19 Jan 2025 00:00:00 +0000</pubDate>
      <guid>https://huoxj.github.io/posts/c&#43;&#43;%E6%8B%BE%E9%81%97/stl-%E7%AE%97%E6%B3%95/</guid>
      <description>&lt;h2 id=&#34;谓词&#34;&gt;谓词&lt;/h2&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;std::all_of&lt;/li&gt;&#xA;&lt;li&gt;std::any_of&lt;/li&gt;&#xA;&lt;li&gt;std::none_of&lt;/li&gt;&#xA;&lt;/ul&gt;</description>
    </item>
    <item>
      <title>NJUSE-嵌入式期末复习</title>
      <link>https://huoxj.github.io/posts/%E5%B5%8C%E5%85%A5%E5%BC%8F/njuse-%E5%B5%8C%E5%85%A5%E5%BC%8F%E6%9C%9F%E6%9C%AB%E5%A4%8D%E4%B9%A0/</link>
      <pubDate>Tue, 07 Jan 2025 00:00:00 +0000</pubDate>
      <guid>https://huoxj.github.io/posts/%E5%B5%8C%E5%85%A5%E5%BC%8F/njuse-%E5%B5%8C%E5%85%A5%E5%BC%8F%E6%9C%9F%E6%9C%AB%E5%A4%8D%E4%B9%A0/</guid>
      <description>&lt;blockquote&gt;&#xA;&lt;p&gt;已经放弃了，还是看同学整理的笔记吧，知识点太多了&lt;/p&gt;&#xA;&lt;/blockquote&gt;&#xA;&lt;p&gt;2024-2025 第一学期嵌入式期末复习&lt;/p&gt;&#xA;&lt;h2 id=&#34;1-嵌入式系统概述&#34;&gt;1. 嵌入式系统概述&lt;/h2&gt;&#xA;&lt;h3 id=&#34;定义&#34;&gt;定义&lt;/h3&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;IEEE定义：用于控制、监控或者辅助操作机器和设备的装置&lt;/li&gt;&#xA;&lt;li&gt;国内定义：嵌入式系统是以应用为中心以计算机技术为基础，软硬件可裁剪，适用于应用系统对功能、可靠性、成本、体积、功耗有严格要求的专业计算机系统&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;h3 id=&#34;术语&#34;&gt;术语&lt;/h3&gt;&#xA;&lt;h3 id=&#34;组成&#34;&gt;组成&lt;/h3&gt;&#xA;&lt;p&gt;由嵌入式硬件和软件组成&lt;/p&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;硬件：微处理器为核心继承寻初期和系统专用的输入输出设备&lt;/li&gt;&#xA;&lt;li&gt;软件：初始化代码及驱动、嵌入式操作系统和应用程序有机结合，形成系统特定的一体化软件。&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;h3 id=&#34;特点&#34;&gt;特点&lt;/h3&gt;&#xA;&lt;ol&gt;&#xA;&lt;li&gt;形式多样，面向特定应用&lt;/li&gt;&#xA;&lt;li&gt;得到多种类型处理器和处理器体系结构的支持&lt;/li&gt;&#xA;&lt;li&gt;极其关注成本&lt;/li&gt;&#xA;&lt;li&gt;有实时性和可靠性要求&lt;/li&gt;&#xA;&lt;li&gt;使用的操作系统使用多种处理器、可裁剪、轻量型、实时可靠、可固化的嵌入式操作系统&lt;/li&gt;&#xA;&lt;li&gt;需要专门工具和特殊方法&lt;/li&gt;&#xA;&lt;/ol&gt;&#xA;&lt;h3 id=&#34;分类&#34;&gt;分类&lt;/h3&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;按处理器位数：4位、8位、16位、32位、64位&lt;/li&gt;&#xA;&lt;li&gt;按应用：信息家电、汽车电子、通信、移动终端、工业控制&lt;/li&gt;&#xA;&lt;li&gt;按速度：强实时系统、一般实时系统、弱实时系统&lt;/li&gt;&#xA;&lt;li&gt;按确定性：硬实时系统、软实时系统&lt;/li&gt;&#xA;&lt;li&gt;按复杂程度：循环轮询系统、有限状态机系统、前后台机系统、单处理器多任务系统、多处理器多任务系统&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;h3 id=&#34;典型应用&#34;&gt;典型应用&lt;/h3&gt;&#xA;&lt;p&gt;工控设备、军用电子设备、航空航天、汽车电子、信息家电、通信、智能玩具、可穿戴设备。&lt;/p&gt;&#xA;&lt;h3 id=&#34;发展趋势&#34;&gt;发展趋势&lt;/h3&gt;&#xA;&lt;h2 id=&#34;2-嵌入式微处理器&#34;&gt;2. 嵌入式微处理器&lt;/h2&gt;&#xA;&lt;h3 id=&#34;分类-1&#34;&gt;分类&lt;/h3&gt;&#xA;&lt;p&gt;按结构区分，有冯诺依曼结构和哈佛结构。&lt;/p&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;冯诺依曼结构：数据和程序放在同一个存储单元，统一编制，指令和数据通过同一个总线访问&lt;/li&gt;&#xA;&lt;li&gt;哈佛结构：程序和数据存储在不同的空间中，即程序存储器和数据存储器是两个相互独立的存储器，每个存储器独立编制、独立访问。与之相对应的是系统中设置的两条总线（程序总线和数据总线），从而使数据的吞吐量提高了一倍（更大存储代管和更大可预测带宽）&lt;/li&gt;&#xA;&lt;li&gt;哈佛结构不能使用自修改代码&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;p&gt;按指令集区分，有 CISC 和 RISC&lt;/p&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;CISC：复杂指令集（许多地址格式，许多操作）&lt;/li&gt;&#xA;&lt;li&gt;RISC：精简指令集（流水型指令）&lt;/li&gt;&#xA;&lt;li&gt;RISC机器用来减少指令周期的一种技术，可提高处理器和总线使用率&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;table&gt;&#xA;  &lt;thead&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;th style=&#34;text-align: left&#34;&gt;&lt;/th&gt;&#xA;          &lt;th style=&#34;text-align: left&#34;&gt;CISC&lt;/th&gt;&#xA;          &lt;th style=&#34;text-align: left&#34;&gt;RISC&lt;/th&gt;&#xA;      &lt;/tr&gt;&#xA;  &lt;/thead&gt;&#xA;  &lt;tbody&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;td style=&#34;text-align: left&#34;&gt;价格&lt;/td&gt;&#xA;          &lt;td style=&#34;text-align: left&#34;&gt;由硬件完成部分软件功能，硬件复杂性增加，芯片成本高&lt;/td&gt;&#xA;          &lt;td style=&#34;text-align: left&#34;&gt;由软件完成部分硬件功能，软件复杂性增加，芯片成本低&lt;/td&gt;&#xA;      &lt;/tr&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;td style=&#34;text-align: left&#34;&gt;性能&lt;/td&gt;&#xA;          &lt;td style=&#34;text-align: left&#34;&gt;减少代码尺寸，增加指令的执行周期数&lt;/td&gt;&#xA;          &lt;td style=&#34;text-align: left&#34;&gt;使用流水线降低指令的执行周期数，增加代码尺寸&lt;/td&gt;&#xA;      &lt;/tr&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;td style=&#34;text-align: left&#34;&gt;指令集&lt;/td&gt;&#xA;          &lt;td style=&#34;text-align: left&#34;&gt;大量的混杂指令集，有简单快速的指令，也有复杂多周期指令，符合HLL&lt;/td&gt;&#xA;          &lt;td style=&#34;text-align: left&#34;&gt;简单的单周期指令，在汇编指令方面有相应的SISC伪代码指令&lt;/td&gt;&#xA;      &lt;/tr&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;td style=&#34;text-align: left&#34;&gt;高级语言支持&lt;/td&gt;&#xA;          &lt;td style=&#34;text-align: left&#34;&gt;硬件完成&lt;/td&gt;&#xA;          &lt;td style=&#34;text-align: left&#34;&gt;软件完成&lt;/td&gt;&#xA;      &lt;/tr&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;td style=&#34;text-align: left&#34;&gt;寻址模式&lt;/td&gt;&#xA;          &lt;td style=&#34;text-align: left&#34;&gt;复杂的寻址模式，支持内存到内存寻址&lt;/td&gt;&#xA;          &lt;td style=&#34;text-align: left&#34;&gt;简单的寻址模式，仅允许LOAD和STORE指令存取内存，其他所有的操作都基于寄存器到寄存器&lt;/td&gt;&#xA;      &lt;/tr&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;td style=&#34;text-align: left&#34;&gt;寄存器数目&lt;/td&gt;&#xA;          &lt;td style=&#34;text-align: left&#34;&gt;寄存器较少&lt;/td&gt;&#xA;          &lt;td style=&#34;text-align: left&#34;&gt;寄存器较多&lt;/td&gt;&#xA;      &lt;/tr&gt;&#xA;  &lt;/tbody&gt;&#xA;&lt;/table&gt;&#xA;&lt;h3 id=&#34;特点-1&#34;&gt;特点&lt;/h3&gt;&#xA;&lt;h3 id=&#34;流水线清空&#34;&gt;流水线清空&lt;/h3&gt;&#xA;&lt;h3 id=&#34;分支预测技术&#34;&gt;分支预测技术&lt;/h3&gt;&#xA;&lt;h3 id=&#34;设备分类&#34;&gt;设备分类&lt;/h3&gt;&#xA;&lt;p&gt;根据能力与性能分类&lt;/p&gt;&#xA;&lt;h2 id=&#34;3-存储器架构&#34;&gt;3. 存储器架构&lt;/h2&gt;&#xA;&lt;h3 id=&#34;复杂&#34;&gt;复杂&lt;/h3&gt;&#xA;&lt;h3 id=&#34;易失性存储器&#34;&gt;易失性存储器&lt;/h3&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;RAM&#xA;RAM也称随机存储器，那么随机是什么意思？所谓随机，指的是当存储器中的数据被读取或写入时，所需要的时间与这段信息所在的位置无关（任何位置读写速度一样）。&lt;/li&gt;&#xA;&lt;li&gt;DRAM&#xA;DRAM（Dynamic Random Access Memory，动态随机存储器）是最为常见的系统内存。我们使用的电脑和手机的运行内存都是DRAM。DRAM使用电容存储，DRAM 只能将数据保持很短的时间。&lt;/li&gt;&#xA;&lt;li&gt;SRAM&#xA;SRAM（Static Random Access Memory，静态随机存储器），它是一种具有静止存取功能的内存，其内部机构比DRAM复杂，可以做到不刷新电路即能保存它内部存储的数据。&lt;/li&gt;&#xA;&lt;li&gt;SDRAM&#xA;SDRAM：（Synchronous Dynamic Random Access Memory，同步动态随机存取存储器），为DRAM的一种，同步是指Memory工作需要同步时钟，内部命令的发送与数据的传输都以时钟为基准；动态是指存储阵列需要不断的刷新来保证数据不丢失；随机是指数据不是线性依次存储，而是由指定地址进行数据读写。&lt;/li&gt;&#xA;&lt;li&gt;还有DDR SDRAM、DDR2 SDRAM、DDR3SDRAM不做过多赘述，感兴趣可以自己百度。&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;h3 id=&#34;非易失性存储器&#34;&gt;非易失性存储器&lt;/h3&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;ROM&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;p&gt;只读存储器（Read-Only Memory）是一种只能读取资bai料的存储器。在制造过程中，将资料以一特制光罩（mask）烧录于线路中，其资料内容在写入后就不能更改，所以有时又称为“光罩式只读内存”（mask ROM）。&lt;/p&gt;</description>
    </item>
    <item>
      <title>SE-ML-11 高斯混合模型</title>
      <link>https://huoxj.github.io/posts/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/se-ml-11-%E9%AB%98%E6%96%AF%E6%B7%B7%E5%90%88%E6%A8%A1%E5%9E%8B/</link>
      <pubDate>Mon, 06 Jan 2025 00:00:00 +0000</pubDate>
      <guid>https://huoxj.github.io/posts/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/se-ml-11-%E9%AB%98%E6%96%AF%E6%B7%B7%E5%90%88%E6%A8%A1%E5%9E%8B/</guid>
      <description>&lt;p&gt;&lt;a href=&#34;https://zhuanlan.zhihu.com/p/151671154&#34;&gt;如何通俗的理解高斯混合模型（Gaussian Mixture Models） - 知乎&lt;/a&gt;&lt;/p&gt;</description>
    </item>
    <item>
      <title>SE-ML02-模型评估与选择</title>
      <link>https://huoxj.github.io/posts/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/se-ml02-%E6%A8%A1%E5%9E%8B%E8%AF%84%E4%BC%B0%E4%B8%8E%E9%80%89%E6%8B%A9/</link>
      <pubDate>Sun, 05 Jan 2025 00:00:00 +0000</pubDate>
      <guid>https://huoxj.github.io/posts/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/se-ml02-%E6%A8%A1%E5%9E%8B%E8%AF%84%E4%BC%B0%E4%B8%8E%E9%80%89%E6%8B%A9/</guid>
      <description>&lt;h2 id=&#34;统计学习方法三要素&#34;&gt;统计学习方法三要素&lt;/h2&gt;&#xA;&lt;h3 id=&#34;模型&#34;&gt;模型&lt;/h3&gt;&#xA;&lt;p&gt;在假设空间中的一个具体假设。是一个需要学习的函数。&lt;/p&gt;&#xA;&lt;h3 id=&#34;策略&#34;&gt;策略&lt;/h3&gt;&#xA;&lt;p&gt;如何从假设空间中选择&lt;strong&gt;最优&lt;/strong&gt;的假设/模型。&lt;/p&gt;&#xA;&lt;p&gt;怎么判断模型优不优秀？&lt;strong&gt;损失函数&lt;/strong&gt;与风险函数。&lt;/p&gt;&#xA;&lt;h4 id=&#34;损失函数&#34;&gt;损失函数&lt;/h4&gt;&#xA;&lt;p&gt;评估 $f$ 在样本 $X$ 上，与真实值 $Y$ 的差距。&lt;/p&gt;&#xA;&lt;p&gt;常见的损失函数：&lt;/p&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;平方损失函数 $$L(Y,f(X))=(Y-f(X)^2)$$&lt;/li&gt;&#xA;&lt;li&gt;0-1损失函数 $$L(Y,f(X))=\begin{equation}\begin{cases}1,Y\neq f(X) \ \0,Y= f(X)\end{cases} \end{equation} $$&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;h4 id=&#34;风险函数&#34;&gt;风险函数&lt;/h4&gt;&#xA;&lt;p&gt;经验风险：模型在训练数据集上的平均损失&#xA;结构风险：在经验风险的基础上，增加对模型复杂度，或者其他自定义惩罚&lt;/p&gt;&#xA;&lt;p&gt;两种风险越低，模型越优。&lt;/p&gt;&#xA;&lt;h3 id=&#34;算法&#34;&gt;算法&lt;/h3&gt;&#xA;&lt;p&gt;学习模型的具体方法。即损失函数或者风险函数的最优化问题。&lt;/p&gt;&#xA;&lt;p&gt;有两种情况：&lt;/p&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;问题存在解析解，直接求解问题就可以得到最优模型&lt;/li&gt;&#xA;&lt;li&gt;问题没有解析解，那就需要梯度下降、牛顿法这种方式去逼近最优解&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;blockquote&gt;&#xA;&lt;p&gt;最小二乘法就是存在解析解的问题，可以直接通过解方程求得使模型最优的参数。神经网络就需要不断通过梯度下降的方式更新权重。&lt;/p&gt;&#xA;&lt;/blockquote&gt;&#xA;&lt;h2 id=&#34;评估方法&#34;&gt;评估方法&lt;/h2&gt;&#xA;&lt;blockquote&gt;&#xA;&lt;p&gt;解决 “如何获得测试结果” 的问题&lt;/p&gt;&#xA;&lt;/blockquote&gt;&#xA;&lt;h3 id=&#34;测试集与训练集的划分&#34;&gt;测试集与训练集的划分&lt;/h3&gt;&#xA;&lt;h4 id=&#34;留出法&#34;&gt;留出法&lt;/h4&gt;&#xA;&lt;p&gt;将拥有的数据集，一部分划作训练集，剩下就是测试集。&lt;/p&gt;&#xA;&lt;p&gt;注意：&lt;/p&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;保持数据分布一致性（分层采样）&lt;/li&gt;&#xA;&lt;li&gt;多次重复划分（？没看懂）&lt;/li&gt;&#xA;&lt;li&gt;测试集的比例，在 20% ~ 33% 间&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;h4 id=&#34;k-折交叉验证法&#34;&gt;K-折交叉验证法&lt;/h4&gt;&#xA;&lt;p&gt;将测试集分为 K 份。进行 k 次训练。每一次按顺序选取第 i 份作为测试集，其他作为训练集。将 k 次的测试结果取平均，作为最终的结果。&lt;/p&gt;&#xA;&lt;p&gt;&lt;img src=&#34;https://runzblog.oss-cn-hangzhou.aliyuncs.com/postimg/202501050857236.png&#34; alt=&#34;&#34;&gt;&lt;/p&gt;&#xA;&lt;h4 id=&#34;自助法&#34;&gt;自助法&lt;/h4&gt;&#xA;&lt;p&gt;一种可重复采样的方法。训练集和测试集可能有交集。&lt;/p&gt;&#xA;&lt;h3 id=&#34;调参&#34;&gt;调参&lt;/h3&gt;&#xA;&lt;p&gt;在整个训练过程中，有两种参数：&lt;/p&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;算法的参数。就是超参数，使用&lt;strong&gt;验证集&lt;/strong&gt;人工调参&lt;/li&gt;&#xA;&lt;li&gt;模型的参数。由学习确定&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;p&gt;在模型训练中，将验证集和训练集一起作为训练集。&lt;/p&gt;&#xA;&lt;h2 id=&#34;性能度量&#34;&gt;性能度量&lt;/h2&gt;&#xA;&lt;blockquote&gt;&#xA;&lt;p&gt;衡量模型泛化能力&lt;/p&gt;</description>
    </item>
    <item>
      <title>SE-ML03-线性模型</title>
      <link>https://huoxj.github.io/posts/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/se-ml03-%E7%BA%BF%E6%80%A7%E6%A8%A1%E5%9E%8B/</link>
      <pubDate>Sun, 05 Jan 2025 00:00:00 +0000</pubDate>
      <guid>https://huoxj.github.io/posts/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/se-ml03-%E7%BA%BF%E6%80%A7%E6%A8%A1%E5%9E%8B/</guid>
      <description>&lt;h2 id=&#34;线性可分性&#34;&gt;线性可分性&lt;/h2&gt;&#xA;&lt;p&gt;任意两个向量，分别属于两个类别。这两个向量和某个确定的权重向量的线性组合得到的标量值，如果一定落在某个标量值的两侧，那么这两个类别是线性可分的。&lt;/p&gt;&#xA;&lt;p&gt;&lt;img src=&#34;https://runzblog.oss-cn-hangzhou.aliyuncs.com/postimg/202501050935696.png&#34; alt=&#34;&#34;&gt;&lt;/p&gt;&#xA;&lt;h2 id=&#34;感知机&#34;&gt;感知机&lt;/h2&gt;&#xA;&lt;p&gt;经典的二分类、线性、判别模型。&lt;/p&gt;&#xA;&lt;p&gt;$$&#xA;f(x)=sign(\textbf{w}^T\textbf{x}+b)&#xA;$$&lt;/p&gt;&#xA;&lt;p&gt;$\textbf{w}$ 是平面的法向量，$b$ 是到原点位移。用这个超平面来判别。&lt;/p&gt;&#xA;&lt;h2 id=&#34;线性回归&#34;&gt;线性回归&lt;/h2&gt;&#xA;&lt;h3 id=&#34;一元线性回归&#34;&gt;一元线性回归&lt;/h3&gt;&#xA;&lt;blockquote&gt;&#xA;&lt;p&gt;高中数学知识&lt;/p&gt;&#xA;&lt;/blockquote&gt;&#xA;&lt;p&gt;最小化均方误差。进行一堆最小二乘估计，得到最优解：&lt;/p&gt;&#xA;&lt;p&gt;$$&#xA;w=\frac{\sum_{i=1}^{m}y_i(x_i-\bar{x})}{\sum_{i=1}^{m}x^2_i-\frac{1}{m}(\sum_{i=1}^mx_i)^2}&#xA;\quad\quad&#xA;b=\frac{1}{m}\sum_{i=1}^m(y_i-wx_i)&#xA;$$&lt;/p&gt;&#xA;&lt;h3 id=&#34;多元线性回归&#34;&gt;多元线性回归&lt;/h3&gt;&#xA;&lt;p&gt;$$&#xA;f(x)=\textbf{w}^T\textbf{x}+b \quad 使得\quad f(\textbf{x}_i\simeq y_i)&#xA;$$&lt;/p&gt;&#xA;&lt;p&gt;求解思想是类似的，但是涉及矩阵求逆。&lt;/p&gt;&#xA;&lt;h2 id=&#34;广义线性模型&#34;&gt;广义线性模型&lt;/h2&gt;&#xA;&lt;p&gt;给线性组合加上一个&lt;strong&gt;单调可微&lt;/strong&gt;的联系函数，这个联系函数可以是非线性的。&lt;/p&gt;&#xA;&lt;p&gt;$$&#xA;y=g^{-1}(\textbf{w}^t\textbf{x}+b)&#xA;$$&lt;/p&gt;&#xA;&lt;h2 id=&#34;二分类任务&#34;&gt;二分类任务&lt;/h2&gt;&#xA;&lt;p&gt;使用特殊的联系函数，使得输出满足 $y\in{0,1}$&lt;/p&gt;&#xA;&lt;h3 id=&#34;联系函数&#34;&gt;联系函数&lt;/h3&gt;&#xA;&lt;h4 id=&#34;单位阶跃函数&#34;&gt;单位阶跃函数&lt;/h4&gt;&#xA;&lt;p&gt;$$&#xA;y=\begin{equation}\begin{cases}0,&amp;amp;z&amp;lt;0\0.5,&amp;amp;z=0\1,&amp;amp;z&amp;gt;0\end{cases}\end{equation}&#xA;$$&lt;/p&gt;&#xA;&lt;p&gt;性质不好，因为不是连续函数。不可微。&lt;/p&gt;&#xA;&lt;h4 id=&#34;对数几率函数&#34;&gt;对数几率函数&lt;/h4&gt;&#xA;&lt;p&gt;大名鼎鼎 Logistic function。高中生物里种群数量的 S 形曲线。&lt;/p&gt;&#xA;&lt;p&gt;$$&#xA;y=\frac{1}{1+e^-z}&#xA;$$&lt;/p&gt;&#xA;&lt;p&gt;衍生出了 Logistic 回归。&lt;/p&gt;&#xA;&lt;h3 id=&#34;logistic-回归&#34;&gt;Logistic 回归&lt;/h3&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;无需假设数据分布&lt;/li&gt;&#xA;&lt;li&gt;可以得到类别的近似概率预测&lt;/li&gt;&#xA;&lt;li&gt;使用数值优化算法求最优解&lt;/li&gt;&#xA;&lt;li&gt;是&lt;strong&gt;分类算法&lt;/strong&gt;，而不是回归算法&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;p&gt;以 Logistic 函数作为联系函数。&lt;/p&gt;&#xA;&lt;p&gt;&lt;img src=&#34;https://runzblog.oss-cn-hangzhou.aliyuncs.com/postimg/202501051007913.png&#34; alt=&#34;&#34;&gt;&lt;/p&gt;&#xA;&lt;p&gt;最后的 $ln\frac{y}{1-y}$ 称为“对数几率”。反映了 x 作为正例的相对可能性。&lt;/p&gt;</description>
    </item>
    <item>
      <title>SE-ML06-支持向量机</title>
      <link>https://huoxj.github.io/posts/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/se-ml06-%E6%94%AF%E6%8C%81%E5%90%91%E9%87%8F%E6%9C%BA/</link>
      <pubDate>Sun, 05 Jan 2025 00:00:00 +0000</pubDate>
      <guid>https://huoxj.github.io/posts/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/se-ml06-%E6%94%AF%E6%8C%81%E5%90%91%E9%87%8F%E6%9C%BA/</guid>
      <description>&lt;h2 id=&#34;线性-svm&#34;&gt;线性 SVM&lt;/h2&gt;&#xA;&lt;p&gt;线性 SVM &lt;strong&gt;最大化&lt;/strong&gt;所有训练样本到决策平面的&lt;strong&gt;最小距离&lt;/strong&gt;。&lt;/p&gt;&#xA;&lt;p&gt;具有最小距离的样本，叫支持向量。&lt;/p&gt;&#xA;&lt;p&gt;&lt;img src=&#34;https://runzblog.oss-cn-hangzhou.aliyuncs.com/postimg/202501051110666.png&#34; alt=&#34;&#34;&gt;&lt;/p&gt;&#xA;&lt;h3 id=&#34;计算-margin&#34;&gt;计算 margin&lt;/h3&gt;&#xA;&lt;p&gt;给定模型 $f(\textbf{x})=\textbf{w}^T\textbf{x}+b$，和任一样本 $x$ ，求其到超平面的距离 $r$。&lt;/p&gt;&#xA;&lt;p&gt;$r=\frac{|f(x)|}{||w||}$&lt;/p&gt;&#xA;&lt;p&gt;需要优化的式子出来了：&lt;/p&gt;&#xA;&lt;p&gt;$$&#xA;\mathop{argmax}\limits_{\textbf{w},b}(\mathop{min}\limits_{i}(r_i))&#xA;$$&lt;/p&gt;&#xA;&lt;p&gt;可以看到，这个式子的取值完全由间隔最小的样本决定。即模型的参数完全是由&lt;strong&gt;支持向量&lt;/strong&gt;决定的。&lt;/p&gt;&#xA;&lt;h3 id=&#34;分类&#34;&gt;分类&lt;/h3&gt;&#xA;&lt;p&gt;$f(x) &amp;gt; 0$ 分为正类，否则是反类。我们的目标就是让 SVM 尽量能完全分开两个类。&lt;/p&gt;&#xA;&lt;p&gt;至于如何判断预测是否正确，如果正类的真实值是 1，反类是 -1 的话&lt;/p&gt;&#xA;&lt;p&gt;$y_if(x_i)$ 为正值，预测正确。否则预测错误。&lt;/p&gt;&#xA;&lt;p&gt;利用这个性质，需要优化的式子可以这样变，以保证 SVM 的可分性：&lt;/p&gt;&#xA;&lt;p&gt;$$&#xA;\mathop{argmax}\limits_{\textbf{w},b}(\mathop{min}\limits_{i}(\frac{y_if(x_i)}{\textbf{||w||}}))&#xA;$$&lt;/p&gt;&#xA;&lt;p&gt;既考虑了预测的正确性，也考虑了最大化间隔的目标。&lt;/p&gt;&#xA;&lt;h3 id=&#34;进一步优化&#34;&gt;进一步优化&lt;/h3&gt;&#xA;&lt;p&gt;要优化的式子还是不够简单。我们从优化结果反着考虑：&lt;/p&gt;&#xA;&lt;p&gt;假设我们最终得到的最优的模型的参数是 $(\textbf{w},b)$，考虑一个参数为 $(c\textbf{w},cb)$ 的模型，其中 $c&amp;gt;0$。&lt;/p&gt;&#xA;&lt;p&gt;可以发现，这个新模型和最优的模型一毛一样&lt;/p&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;对于样本 $x_i$，二者预测结果一致。因为 $c$ 根本不影响符号&lt;/li&gt;&#xA;&lt;li&gt;支持向量以及间隔不变，可以参考 $r$ 的公式，$c$ 都抵消掉了&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;p&gt;所以，我们可以通过引入这个参数 $c$ ，使得要优化的式子更简单。&lt;/p&gt;&#xA;&lt;p&gt;通过 $c$ 改变 $||w||=1$ 是一个不错的思路，但细想还是会发现，仍然比较复杂。&lt;/p&gt;&#xA;&lt;p&gt;直接揭晓答案：通过 $c$，在约束 $\mathop{min}\limits_{i}(y_if(x_i))=1$，同时最大化 $\frac{1}{||\textbf{w}||}$。&lt;/p&gt;&#xA;&lt;h3 id=&#34;拉格朗日乘子法&#34;&gt;拉格朗日乘子法&lt;/h3&gt;&#xA;&lt;p&gt;在约束条件下优化，可以用拉格朗日乘子法解决。&lt;/p&gt;</description>
    </item>
    <item>
      <title>SE-ML08-神经网络</title>
      <link>https://huoxj.github.io/posts/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/se-ml08-%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C/</link>
      <pubDate>Sun, 05 Jan 2025 00:00:00 +0000</pubDate>
      <guid>https://huoxj.github.io/posts/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/se-ml08-%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C/</guid>
      <description>&lt;h2 id=&#34;结构&#34;&gt;结构&lt;/h2&gt;&#xA;&lt;p&gt;输入 -&amp;gt; 权值 -&amp;gt; 激活函数 -&amp;gt; 偏置单元&lt;/p&gt;&#xA;&lt;h2 id=&#34;激活函数&#34;&gt;激活函数&lt;/h2&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;单位跃迁函数&lt;/li&gt;&#xA;&lt;li&gt;饱和激励函数：Sigmoid、tanh&lt;/li&gt;&#xA;&lt;li&gt;非饱和激励函数：ReLU 系列&lt;/li&gt;&#xA;&lt;/ul&gt;</description>
    </item>
    <item>
      <title>01-软件测试导览</title>
      <link>https://huoxj.github.io/posts/%E8%BD%AF%E4%BB%B6%E6%B5%8B%E8%AF%95/01-%E8%BD%AF%E4%BB%B6%E6%B5%8B%E8%AF%95%E5%AF%BC%E8%A7%88/</link>
      <pubDate>Fri, 03 Jan 2025 00:00:00 +0000</pubDate>
      <guid>https://huoxj.github.io/posts/%E8%BD%AF%E4%BB%B6%E6%B5%8B%E8%AF%95/01-%E8%BD%AF%E4%BB%B6%E6%B5%8B%E8%AF%95%E5%AF%BC%E8%A7%88/</guid>
      <description>&lt;h2 id=&#34;课程总览&#34;&gt;课程总览&lt;/h2&gt;&#xA;&lt;p&gt;三个部分，&lt;code&gt;经典测试&lt;/code&gt;、&lt;code&gt;移动应用测试&lt;/code&gt;和&lt;code&gt;AI测试&lt;/code&gt;&lt;/p&gt;&#xA;&lt;h2 id=&#34;测试的基本问题&#34;&gt;测试的基本问题&lt;/h2&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;测试设计问题：要问什么问题？&lt;/li&gt;&#xA;&lt;li&gt;测试预言问题：要怎么回答问题？&lt;/li&gt;&#xA;&lt;li&gt;测试终止问题：什么时候终止？&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;h2 id=&#34;pie-模型&#34;&gt;PIE 模型&lt;/h2&gt;&#xA;&lt;p&gt;PIE 模型解释了软件中的 Fault 如何导致 Failure。&lt;/p&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;Execution: The location or locations in the program that contain the fault must be &lt;strong&gt;reached&lt;/strong&gt;&lt;/li&gt;&#xA;&lt;li&gt;Infection : The &lt;strong&gt;state&lt;/strong&gt; of the program must be incorrect&lt;/li&gt;&#xA;&lt;li&gt;Propagation : The infected state must &lt;strong&gt;propagate&lt;/strong&gt; to cause some output of the program to be incorrect&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;h2 id=&#34;测试的局限性&#34;&gt;测试的局限性&lt;/h2&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;输入空间庞大。无法穷举所有输入。&lt;/li&gt;&#xA;&lt;li&gt;实现逻辑复杂。无法想到所有场景。&lt;/li&gt;&#xA;&lt;li&gt;测试预言未知。无法判定测试的预期输出&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;h2 id=&#34;随机测试-大数定律&#34;&gt;⭐随机测试-大数定律&lt;/h2&gt;&#xA;&lt;p&gt;测试&lt;strong&gt;执行次数够多&lt;/strong&gt;，并且测试&lt;strong&gt;数据随机生成&lt;/strong&gt;，总有概率低的&lt;strong&gt;偶然现象发生&lt;/strong&gt;。&lt;/p&gt;</description>
    </item>
    <item>
      <title>02-变异测试</title>
      <link>https://huoxj.github.io/posts/%E8%BD%AF%E4%BB%B6%E6%B5%8B%E8%AF%95/02-%E5%8F%98%E5%BC%82%E6%B5%8B%E8%AF%95/</link>
      <pubDate>Fri, 03 Jan 2025 00:00:00 +0000</pubDate>
      <guid>https://huoxj.github.io/posts/%E8%BD%AF%E4%BB%B6%E6%B5%8B%E8%AF%95/02-%E5%8F%98%E5%BC%82%E6%B5%8B%E8%AF%95/</guid>
      <description>&lt;p&gt;一言以蔽之，变异测试研究如何编写能够&lt;strong&gt;暴露缺陷&lt;/strong&gt;的测试用例，以及如何提升测试&lt;strong&gt;可信度&lt;/strong&gt;。&lt;/p&gt;&#xA;&lt;p&gt;将这些测试用例应用到待测程序中，就很有可能会发现待测程序的缺陷。&lt;/p&gt;&#xA;&lt;h2 id=&#34;概念&#34;&gt;概念&lt;/h2&gt;&#xA;&lt;h3 id=&#34;变异体&#34;&gt;变异体&lt;/h3&gt;&#xA;&lt;p&gt;基于一定的语法（Syntax）变换规则，通过对源程序进行程序变换（Program Transformation）得到的一系列变体。&lt;/p&gt;&#xA;&lt;p&gt;源程序不包含 Defect，变异体包含，那这个 Defect 叫&lt;code&gt;人工缺陷&lt;/code&gt;&lt;/p&gt;&#xA;&lt;h3 id=&#34;变异算子&#34;&gt;变异算子&lt;/h3&gt;&#xA;&lt;p&gt;上面所说的变换规则就是变异算子。&lt;/p&gt;&#xA;&lt;h3 id=&#34;变异存活杀死&#34;&gt;变异存活、杀死&lt;/h3&gt;&#xA;&lt;p&gt;如果一个变异体无法通过测试用例，这个变异体就被这个测试用例杀死了。&lt;/p&gt;&#xA;&lt;h3 id=&#34;变异得分&#34;&gt;变异得分&lt;/h3&gt;&#xA;&lt;p&gt;变异测试对测试套件错误检测能力的量化。&lt;/p&gt;&#xA;&lt;p&gt;是对于一个测试用例而言的。score 是&lt;strong&gt;所有变异体&lt;/strong&gt;在这个测试用例上&lt;strong&gt;运行失败&lt;/strong&gt;的比例。&lt;/p&gt;&#xA;&lt;p&gt;下标 k 代表变体 killed，被检测到了；s 代表 survived，没有被检测到。&lt;/p&gt;&#xA;&lt;p&gt;$$&#xA;score=\frac{mut_k}{mut_s+mut_k}\times100%&#xA;$$&lt;/p&gt;&#xA;&lt;h3 id=&#34;假设&#34;&gt;假设&lt;/h3&gt;&#xA;&lt;p&gt;基于这些假设，我们可以认为变异测试有效：&lt;/p&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;缺陷是&lt;strong&gt;简单的、可模拟&lt;/strong&gt;的&#xA;&lt;ul&gt;&#xA;&lt;li&gt;变异体模拟这些缺陷&lt;/li&gt;&#xA;&lt;li&gt;老练程序员假设：一个老练程序员编写的错误程序与正确程序相差不大&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;缺陷可&lt;strong&gt;叠加&lt;/strong&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;复杂变异体可以通过耦合简单变异体得到&lt;/li&gt;&#xA;&lt;li&gt;能够杀死简单变异体的测试用例可以杀死复杂变异体&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;缺陷检测&lt;strong&gt;有效性&lt;/strong&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;能检测人工缺陷的样例，也能检测真实程序的缺陷&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;h2 id=&#34;步骤&#34;&gt;步骤&lt;/h2&gt;&#xA;&lt;h3 id=&#34;1-变异体筛选&#34;&gt;1. 变异体筛选&lt;/h3&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;对变异体进行筛选&lt;/li&gt;&#xA;&lt;li&gt;通过变异算子筛选&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;h3 id=&#34;2-变异体生成&#34;&gt;2. 变异体生成&lt;/h3&gt;&#xA;&lt;p&gt;将选中的变异体通过算子实例化。&lt;/p&gt;&#xA;&lt;h3 id=&#34;3-变异体优化&#34;&gt;3. 变异体优化&lt;/h3&gt;&#xA;&lt;p&gt;去除等价和无效变异体。&lt;/p&gt;&#xA;&lt;p&gt;目的：减小开销、提高变异得分可信度&lt;/p&gt;&#xA;&lt;p&gt;形式：静态分析&lt;/p&gt;&#xA;&lt;h3 id=&#34;4-变异体执行&#34;&gt;4. 变异体执行&lt;/h3&gt;&#xA;&lt;p&gt;最昂贵的阶段。&lt;/p&gt;&#xA;&lt;h3 id=&#34;5-变异得分计算&#34;&gt;5. 变异得分计算&lt;/h3&gt;&#xA;&lt;p&gt;计算被杀死的变异体数量，进而得到变异得分、量化测试的充分性。&lt;/p&gt;&#xA;&lt;h2 id=&#34;应用与研究&#34;&gt;应用与研究&lt;/h2&gt;&#xA;&lt;h3 id=&#34;传统方向&#34;&gt;传统方向&lt;/h3&gt;&#xA;&lt;p&gt;测试优化、测试生成、调试辅助&lt;/p&gt;&#xA;&lt;h3 id=&#34;非传统&#34;&gt;非传统&lt;/h3&gt;&#xA;&lt;p&gt;非确定系统、行为建模、算子定义&lt;/p&gt;&#xA;&lt;h2 id=&#34;总结&#34;&gt;总结&lt;/h2&gt;&#xA;&lt;p&gt;这张图给个好评！&lt;/p&gt;&#xA;&lt;p&gt;&lt;img src=&#34;https://runzblog.oss-cn-hangzhou.aliyuncs.com/postimg/202501031720816.png&#34; alt=&#34;&#34;&gt;&lt;/p&gt;</description>
    </item>
    <item>
      <title>03-模糊测试</title>
      <link>https://huoxj.github.io/posts/%E8%BD%AF%E4%BB%B6%E6%B5%8B%E8%AF%95/03-%E6%A8%A1%E7%B3%8A%E6%B5%8B%E8%AF%95/</link>
      <pubDate>Fri, 03 Jan 2025 00:00:00 +0000</pubDate>
      <guid>https://huoxj.github.io/posts/%E8%BD%AF%E4%BB%B6%E6%B5%8B%E8%AF%95/03-%E6%A8%A1%E7%B3%8A%E6%B5%8B%E8%AF%95/</guid>
      <description></description>
    </item>
    <item>
      <title>04-测试用例优先级</title>
      <link>https://huoxj.github.io/posts/%E8%BD%AF%E4%BB%B6%E6%B5%8B%E8%AF%95/04-%E6%B5%8B%E8%AF%95%E7%94%A8%E4%BE%8B%E4%BC%98%E5%85%88%E7%BA%A7/</link>
      <pubDate>Fri, 03 Jan 2025 00:00:00 +0000</pubDate>
      <guid>https://huoxj.github.io/posts/%E8%BD%AF%E4%BB%B6%E6%B5%8B%E8%AF%95/04-%E6%B5%8B%E8%AF%95%E7%94%A8%E4%BE%8B%E4%BC%98%E5%85%88%E7%BA%A7/</guid>
      <description>&lt;h2 id=&#34;回归测试&#34;&gt;回归测试&lt;/h2&gt;&#xA;&lt;p&gt;测试用例优先级是解决回归测试的一些问题的。&lt;/p&gt;&#xA;&lt;p&gt;&lt;strong&gt;回归测试&lt;/strong&gt;：版本迭代之后，重新运行之前的测试用例&lt;/p&gt;&#xA;&lt;p&gt;但是，之前的测试用例：&lt;/p&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;用例庞大。太多了&lt;/li&gt;&#xA;&lt;li&gt;用例冗余&lt;/li&gt;&#xA;&lt;li&gt;用例失效。更新之后某些接口发生改变，原来的测试没法测&lt;/li&gt;&#xA;&lt;li&gt;用例缺失。新的模块需要新用例&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;h2 id=&#34;优化回归测试&#34;&gt;优化回归测试&lt;/h2&gt;&#xA;&lt;p&gt;要优化回归测试，就要优化测试用例集合。有如下方法&lt;/p&gt;&#xA;&lt;ol&gt;&#xA;&lt;li&gt;修复&lt;/li&gt;&#xA;&lt;li&gt;选择⭐&lt;/li&gt;&#xA;&lt;li&gt;扩充&lt;/li&gt;&#xA;&lt;li&gt;缩减&lt;/li&gt;&#xA;&lt;li&gt;优先级⭐&lt;/li&gt;&#xA;&lt;/ol&gt;&#xA;&lt;h2 id=&#34;测试用例优先级-tcp&#34;&gt;测试用例优先级 TCP&lt;/h2&gt;&#xA;&lt;p&gt;依照某种策略，给测试用例赋予&lt;strong&gt;优先级&lt;/strong&gt;。优先级高的用例先执行。&lt;/p&gt;&#xA;&lt;p&gt;即给定一堆测试用例，我们要确定一个用例序列，然后按顺序执行这些测试用例。&lt;/p&gt;&#xA;&lt;p&gt;好处：提高测试用例集的故障检测率&lt;/p&gt;&#xA;&lt;h3 id=&#34;流程&#34;&gt;流程⭐&lt;/h3&gt;&#xA;&lt;ol&gt;&#xA;&lt;li&gt;特征提取。对特使用例进行特征表示&#xA;&lt;ul&gt;&#xA;&lt;li&gt;代码覆盖：语句、分支、函数&lt;/li&gt;&#xA;&lt;li&gt;基于文本特征&lt;/li&gt;&#xA;&lt;li&gt;基于缺陷特征&lt;/li&gt;&#xA;&lt;li&gt;基于模型特征&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;基于 TCP 策略排序&#xA;&lt;ul&gt;&#xA;&lt;li&gt;贪心&lt;/li&gt;&#xA;&lt;li&gt;相似性&lt;/li&gt;&#xA;&lt;li&gt;搜索&lt;/li&gt;&#xA;&lt;li&gt;机器学习&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;评估准则&#xA;&lt;ul&gt;&#xA;&lt;li&gt;错误检测率&lt;/li&gt;&#xA;&lt;li&gt;时间开销&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;/ol&gt;&#xA;&lt;h3 id=&#34;类型&#34;&gt;类型&lt;/h3&gt;&#xA;&lt;p&gt;通用测试用例优先级：版本越新，用例优先级越高&#xA;特定于版本的测试用例优先级：根据不同版本的特性分配优先级。爱怎么分怎么分。&lt;/p&gt;&#xA;&lt;h3 id=&#34;优先级策略&#34;&gt;⭐优先级策略&lt;/h3&gt;&#xA;&lt;h4 id=&#34;基于贪心的-tcp&#34;&gt;基于贪心的 TCP&lt;/h4&gt;&#xA;&lt;blockquote&gt;&#xA;&lt;p&gt;基本是必考吧&lt;/p&gt;&#xA;&lt;/blockquote&gt;&#xA;&lt;p&gt;贪心的对象一般来说是测试用例代码单元&lt;strong&gt;覆盖率&lt;/strong&gt;。至于代码单元，有时候是语句，有时候是分支。&lt;/p&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;全局贪心：每一轮都选覆盖最多代码单元的测试用例&lt;/li&gt;&#xA;&lt;li&gt;增量贪心：每一轮选覆盖了最多的&lt;strong&gt;当前还未覆盖的&lt;/strong&gt;代码单元的测试用例&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;p&gt;每一轮中，覆盖率相同的用例，随机选择。&lt;/p&gt;&#xA;&lt;p&gt;&lt;img src=&#34;https://runzblog.oss-cn-hangzhou.aliyuncs.com/postimg/202501031609361.png&#34; alt=&#34;&#34;&gt;&lt;/p&gt;&#xA;&lt;h4 id=&#34;基于相似性的-tcp&#34;&gt;基于相似性的 TCP&lt;/h4&gt;&#xA;&lt;blockquote&gt;&#xA;&lt;p&gt;每轮优先与已选择测试用例集差异性最大的测试用例。让测试用例均匀地分布在输入域中。&lt;/p&gt;&#xA;&lt;/blockquote&gt;&#xA;&lt;p&gt;定义两个用例 $t_1, t_2$ 间的距离：&lt;/p&gt;&#xA;&lt;p&gt;$$&#xA;Jaccard(t_1,t_2)=1-\frac{|U(t_1)\cap U(t_2)|}{|U(t_1)\cup U(t_2)|}&#xA;$$&lt;/p&gt;&#xA;&lt;p&gt;就是两个用例覆盖代码的&lt;strong&gt;交并比&lt;/strong&gt;。&lt;/p&gt;&#xA;&lt;p&gt;而一个用例到用例集的距离，分别使用最大距离、最小距离和平均距离&lt;/p&gt;&#xA;&lt;h4 id=&#34;基于搜索的-tcp&#34;&gt;基于搜索的 TCP&lt;/h4&gt;&#xA;&lt;blockquote&gt;&#xA;&lt;p&gt;探索用例优先级排序组合的状态空间，以此找到检测错误更快的用例序列。&lt;/p&gt;&#xA;&lt;/blockquote&gt;&#xA;&lt;p&gt;这个方法使用了&lt;strong&gt;遗传&lt;/strong&gt;的思想。&lt;/p&gt;&#xA;&lt;ol&gt;&#xA;&lt;li&gt;种群构造。每一个个体是一个测试用例序列，比如我们随机生成两个个体：&lt;/li&gt;&#xA;&lt;/ol&gt;&#xA;&lt;p&gt;表中的 1 ~ 6 是测试用例在个体中的顺序编号。&lt;/p&gt;</description>
    </item>
    <item>
      <title>05-测试预言问题</title>
      <link>https://huoxj.github.io/posts/%E8%BD%AF%E4%BB%B6%E6%B5%8B%E8%AF%95/05-%E6%B5%8B%E8%AF%95%E9%A2%84%E8%A8%80%E9%97%AE%E9%A2%98/</link>
      <pubDate>Fri, 03 Jan 2025 00:00:00 +0000</pubDate>
      <guid>https://huoxj.github.io/posts/%E8%BD%AF%E4%BB%B6%E6%B5%8B%E8%AF%95/05-%E6%B5%8B%E8%AF%95%E9%A2%84%E8%A8%80%E9%97%AE%E9%A2%98/</guid>
      <description>&lt;p&gt;测试预言，是一个描述输出与预期是否相符的概念。&lt;/p&gt;&#xA;&lt;p&gt;预言有啥问题了？&lt;strong&gt;复杂的预言难以构建，容易构建的预言效果差&lt;/strong&gt;。&lt;/p&gt;&#xA;&lt;p&gt;解决方案，有一种叫使用不完全/有偏测试预言。也看不懂什么意思，反正就是来引出下面的蜕变测试和差分测试的。&lt;/p&gt;&#xA;&lt;h2 id=&#34;蜕变测试&#34;&gt;蜕变测试&lt;/h2&gt;&#xA;&lt;h3 id=&#34;动机&#34;&gt;动机&lt;/h3&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;可靠测试集问题（测试的生成与扩增）&lt;/li&gt;&#xA;&lt;li&gt;预言问题 （正确性验证）&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;h3 id=&#34;假设&#34;&gt;假设&lt;/h3&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;不能通过成功测试用例排除程序存在缺陷的可能&lt;/li&gt;&#xA;&lt;li&gt;利用多个相关的成功测试用例所展现出的测试输入和预期输出之间的关系来协助后续测试&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;h3 id=&#34;本质&#34;&gt;本质&lt;/h3&gt;&#xA;&lt;p&gt;充分利用成功测试用例。对成功测试用例表现出的&lt;strong&gt;必要属性&lt;/strong&gt;进行复用。&lt;/p&gt;&#xA;&lt;h3 id=&#34;要素&#34;&gt;要素&lt;/h3&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;蜕变关系（MR, Metamorphic Relation）：一组待测算法/功能的必要属性，蜕变测试的核心&lt;/li&gt;&#xA;&lt;li&gt;蜕变集合（Metamorphic Group）：由表达了蜕变关系的一组测试输入组成的集合&lt;/li&gt;&#xA;&lt;li&gt;蜕变测试过程：应用蜕变关系和蜕变集合进行测试的一般流程&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;h2 id=&#34;差分测试&#34;&gt;差分测试&lt;/h2&gt;&#xA;&lt;h3 id=&#34;定义&#34;&gt;定义&lt;/h3&gt;&#xA;&lt;p&gt;利用相似/竞品软件系统进行测试&lt;/p&gt;&#xA;&lt;p&gt;通过向一系列&lt;strong&gt;类似&lt;/strong&gt;的应用程序 （或同一应用程序的不同实现）提供&lt;strong&gt;相同的输入&lt;/strong&gt;，根据这些相似程序执行结果&lt;strong&gt;是否存在差异&lt;/strong&gt;来判定是否&lt;strong&gt;检测到缺陷&lt;/strong&gt;。&lt;/p&gt;</description>
    </item>
    <item>
      <title>06-移动应用自动化 GUI 测试</title>
      <link>https://huoxj.github.io/posts/%E8%BD%AF%E4%BB%B6%E6%B5%8B%E8%AF%95/06-%E7%A7%BB%E5%8A%A8%E5%BA%94%E7%94%A8%E8%87%AA%E5%8A%A8%E5%8C%96-gui-%E6%B5%8B%E8%AF%95/</link>
      <pubDate>Fri, 03 Jan 2025 00:00:00 +0000</pubDate>
      <guid>https://huoxj.github.io/posts/%E8%BD%AF%E4%BB%B6%E6%B5%8B%E8%AF%95/06-%E7%A7%BB%E5%8A%A8%E5%BA%94%E7%94%A8%E8%87%AA%E5%8A%A8%E5%8C%96-gui-%E6%B5%8B%E8%AF%95/</guid>
      <description>&lt;h2 id=&#34;测试脚本&#34;&gt;测试脚本&lt;/h2&gt;&#xA;&lt;p&gt;传统的脚本驱动的自动化 GUI 测试。代表工具是 &lt;code&gt;selenium&lt;/code&gt; 和 &lt;code&gt;appium&lt;/code&gt;&lt;/p&gt;&#xA;&lt;h3 id=&#34;存在的问题&#34;&gt;存在的问题&lt;/h3&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;脚本执行&lt;strong&gt;依赖&lt;/strong&gt; OS 接口&lt;/li&gt;&#xA;&lt;li&gt;定位控件&lt;strong&gt;依赖&lt;/strong&gt;移动应用的 UI 层&lt;/li&gt;&#xA;&lt;li&gt;人工编写脚本开销大，&lt;strong&gt;成本高&lt;/strong&gt;&lt;/li&gt;&#xA;&lt;li&gt;脚本随应用迭代，可&lt;strong&gt;维护性不强&lt;/strong&gt;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;p&gt;即便是基于简单的图像匹配，还是存在依赖、适配、成本的问题。&lt;/p&gt;&#xA;&lt;h2 id=&#34;基于图像理解&#34;&gt;基于图像理解⭐&lt;/h2&gt;&#xA;&lt;p&gt;挑战⭐：&lt;/p&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;移动应用碎片化问题=&amp;gt;测试难度大&lt;/li&gt;&#xA;&lt;li&gt;页面包含动态内容=&amp;gt;相似控件难识别&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;p&gt;解决⭐：基于图像理解技术，录制和回放跨平台的测试脚本&lt;/p&gt;&#xA;&lt;p&gt;步骤⭐：&lt;/p&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;GUI 测试脚本录制&#xA;&lt;ul&gt;&#xA;&lt;li&gt;基于坐标&lt;/li&gt;&#xA;&lt;li&gt;基于控件树&lt;/li&gt;&#xA;&lt;li&gt;基于图像&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;GUI 脚本回放&#xA;&lt;ul&gt;&#xA;&lt;li&gt;图像特征比对&lt;/li&gt;&#xA;&lt;li&gt;布局刻画&lt;/li&gt;&#xA;&lt;li&gt;坐标校正&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;p&gt;局限性：&lt;/p&gt;&#xA;&lt;ol&gt;&#xA;&lt;li&gt;无法感知异形屏幕对 UI 控件的遮挡&lt;/li&gt;&#xA;&lt;li&gt;难以模拟真实场景下人的交互操作&lt;/li&gt;&#xA;&lt;li&gt;仍依赖操作系统接口执行测试操作&lt;/li&gt;&#xA;&lt;/ol&gt;</description>
    </item>
    <item>
      <title>08-移动应用众包测试</title>
      <link>https://huoxj.github.io/posts/%E8%BD%AF%E4%BB%B6%E6%B5%8B%E8%AF%95/08-%E7%A7%BB%E5%8A%A8%E5%BA%94%E7%94%A8%E4%BC%97%E5%8C%85%E6%B5%8B%E8%AF%95/</link>
      <pubDate>Fri, 03 Jan 2025 00:00:00 +0000</pubDate>
      <guid>https://huoxj.github.io/posts/%E8%BD%AF%E4%BB%B6%E6%B5%8B%E8%AF%95/08-%E7%A7%BB%E5%8A%A8%E5%BA%94%E7%94%A8%E4%BC%97%E5%8C%85%E6%B5%8B%E8%AF%95/</guid>
      <description>&lt;p&gt;跳过了 07-Web 测试，因为不考。&lt;/p&gt;&#xA;&lt;h2 id=&#34;概念&#34;&gt;概念&lt;/h2&gt;&#xA;&lt;p&gt;众包：利用群体力量来完成传统方法中成本高昂或耗时的大规模任务&lt;/p&gt;&#xA;&lt;p&gt;&lt;strong&gt;众包测试&lt;/strong&gt;：利用群体力量完成移动应用测试任务&lt;/p&gt;&#xA;&lt;h2 id=&#34;流程&#34;&gt;流程&lt;/h2&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;&lt;strong&gt;申请上传&lt;/strong&gt;：用户上传自己要测的应用到众测平台，指定测试任务等信息&lt;/li&gt;&#xA;&lt;li&gt;&lt;strong&gt;任务选择和环境设置&lt;/strong&gt;：众测人员选择任务，配置环境&lt;/li&gt;&#xA;&lt;li&gt;&lt;strong&gt;提交报告&lt;/strong&gt;：众测人员测试，并提交缺陷报告&lt;/li&gt;&#xA;&lt;li&gt;&lt;strong&gt;生成最终测试报告&lt;/strong&gt;：平台收集补充信息，生成最终的缺陷报告&lt;/li&gt;&#xA;&lt;li&gt;&lt;strong&gt;报告验证&lt;/strong&gt;：验证报告，并发酬劳&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;h2 id=&#34;挑战&#34;&gt;挑战⭐&lt;/h2&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;任务分配&lt;/li&gt;&#xA;&lt;li&gt;任务奖励&lt;/li&gt;&#xA;&lt;li&gt;众测过程引导&lt;/li&gt;&#xA;&lt;li&gt;测试报告质量控制&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;h2 id=&#34;机制&#34;&gt;机制⭐&lt;/h2&gt;&#xA;&lt;h3 id=&#34;众测报告聚合&#34;&gt;众测报告聚合&lt;/h3&gt;&#xA;&lt;p&gt;Aggregator：将报告做聚类。&lt;/p&gt;&#xA;&lt;p&gt;Summarizer：一个类汇总，总结并报告给开发者&lt;/p&gt;&#xA;&lt;h3 id=&#34;众测报告排序&#34;&gt;众测报告排序&lt;/h3&gt;&#xA;&lt;p&gt;报告排序原则：bug 越早发现，修复成本更低&lt;/p&gt;&#xA;&lt;p&gt;方法：文本+图片结合分析的方法&lt;/p&gt;&#xA;&lt;p&gt;当前研究的局限：&lt;/p&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;主要着眼于文本的分析理解&lt;/li&gt;&#xA;&lt;li&gt;仅引入简单的截图分析以辅助文本&lt;/li&gt;&#xA;&lt;li&gt;简单地将文本与图片拼接起来进行分析&lt;/li&gt;&#xA;&lt;/ul&gt;</description>
    </item>
    <item>
      <title>Lec-10 人机交互系统基础知识</title>
      <link>https://huoxj.github.io/posts/%E4%BA%BA%E6%9C%BA%E4%BA%A4%E4%BA%92/lec-10-%E4%BA%BA%E6%9C%BA%E4%BA%A4%E4%BA%92%E7%B3%BB%E7%BB%9F%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/</link>
      <pubDate>Wed, 01 Jan 2025 00:00:00 +0000</pubDate>
      <guid>https://huoxj.github.io/posts/%E4%BA%BA%E6%9C%BA%E4%BA%A4%E4%BA%92/lec-10-%E4%BA%BA%E6%9C%BA%E4%BA%A4%E4%BA%92%E7%B3%BB%E7%BB%9F%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/</guid>
      <description>&lt;blockquote&gt;&#xA;&lt;p&gt;本来是教材前面二三章的内容，今年放在后面讲了&lt;/p&gt;&#xA;&lt;/blockquote&gt;&#xA;&lt;h2 id=&#34;信息处理模型&#34;&gt;信息处理模型&lt;/h2&gt;&#xA;&lt;p&gt;研究人对外界&lt;strong&gt;信息&lt;/strong&gt;的接收、存储、集成、检索和使用。&lt;/p&gt;&#xA;&lt;p&gt;预测人执行特定任务的效率。&lt;/p&gt;&#xA;&lt;h3 id=&#34;信息处理机&#34;&gt;信息处理机&lt;/h3&gt;&#xA;&lt;p&gt;&lt;img src=&#34;https://runzblog.oss-cn-hangzhou.aliyuncs.com/postimg/202501011334614.png&#34; alt=&#34;&#34;&gt;&lt;/p&gt;&#xA;&lt;p&gt;没有考虑到注意和记忆的重要性&lt;/p&gt;&#xA;&lt;h3 id=&#34;扩展的信息处理机模型&#34;&gt;扩展的信息处理机模型&lt;/h3&gt;&#xA;&lt;p&gt;&lt;img src=&#34;https://runzblog.oss-cn-hangzhou.aliyuncs.com/postimg/202501011334097.png&#34; alt=&#34;&#34;&gt;&lt;/p&gt;&#xA;&lt;p&gt;也就是加了注意力和记忆的信息处理机模型。&lt;/p&gt;&#xA;&lt;h3 id=&#34;人类处理机模型&#34;&gt;⭐人类处理机模型&lt;/h3&gt;&#xA;&lt;p&gt;最著名的信息处理模型。&lt;/p&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;感知处理器&#xA;&lt;ul&gt;&#xA;&lt;li&gt;接受外界信息，输出到声音存储和视觉存储区域&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;认知处理器&#xA;&lt;ul&gt;&#xA;&lt;li&gt;根据&lt;strong&gt;工作记忆&lt;/strong&gt;与&lt;strong&gt;长期记忆&lt;/strong&gt;，对&lt;strong&gt;输入&lt;/strong&gt;进行处理，得到&lt;strong&gt;输出&lt;/strong&gt;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;动作处理器&#xA;&lt;ul&gt;&#xA;&lt;li&gt;根据&lt;strong&gt;输出&lt;/strong&gt;，执行对应任务&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;p&gt;&lt;img src=&#34;https://runzblog.oss-cn-hangzhou.aliyuncs.com/postimg/202501011338020.png&#34; alt=&#34;&#34;&gt;&lt;/p&gt;&#xA;&lt;h2 id=&#34;格式塔心理学&#34;&gt;⭐格式塔心理学&lt;/h2&gt;&#xA;&lt;p&gt;研究人是如何感知一个良好组织的模式的，而不是将其视为一系列相互独立的部分。&lt;/p&gt;&#xA;&lt;p&gt;事物的整体区别于部分的组合。&lt;/p&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;相近性原则&lt;/li&gt;&#xA;&lt;li&gt;相似性原则&lt;/li&gt;&#xA;&lt;li&gt;连续性原则&lt;/li&gt;&#xA;&lt;li&gt;对称性原则&lt;/li&gt;&#xA;&lt;li&gt;完整性和闭合性原则&lt;/li&gt;&#xA;&lt;li&gt;前景和背景&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;h2 id=&#34;人脑记忆结构&#34;&gt;⭐人脑记忆结构&lt;/h2&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;&lt;strong&gt;感觉记忆&lt;/strong&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;瞬时记忆&lt;/li&gt;&#xA;&lt;li&gt;持续 1 秒&lt;/li&gt;&#xA;&lt;li&gt;能够让一组图片组合成一个动态影像序列&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;&lt;strong&gt;短时记忆&lt;/strong&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;感觉记忆编码而成&lt;/li&gt;&#xA;&lt;li&gt;持续 30 秒&lt;/li&gt;&#xA;&lt;li&gt;储存当前正在使用的信息&lt;/li&gt;&#xA;&lt;li&gt;储存能力 7 ± 2 个单元&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;&lt;strong&gt;长时记忆&lt;/strong&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;短时记忆加工而来，并且只有与长时记忆相关的短时记忆才能进入长时记忆&lt;/li&gt;&#xA;&lt;li&gt;容量无限、持续时间长&lt;/li&gt;&#xA;&lt;li&gt;遗忘不代表消失，能快速恢复&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;h2 id=&#34;界面类型&#34;&gt;⭐界面类型&lt;/h2&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;命令行界面&lt;/li&gt;&#xA;&lt;li&gt;图形用户界面&lt;/li&gt;&#xA;&lt;li&gt;多媒体界面&lt;/li&gt;&#xA;&lt;li&gt;信息和可视化表盘 （dashboard）&lt;/li&gt;&#xA;&lt;li&gt;VR 和 AR&lt;/li&gt;&#xA;&lt;li&gt;新兴技术：触摸交互、手势界面、实物界面、脑机界面、可穿戴计算&amp;hellip;&lt;/li&gt;&#xA;&lt;/ul&gt;</description>
    </item>
    <item>
      <title>Lec-11 交互模型与理论</title>
      <link>https://huoxj.github.io/posts/%E4%BA%BA%E6%9C%BA%E4%BA%A4%E4%BA%92/lec-11-%E4%BA%A4%E4%BA%92%E6%A8%A1%E5%9E%8B%E4%B8%8E%E7%90%86%E8%AE%BA/</link>
      <pubDate>Wed, 01 Jan 2025 00:00:00 +0000</pubDate>
      <guid>https://huoxj.github.io/posts/%E4%BA%BA%E6%9C%BA%E4%BA%A4%E4%BA%92/lec-11-%E4%BA%A4%E4%BA%92%E6%A8%A1%E5%9E%8B%E4%B8%8E%E7%90%86%E8%AE%BA/</guid>
      <description>&lt;p&gt;这一节主要讲了&lt;strong&gt;预测模型&lt;/strong&gt;，通过这些模型，可以在不对用户做测试的条件下预测用户的执行情况。&lt;/p&gt;&#xA;&lt;h2 id=&#34;goms-模型&#34;&gt;GOMS 模型&lt;/h2&gt;&#xA;&lt;blockquote&gt;&#xA;&lt;p&gt;可能会考概念&lt;/p&gt;&#xA;&lt;/blockquote&gt;&#xA;&lt;p&gt;最著名的预测模型。&lt;/p&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;基于人类处理机模型&lt;/li&gt;&#xA;&lt;li&gt;采用&lt;strong&gt;分而治之&lt;/strong&gt;的思想，将一个任务进行多层次的细化，然后把每个操作的时间&lt;strong&gt;相加&lt;/strong&gt;就可以得到一项任务的时间&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;p&gt;全称：&lt;/p&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;Goal：用户要达到的目的&lt;/li&gt;&#xA;&lt;li&gt;Operator：任务执行的底层行为，无法分解&lt;/li&gt;&#xA;&lt;li&gt;Method：如何完成目标的过程，即对应目标的子目标序列和所需操作&lt;/li&gt;&#xA;&lt;li&gt;Selection：确定当有多种方法时选择方法&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;p&gt;&lt;img src=&#34;https://runzblog.oss-cn-hangzhou.aliyuncs.com/postimg/202501011403155.png&#34; alt=&#34;&#34;&gt;&lt;/p&gt;&#xA;&lt;p&gt;优点&lt;/p&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;能够容易地对不同的界面或系统进行比较分析&#xA;局限性&lt;/li&gt;&#xA;&lt;li&gt;假设用户只按一种正确的方式进行人机交互，没有清楚地描述错误处理的过程，只针对那些不犯任何错误的专家用户&lt;/li&gt;&#xA;&lt;li&gt;任务之间的关系描述过于简单&lt;/li&gt;&#xA;&lt;li&gt;忽略了用户间的个体差异&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;h2 id=&#34;击键层次模型&#34;&gt;⭐击键层次模型&lt;/h2&gt;&#xA;&lt;p&gt;简化版本的 GOMS，对用户执行情况进行量化&lt;strong&gt;预测&lt;/strong&gt;。&lt;/p&gt;&#xA;&lt;h3 id=&#34;用途&#34;&gt;用途&lt;/h3&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;预测&lt;strong&gt;无错误情况&lt;/strong&gt;下专家用户在下列输入前提下完成任务的时间&lt;/li&gt;&#xA;&lt;li&gt;便于&lt;strong&gt;比较&lt;/strong&gt;不同系统&lt;/li&gt;&#xA;&lt;li&gt;&lt;strong&gt;确定何种方案&lt;/strong&gt;能最有效地支持特定任务&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;h3 id=&#34;操作符&#34;&gt;操作符&lt;/h3&gt;&#xA;&lt;p&gt;用一系列操作符，描述用户执行任务的序列与时间：&lt;/p&gt;&#xA;&lt;table&gt;&#xA;  &lt;thead&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;th style=&#34;text-align: left&#34;&gt;操作符&lt;/th&gt;&#xA;          &lt;th style=&#34;text-align: left&#34;&gt;描述&lt;/th&gt;&#xA;          &lt;th style=&#34;text-align: left&#34;&gt;备注&lt;/th&gt;&#xA;      &lt;/tr&gt;&#xA;  &lt;/thead&gt;&#xA;  &lt;tbody&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;td style=&#34;text-align: left&#34;&gt;$K[keyname]$&lt;/td&gt;&#xA;          &lt;td style=&#34;text-align: left&#34;&gt;在键盘上按下 keyname 按键&lt;/td&gt;&#xA;          &lt;td style=&#34;text-align: left&#34;&gt;不同按键按下的时间不一样&lt;/td&gt;&#xA;      &lt;/tr&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;td style=&#34;text-align: left&#34;&gt;$P[pos]$&lt;/td&gt;&#xA;          &lt;td style=&#34;text-align: left&#34;&gt;用鼠标等设备，将光标移动到 pos 对应的位置&lt;/td&gt;&#xA;          &lt;td style=&#34;text-align: left&#34;&gt;&lt;/td&gt;&#xA;      &lt;/tr&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;td style=&#34;text-align: left&#34;&gt;$P_1$&lt;/td&gt;&#xA;          &lt;td style=&#34;text-align: left&#34;&gt;点击鼠标等设备&lt;/td&gt;&#xA;          &lt;td style=&#34;text-align: left&#34;&gt;&lt;/td&gt;&#xA;      &lt;/tr&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;td style=&#34;text-align: left&#34;&gt;$H[mouse / keyboard]$&lt;/td&gt;&#xA;          &lt;td style=&#34;text-align: left&#34;&gt;将手放到鼠标或者键盘上&lt;/td&gt;&#xA;          &lt;td style=&#34;text-align: left&#34;&gt;&lt;/td&gt;&#xA;      &lt;/tr&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;td style=&#34;text-align: left&#34;&gt;$D$&lt;/td&gt;&#xA;          &lt;td style=&#34;text-align: left&#34;&gt;用鼠标画线&lt;/td&gt;&#xA;          &lt;td style=&#34;text-align: left&#34;&gt;&lt;/td&gt;&#xA;      &lt;/tr&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;td style=&#34;text-align: left&#34;&gt;$M$&lt;/td&gt;&#xA;          &lt;td style=&#34;text-align: left&#34;&gt;用户思维过程、心理准备&lt;/td&gt;&#xA;          &lt;td style=&#34;text-align: left&#34;&gt;比如做决定。&lt;/td&gt;&#xA;      &lt;/tr&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;td style=&#34;text-align: left&#34;&gt;$R(t)$&lt;/td&gt;&#xA;          &lt;td style=&#34;text-align: left&#34;&gt;用户等待系统 t 时间&lt;/td&gt;&#xA;          &lt;td style=&#34;text-align: left&#34;&gt;&lt;/td&gt;&#xA;      &lt;/tr&gt;&#xA;  &lt;/tbody&gt;&#xA;&lt;/table&gt;&#xA;&lt;h3 id=&#34;例子&#34;&gt;例子&lt;/h3&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;Dos 环境下执行 ipconfig 命令：&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;M K[i] K[p] K[c] K[o] K[n] K[f] K[i] K[g] K[Enter]&#xA;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;$T_{execute}=T_M+9\times T_K$&lt;/p&gt;</description>
    </item>
    <item>
      <title>Lec-12 以用户为中心</title>
      <link>https://huoxj.github.io/posts/%E4%BA%BA%E6%9C%BA%E4%BA%A4%E4%BA%92/lec-12-%E4%BB%A5%E7%94%A8%E6%88%B7%E4%B8%BA%E4%B8%AD%E5%BF%83/</link>
      <pubDate>Wed, 01 Jan 2025 00:00:00 +0000</pubDate>
      <guid>https://huoxj.github.io/posts/%E4%BA%BA%E6%9C%BA%E4%BA%A4%E4%BA%92/lec-12-%E4%BB%A5%E7%94%A8%E6%88%B7%E4%B8%BA%E4%B8%AD%E5%BF%83/</guid>
      <description>&lt;p&gt;这一节主要是理解，内容不多&lt;/p&gt;&#xA;&lt;h2 id=&#34;ucd-原则&#34;&gt;UCD 原则&lt;/h2&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;及早以用户为中心&lt;/li&gt;&#xA;&lt;li&gt;综合设计&lt;/li&gt;&#xA;&lt;li&gt;及早并持续性地进行测试&lt;/li&gt;&#xA;&lt;li&gt;迭代设计&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;h2 id=&#34;ucd-方法&#34;&gt;UCD 方法&lt;/h2&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;用户参与&lt;/li&gt;&#xA;&lt;li&gt;焦点小组&lt;/li&gt;&#xA;&lt;li&gt;问卷调查&lt;/li&gt;&#xA;&lt;li&gt;民族志观察&lt;/li&gt;&#xA;&lt;li&gt;走查&lt;/li&gt;&#xA;&lt;li&gt;专家评估&lt;/li&gt;&#xA;&lt;li&gt;可用性测试&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;h2 id=&#34;理解用户工作&#34;&gt;理解用户工作&lt;/h2&gt;&#xA;&lt;p&gt;使用&lt;strong&gt;上下文询问法&lt;/strong&gt;（情景调查）了解用户。&lt;/p&gt;&#xA;&lt;p&gt;观察并与用户交流会比仅仅观察的效果要好&lt;/p&gt;&#xA;&lt;p&gt;四个原则：&lt;/p&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;上下文环境&lt;/li&gt;&#xA;&lt;li&gt;伙伴关系&lt;/li&gt;&#xA;&lt;li&gt;解释&lt;/li&gt;&#xA;&lt;li&gt;焦点&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;p&gt;相比于民族志观察，上下文询问法&lt;/p&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;过程更简短&lt;/li&gt;&#xA;&lt;li&gt;重点更为明确、集中&lt;/li&gt;&#xA;&lt;li&gt;设计人员只询问，不参与&lt;/li&gt;&#xA;&lt;li&gt;目的明确&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;h2 id=&#34;以活动为中心&#34;&gt;以活动为中心&lt;/h2&gt;&#xA;&lt;p&gt;以用户为中心的方法存在一些缺陷：&lt;/p&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;影响产品的创新性&lt;/li&gt;&#xA;&lt;li&gt;可操作性受到时间、预算和任务规模的限制&lt;/li&gt;&#xA;&lt;li&gt;忽视了人的主观能动性和对技术的适应能力&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;p&gt;所以推出以活动为中心的思想：&lt;/p&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;把用户要做的“事”（活动）作为重点关注的对象&lt;/li&gt;&#xA;&lt;li&gt;更适合于复杂的设计项目&lt;/li&gt;&#xA;&lt;/ul&gt;</description>
    </item>
    <item>
      <title>Lec-9 交互式系统的设计</title>
      <link>https://huoxj.github.io/posts/%E4%BA%BA%E6%9C%BA%E4%BA%A4%E4%BA%92/lec-9-%E4%BA%A4%E4%BA%92%E5%BC%8F%E7%B3%BB%E7%BB%9F%E7%9A%84%E8%AE%BE%E8%AE%A1/</link>
      <pubDate>Wed, 01 Jan 2025 00:00:00 +0000</pubDate>
      <guid>https://huoxj.github.io/posts/%E4%BA%BA%E6%9C%BA%E4%BA%A4%E4%BA%92/lec-9-%E4%BA%A4%E4%BA%92%E5%BC%8F%E7%B3%BB%E7%BB%9F%E7%9A%84%E8%AE%BE%E8%AE%A1/</guid>
      <description>&lt;h2 id=&#34;简化设计的策略&#34;&gt;⭐简化设计的策略&lt;/h2&gt;&#xA;&lt;p&gt;四个策略：删除、组织、隐藏、转移&lt;/p&gt;&#xA;&lt;h3 id=&#34;删除&#34;&gt;删除&lt;/h3&gt;&#xA;&lt;p&gt;最明显的简化设计方法&lt;/p&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;删除杂乱的特性&#xA;&lt;ul&gt;&#xA;&lt;li&gt;保留核心功能&lt;/li&gt;&#xA;&lt;li&gt;砍掉残缺功能&lt;/li&gt;&#xA;&lt;li&gt;砍掉可能不会经常使用的功能&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;具体怎么删、删什么，还可以根据启发式规则来判断&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;h3 id=&#34;组织&#34;&gt;组织&lt;/h3&gt;&#xA;&lt;p&gt;最快捷的简化设计方式&lt;/p&gt;&#xA;&lt;p&gt;参考&lt;strong&gt;格式塔心理学&lt;/strong&gt;就行啦。&lt;/p&gt;&#xA;&lt;h3 id=&#34;隐藏&#34;&gt;隐藏&lt;/h3&gt;&#xA;&lt;p&gt;隐藏是一种低成本的简化方案&lt;/p&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;主流用户很少使用，但自身需要更新的功能&lt;/li&gt;&#xA;&lt;li&gt;事关细节（对服务器进行配置或设计邮件签名）&lt;/li&gt;&#xA;&lt;li&gt;选项和偏好（修改绘图应用的单位）&lt;/li&gt;&#xA;&lt;li&gt;特定于地区的信息（如时间和日期需频繁自动更新的信息）&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;h3 id=&#34;转移&#34;&gt;转移&lt;/h3&gt;&#xA;&lt;p&gt;将某些功能转移到其他地方，&lt;strong&gt;合理分配职责&lt;/strong&gt;。&lt;/p&gt;&#xA;&lt;p&gt;原则是，哪一方擅长什么，就将对应功能转移过去。&lt;/p&gt;&#xA;&lt;h2 id=&#34;卡片分类法&#34;&gt;⭐卡片分类法&lt;/h2&gt;&#xA;&lt;p&gt;解决如何让用户找到他们需要的信息。&lt;/p&gt;&#xA;&lt;p&gt;实验中，参与者需要对事物进行分类&lt;/p&gt;&#xA;&lt;p&gt;主要被用作导航研究：&lt;/p&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;卡片上可以写上&lt;strong&gt;任何可能出现在页面或应用菜单上的内容&lt;/strong&gt;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;p&gt;也可以用于布局研究&lt;/p&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;写上界面元素（或数据项）等&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;p&gt;卡片分类法中的&lt;strong&gt;分组名称&lt;/strong&gt;可以是&lt;strong&gt;用户自己定义的&lt;/strong&gt;，也可以是&lt;strong&gt;研究者预先定义的&lt;/strong&gt;。&lt;/p&gt;&#xA;&lt;p&gt;在研究过程中，用户可以自由地将卡片分组，也可以自由地将卡片从一个组中移动到另一个组中。研究者可以记录用户的行为，以便后续分析。&lt;/p&gt;&#xA;&lt;p&gt;需要注意的是，分组名称应当避免抽象、包罗万象的名称，且最终的组名之间不应有重叠。&lt;/p&gt;</description>
    </item>
    <item>
      <title>点子王</title>
      <link>https://huoxj.github.io/posts/%E9%9A%8F%E8%AE%B0/%E7%82%B9%E5%AD%90%E7%8E%8B/</link>
      <pubDate>Wed, 01 Jan 2025 00:00:00 +0000</pubDate>
      <guid>https://huoxj.github.io/posts/%E9%9A%8F%E8%AE%B0/%E7%82%B9%E5%AD%90%E7%8E%8B/</guid>
      <description>&lt;h3 id=&#34;基于-ethereum-的去中心化课程教师平台&#34;&gt;基于 Ethereum 的去中心化课程、教师平台。&lt;/h3&gt;&#xA;&lt;p&gt;这种去中心化技术本身不错，有研究与探索价值，也算一种拓宽视野的方式。但是对于课程、导师评价平台来说，有一点太过刻意了。通过躲避监管的方式纵容感性、片面甚至是极端的情绪输出，违背了建立平台信息共享的初衷。而理性、中肯的评价，无论褒贬，才更具参考价值。所以这个点子还是以传统的方式实现。以 github 仓库实现审查与监管。虽然不完美，但目前看来是一个比较优的解。&#xA;话又说回来，课程信息等内容才是主题，网站只是载体，要把主次分清楚。&#xA;后期有时间往平台上搬一些或者写一些经验性质的文章。先把内容丰富起来、用户发展起来，车到山前必有路，到时候根据反馈再来进行改进也不迟。&lt;/p&gt;&#xA;&lt;h3 id=&#34;ai-listener&#34;&gt;AI listener&lt;/h3&gt;&#xA;&lt;p&gt;在 b 站刷有感类视频想到的点子。对着摄像头侃侃而谈地讲话是一件挺不容易的事情。我认为原因之一是没有交流，比如上网课的老师在没有面对学生的时候上课效果往往更差。经常听说联系演讲的人对着镜子中的自己演讲，这是一种增加交流的方式。如果能在自己需要讲话时，有一个或者多个听众来给予反馈和交流该多好！&#xA;正巧，现在 AI 技术十分发达，分析讲话内容来生成听众的反馈，并以一个视频通话的形式反馈给讲话者是完全可行的。讲话的人可以根据视频中 AI 听者的反馈来调整自己的节奏，从而发挥得更加自然与流畅。&#xA;同时，这样的需求也适用于那些想要练习演讲能力，但又十分怯于在听众面前表达的人。可以先面向 AI 听众练习表达，在面向真人的演讲中也可以更加从容淡定。&#xA;AI 听众的反馈可以通过一系列 prompt 调整。&lt;/p&gt;</description>
    </item>
    <item>
      <title>异常处理</title>
      <link>https://huoxj.github.io/posts/c&#43;&#43;%E6%8B%BE%E9%81%97/%E5%BC%82%E5%B8%B8%E5%A4%84%E7%90%86/</link>
      <pubDate>Sun, 29 Dec 2024 00:00:00 +0000</pubDate>
      <guid>https://huoxj.github.io/posts/c&#43;&#43;%E6%8B%BE%E9%81%97/%E5%BC%82%E5%B8%B8%E5%A4%84%E7%90%86/</guid>
      <description>&lt;h2 id=&#34;错误&#34;&gt;错误&lt;/h2&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;语法错误：编译器解决&lt;/li&gt;&#xA;&lt;li&gt;逻辑错误：测试解决&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;h2 id=&#34;异常&#34;&gt;异常&lt;/h2&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;运行环境造成。如内存不足、文件操作失败等&lt;/li&gt;&#xA;&lt;li&gt;特征&#xA;&lt;ul&gt;&#xA;&lt;li&gt;可以预见&lt;/li&gt;&#xA;&lt;li&gt;无法避免&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;异常处理：提高程序鲁棒性&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;h2 id=&#34;异常处理方法&#34;&gt;异常处理方法&lt;/h2&gt;&#xA;&lt;p&gt;传统的方法是，使用&lt;strong&gt;函数参数&lt;/strong&gt;或者&lt;strong&gt;返回值&lt;/strong&gt;来标识是否发生异常、发生什么异常。&lt;/p&gt;&#xA;&lt;p&gt;函数&lt;strong&gt;调用者&lt;/strong&gt;检查参数或者返回值来确定异常，并&lt;strong&gt;处理异常&lt;/strong&gt;。&lt;/p&gt;&#xA;&lt;p&gt;这样需要逐层返回。并且对于一些特殊的情况无法处理，比如构造函数发生异常。&lt;/p&gt;&#xA;&lt;hr&gt;&#xA;&lt;h2 id=&#34;c-异常处理机制&#34;&gt;C++ 异常处理机制&lt;/h2&gt;&#xA;&lt;h3 id=&#34;try&#34;&gt;try&lt;/h3&gt;&#xA;&lt;p&gt;&lt;strong&gt;监控&lt;/strong&gt;语句序列中是否发生异常。&lt;/p&gt;&#xA;&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#d8dee9;background-color:#2e3440;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-cpp&#34; data-lang=&#34;cpp&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#81a1c1;font-weight:bold&#34;&gt;try&lt;/span&gt;&lt;span style=&#34;color:#eceff4&#34;&gt;{&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&#x9;statements to monitor&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#eceff4&#34;&gt;}&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;h3 id=&#34;throw&#34;&gt;throw&lt;/h3&gt;&#xA;&lt;p&gt;try 中检测到异常时，&lt;strong&gt;抛出&lt;/strong&gt;异常。&lt;/p&gt;&#xA;&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#d8dee9;background-color:#2e3440;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-cpp&#34; data-lang=&#34;cpp&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#81a1c1;font-weight:bold&#34;&gt;throw&lt;/span&gt; expression&#xA;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;h3 id=&#34;catch&#34;&gt;catch&lt;/h3&gt;&#xA;&lt;p&gt;捕获异常并处理。try 后可以跟随多个 catch 来捕获不同类型的异常。&lt;/p&gt;&#xA;&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#d8dee9;background-color:#2e3440;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-cpp&#34; data-lang=&#34;cpp&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#81a1c1;font-weight:bold&#34;&gt;catch&lt;/span&gt; &lt;span style=&#34;color:#eceff4&#34;&gt;(&lt;/span&gt;ExceptionType e&lt;span style=&#34;color:#eceff4&#34;&gt;){&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&#x9;deal with exception&lt;span style=&#34;color:#eceff4&#34;&gt;...&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#eceff4&#34;&gt;}&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;h3 id=&#34;异常处理的嵌套&#34;&gt;异常处理的嵌套&lt;/h3&gt;&#xA;&lt;p&gt;抛出的异常会在&lt;strong&gt;调用链&lt;/strong&gt;中自下往上捕获。&lt;/p&gt;&#xA;&lt;p&gt;最终还未被捕获的异常，由系统的 abort 处理。&lt;/p&gt;&#xA;&lt;p&gt;&lt;img src=&#34;https://runzblog.oss-cn-hangzhou.aliyuncs.com/postimg/202412290856374.png&#34; alt=&#34;&#34;&gt;&lt;/p&gt;&#xA;&lt;h3 id=&#34;异常类间的继承&#34;&gt;异常类间的继承&lt;/h3&gt;&#xA;&lt;p&gt;在捕获一系列有继承关系的异常类对象的时候，需要注意：&lt;/p&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;用&lt;strong&gt;引用&lt;/strong&gt;传递异常对象。&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;p&gt;即：&lt;/p&gt;&#xA;&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#d8dee9;background-color:#2e3440;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-cpp&#34; data-lang=&#34;cpp&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#81a1c1;font-weight:bold&#34;&gt;try&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#eceff4&#34;&gt;{...}&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#81a1c1;font-weight:bold&#34;&gt;catch&lt;/span&gt;&lt;span style=&#34;color:#eceff4&#34;&gt;(&lt;/span&gt;Exception1 &lt;span style=&#34;color:#81a1c1&#34;&gt;&amp;amp;&lt;/span&gt;e1&lt;span style=&#34;color:#eceff4&#34;&gt;){...}&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#81a1c1;font-weight:bold&#34;&gt;catch&lt;/span&gt;&lt;span style=&#34;color:#eceff4&#34;&gt;(&lt;/span&gt;Exception2 &lt;span style=&#34;color:#81a1c1&#34;&gt;&amp;amp;&lt;/span&gt;e2&lt;span style=&#34;color:#eceff4&#34;&gt;){...}&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;如果直接传异常对象，容易发生对象切片。&lt;/p&gt;&#xA;&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#d8dee9;background-color:#2e3440;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-cpp&#34; data-lang=&#34;cpp&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#81a1c1;font-weight:bold&#34;&gt;class&lt;/span&gt; &lt;span style=&#34;color:#8fbcbb&#34;&gt;EBase&lt;/span&gt; &lt;span style=&#34;color:#eceff4&#34;&gt;{};&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#81a1c1;font-weight:bold&#34;&gt;class&lt;/span&gt; &lt;span style=&#34;color:#8fbcbb&#34;&gt;EDerived&lt;/span&gt;&lt;span style=&#34;color:#81a1c1&#34;&gt;:&lt;/span&gt; &lt;span style=&#34;color:#81a1c1;font-weight:bold&#34;&gt;public&lt;/span&gt; EBase &lt;span style=&#34;color:#eceff4&#34;&gt;{};&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#81a1c1&#34;&gt;void&lt;/span&gt; &lt;span style=&#34;color:#88c0d0&#34;&gt;f&lt;/span&gt;&lt;span style=&#34;color:#eceff4&#34;&gt;(&lt;/span&gt;EBase e&lt;span style=&#34;color:#eceff4&#34;&gt;)&lt;/span&gt; &lt;span style=&#34;color:#eceff4&#34;&gt;{&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&#x9;&lt;span style=&#34;color:#81a1c1;font-weight:bold&#34;&gt;throw&lt;/span&gt; e&lt;span style=&#34;color:#eceff4&#34;&gt;;&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#eceff4&#34;&gt;}&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;EDerived e&lt;span style=&#34;color:#eceff4&#34;&gt;;&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#81a1c1;font-weight:bold&#34;&gt;try&lt;/span&gt; &lt;span style=&#34;color:#eceff4&#34;&gt;{&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&#x9;f&lt;span style=&#34;color:#eceff4&#34;&gt;(&lt;/span&gt;e&lt;span style=&#34;color:#eceff4&#34;&gt;);&lt;/span&gt;  &lt;span style=&#34;color:#616e87;font-style:italic&#34;&gt;// Object Slicing, throwing EBase instead of EDerived&#xA;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#616e87;font-style:italic&#34;&gt;&lt;/span&gt;&lt;span style=&#34;color:#eceff4&#34;&gt;}&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#81a1c1;font-weight:bold&#34;&gt;catch&lt;/span&gt;&lt;span style=&#34;color:#eceff4&#34;&gt;(&lt;/span&gt;EDerived e&lt;span style=&#34;color:#eceff4&#34;&gt;)&lt;/span&gt; &lt;span style=&#34;color:#eceff4&#34;&gt;{&lt;/span&gt; cout&lt;span style=&#34;color:#81a1c1&#34;&gt;&amp;lt;&amp;lt;&lt;/span&gt;&lt;span style=&#34;color:#a3be8c&#34;&gt;&amp;#34;Derived&amp;#34;&lt;/span&gt;&lt;span style=&#34;color:#eceff4&#34;&gt;;&lt;/span&gt; &lt;span style=&#34;color:#eceff4&#34;&gt;}&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#81a1c1;font-weight:bold&#34;&gt;catch&lt;/span&gt;&lt;span style=&#34;color:#eceff4&#34;&gt;(&lt;/span&gt;EBase e&lt;span style=&#34;color:#eceff4&#34;&gt;)&lt;/span&gt; &lt;span style=&#34;color:#eceff4&#34;&gt;{&lt;/span&gt; cout&lt;span style=&#34;color:#81a1c1&#34;&gt;&amp;lt;&amp;lt;&lt;/span&gt;&lt;span style=&#34;color:#a3be8c&#34;&gt;&amp;#34;Base&amp;#34;&lt;/span&gt;&lt;span style=&#34;color:#eceff4&#34;&gt;;&lt;/span&gt; &lt;span style=&#34;color:#eceff4&#34;&gt;}&lt;/span&gt;  &lt;span style=&#34;color:#616e87;font-style:italic&#34;&gt;// e caught here&#xA;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;ul&gt;&#xA;&lt;li&gt;按 “从最派生的类到最基的类” 的顺序来捕获&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;p&gt;catch 是按声明顺序捕获的。&lt;/p&gt;</description>
    </item>
    <item>
      <title>Lec-8 交互式系统的需求</title>
      <link>https://huoxj.github.io/posts/%E4%BA%BA%E6%9C%BA%E4%BA%A4%E4%BA%92/lec-8-%E4%BA%A4%E4%BA%92%E5%BC%8F%E7%B3%BB%E7%BB%9F%E7%9A%84%E9%9C%80%E6%B1%82/</link>
      <pubDate>Fri, 27 Dec 2024 00:00:00 +0000</pubDate>
      <guid>https://huoxj.github.io/posts/%E4%BA%BA%E6%9C%BA%E4%BA%A4%E4%BA%92/lec-8-%E4%BA%A4%E4%BA%92%E5%BC%8F%E7%B3%BB%E7%BB%9F%E7%9A%84%E9%9C%80%E6%B1%82/</guid>
      <description>&lt;h2 id=&#34;用户&#34;&gt;用户&lt;/h2&gt;&#xA;&lt;h3 id=&#34;用户特性&#34;&gt;用户特性&lt;/h3&gt;&#xA;&lt;p&gt;心理学原理部分，假设每个人都有相似的能力和局限性。&lt;/p&gt;&#xA;&lt;p&gt;交互产品设计人员应该意识到个性的差异。&lt;/p&gt;&#xA;&lt;p&gt;用户的&lt;strong&gt;差异&lt;/strong&gt;主要体现在：&lt;/p&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;体验水平&lt;/li&gt;&#xA;&lt;li&gt;年龄&lt;/li&gt;&#xA;&lt;li&gt;文化&lt;/li&gt;&#xA;&lt;li&gt;健康&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;h4 id=&#34;体验水平差异&#34;&gt;体验水平差异&lt;/h4&gt;&#xA;&lt;h5 id=&#34;新手用户&#34;&gt;新手用户&lt;/h5&gt;&#xA;&lt;p&gt;特点&lt;/p&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;敏感，且很容易在开始有挫折感&#xA;设计要求&lt;/li&gt;&#xA;&lt;li&gt;不能将新手状态视为目标&lt;/li&gt;&#xA;&lt;li&gt;让学习过程快速且富有针对性&lt;/li&gt;&#xA;&lt;li&gt;确保程序充分反映了用户关于任务的心智模型&lt;/li&gt;&#xA;&lt;li&gt;无论什么样的帮助，都不应该在界面中固定&lt;/li&gt;&#xA;&lt;li&gt;具有向导功能的对话框帮助较好&#xA;&lt;ul&gt;&#xA;&lt;li&gt;不要使用在线帮助作为学习指导&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;菜单项应该是解释性的&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;h5 id=&#34;专家用户&#34;&gt;专家用户&lt;/h5&gt;&#xA;&lt;p&gt;特点&lt;/p&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;对缺少经验的用户有着异乎寻常的影响&lt;/li&gt;&#xA;&lt;li&gt;欣赏更新的且更强大功能&lt;/li&gt;&#xA;&lt;li&gt;不会受到复杂性增加的干扰&#xA;设计要求&lt;/li&gt;&#xA;&lt;li&gt;对经常使用的工具集，要能快速访问&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;h5 id=&#34;中间用户&#34;&gt;中间用户&lt;/h5&gt;&#xA;&lt;p&gt;特点&lt;/p&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;需要工具&lt;/li&gt;&#xA;&lt;li&gt;知道如何使用参考资料&lt;/li&gt;&#xA;&lt;li&gt;能够区分经常使用和很少使用的功能&lt;/li&gt;&#xA;&lt;li&gt;高级功能的存在让永久的中间用户放心&#xA;设计要求&lt;/li&gt;&#xA;&lt;li&gt;工具提示（Tooltip）是适合中间用户最好的习惯用法&lt;/li&gt;&#xA;&lt;li&gt;在线帮助是永久中间用户的极佳工具&lt;/li&gt;&#xA;&lt;li&gt;常用功能中的工具放在用户界面的前端和中心位置&lt;/li&gt;&#xA;&lt;li&gt;提供一些额外的高级特性&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;h4 id=&#34;年龄差异&#34;&gt;年龄差异&lt;/h4&gt;&#xA;&lt;p&gt;老年人和儿童&lt;/p&gt;&#xA;&lt;h4 id=&#34;文化差异&#34;&gt;文化差异&lt;/h4&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;符号：勾（√）和叉（X）分别表示肯定和否定&lt;/li&gt;&#xA;&lt;li&gt;姿势：点头vs.摇头&lt;/li&gt;&#xA;&lt;li&gt;颜色：如红色与绿色&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;h4 id=&#34;健康差异&#34;&gt;健康差异&lt;/h4&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;听见、视觉&lt;/li&gt;&#xA;&lt;li&gt;身体损伤&lt;/li&gt;&#xA;&lt;li&gt;语言&lt;/li&gt;&#xA;&lt;li&gt;朗读&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;h2 id=&#34;用户建模&#34;&gt;⭐用户建模&lt;/h2&gt;&#xA;&lt;blockquote&gt;&#xA;&lt;p&gt;可能会考设计、评估人物角色&lt;/p&gt;&#xA;&lt;/blockquote&gt;&#xA;&lt;p&gt;使用人物角色 (Personas) 对用户进行建模。&lt;/p&gt;&#xA;&lt;h3 id=&#34;人物角色&#34;&gt;人物角色&lt;/h3&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;不是真实的人&lt;/li&gt;&#xA;&lt;li&gt;是基于观察到的那些真实人的行为和动机，并且在整个设计过程中代表真实的人&lt;/li&gt;&#xA;&lt;li&gt;是在人口统计学调查收集到的实际用户的行为数据的基础上形成的综合原型&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;h3 id=&#34;解决什么问题&#34;&gt;解决什么问题&lt;/h3&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;弹性用户&lt;/li&gt;&#xA;&lt;li&gt;自参考设计&lt;/li&gt;&#xA;&lt;li&gt;边缘情况设计&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;h3 id=&#34;怎么构造人物角色&#34;&gt;怎么构造人物角色&lt;/h3&gt;&#xA;&lt;p&gt;观点：真实用户和人物角色，既是多对一的关系，也是一对多的关系&lt;/p&gt;&#xA;&lt;p&gt;建模时基于如下问题：&lt;/p&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;谁将使用系统？&lt;/li&gt;&#xA;&lt;li&gt;这些用户属于哪些类型的人群？&lt;/li&gt;&#xA;&lt;li&gt;是什么因素决定他们将怎样使用系统？&lt;/li&gt;&#xA;&lt;li&gt;他们与软件的关系有什么特征？&lt;/li&gt;&#xA;&lt;li&gt;他们通常需要软件提供什么支持？&lt;/li&gt;&#xA;&lt;li&gt;他们对软件会有怎样的行为？他们对软件的行为有什么期望？&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;h3 id=&#34;例子&#34;&gt;例子&lt;/h3&gt;&#xA;&lt;p&gt;例子中还包含了场景。&lt;/p&gt;</description>
    </item>
    <item>
      <title>C&#43;&#43; 强制类型转换</title>
      <link>https://huoxj.github.io/posts/c&#43;&#43;%E6%8B%BE%E9%81%97/c&#43;&#43;-%E5%BC%BA%E5%88%B6%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2/</link>
      <pubDate>Tue, 24 Dec 2024 00:00:00 +0000</pubDate>
      <guid>https://huoxj.github.io/posts/c&#43;&#43;%E6%8B%BE%E9%81%97/c&#43;&#43;-%E5%BC%BA%E5%88%B6%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2/</guid>
      <description>&lt;h2 id=&#34;why&#34;&gt;Why&lt;/h2&gt;&#xA;&lt;p&gt;C 中的强制类型转换是通过在表达式前面加类型名实现的。&lt;/p&gt;&#xA;&lt;p&gt;C++ 中，强制类型转换被细分成了四个运算符：&lt;/p&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;static_cast&lt;/li&gt;&#xA;&lt;li&gt;reinterpret_cast&lt;/li&gt;&#xA;&lt;li&gt;const_cast&lt;/li&gt;&#xA;&lt;li&gt;dynamic_cast&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;p&gt;原因如下：&lt;/p&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;不同场景下的强制转换，风险是不同的，需要细分来体现&#xA;比如，int 转成 double 是风险不大的；但是将 const 指针转换成非 const 指针是十分危险的。&lt;/li&gt;&#xA;&lt;li&gt;在继承场景下，将基类转换成派生类需要检查是否成功&#xA;C 中的强制转换是无法知道基类指针转换成派生类是否成功的。但是 dynamic_cast 可以以返回 nullptr 的方式告诉你转换是否成功。&lt;/li&gt;&#xA;&lt;li&gt;程序中强制类型转换难以定位&#xA;新方法中，你只需要找 cast 单词出现的地方，就能知道所有进行了显示强制类型转换的地方。&lt;/li&gt;&#xA;&lt;li&gt;类型转换出错时，cast 会报错，方便定位错误&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;h2 id=&#34;static_cast&#34;&gt;static_cast&lt;/h2&gt;&#xA;&lt;p&gt;static_cast 负责风险低、自然的转换。允许可以隐式转换的类型间的转换。&lt;/p&gt;&#xA;&lt;p&gt;具体来说：&lt;/p&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;允许&lt;strong&gt;基本类型&lt;/strong&gt;之间的转换。比如 int、float、double 之间的转换&lt;/li&gt;&#xA;&lt;li&gt;允许对象的重载了强制类型转换运算符的转换&lt;/li&gt;&#xA;&lt;li&gt;其他场景尽量不要用 static_cast&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;h2 id=&#34;dynamic_cast&#34;&gt;dynamic_cast&lt;/h2&gt;&#xA;&lt;p&gt;dynamic_cast 负责基类到派生类的引用和指针的转换。&lt;/p&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;目标类型是源类型的派生。即父转子。&lt;/li&gt;&#xA;&lt;li&gt;被转换的类需要有虚函数，否则会报错：&#xA;&lt;code&gt;bad_dynamic_cast_not_polymorphic: &#39;xxx&#39; is not polymorphic&lt;/code&gt;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;h2 id=&#34;reinterpret_cast&#34;&gt;reinterpret_cast&lt;/h2&gt;&#xA;&lt;p&gt;reinterpret_cast 负责指针的不安全的转换。转换时，逐 bit 复制数据，也印证了 reinterpret 的含义，就是对相同的 01 bit 流进行不同的解释。&lt;/p&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;负责不同类型的指针、引用之间的转换&lt;/li&gt;&#xA;&lt;li&gt;指针到指针数值（里面存的地址）的转换。&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;h2 id=&#34;const_cast&#34;&gt;const_cast&lt;/h2&gt;&#xA;&lt;p&gt;const_cast 负责去除 const 的转换。&lt;/p&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;将 const 的只读变量转换成普通的可读可写的变量&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;h2 id=&#34;参考&#34;&gt;参考&lt;/h2&gt;&#xA;&lt;p&gt;&lt;a href=&#34;https://c.biancheng.net/view/410.html&#34;&gt;C++强制类型转换运算符（static_cast、reinterpret_cast、const_cast和dynamic_cast） - C语言中文网&lt;/a&gt;&lt;/p&gt;</description>
    </item>
    <item>
      <title>C&#43;&#43;期末复习</title>
      <link>https://huoxj.github.io/posts/c&#43;&#43;%E6%8B%BE%E9%81%97/c&#43;&#43;%E6%9C%9F%E6%9C%AB%E5%A4%8D%E4%B9%A0/</link>
      <pubDate>Tue, 24 Dec 2024 00:00:00 +0000</pubDate>
      <guid>https://huoxj.github.io/posts/c&#43;&#43;%E6%8B%BE%E9%81%97/c&#43;&#43;%E6%9C%9F%E6%9C%AB%E5%A4%8D%E4%B9%A0/</guid>
      <description>&lt;p&gt;根据上课 PPT 和同学与学长的笔记整理而成。&lt;/p&gt;&#xA;&lt;h2 id=&#34;介绍&#34;&gt;介绍&lt;/h2&gt;&#xA;&lt;h3 id=&#34;c-历史&#34;&gt;C++ 历史&lt;/h3&gt;&#xA;&lt;p&gt;先跳过。。。&lt;/p&gt;&#xA;&lt;h2 id=&#34;结构化编程部分&#34;&gt;结构化编程部分&lt;/h2&gt;&#xA;&lt;h3 id=&#34;强制类型转换&#34;&gt;强制类型转换&lt;/h3&gt;&#xA;&lt;p&gt;article link=&amp;quot;/posts/C++拾遗/C++-强制类型转换&amp;quot; &amp;gt;}}&lt;/p&gt;&#xA;&lt;h3 id=&#34;表达式的副作用&#34;&gt;表达式的副作用&lt;/h3&gt;&#xA;&lt;p&gt;副作用，就是一个过程是否会修改参与的变量的性质。&lt;/p&gt;&#xA;&lt;p&gt;在表达式中，有副作用的运算符：&lt;code&gt;=&lt;/code&gt; &lt;code&gt;+=&lt;/code&gt; &lt;code&gt;++&lt;/code&gt; &lt;code&gt;&amp;lt;&amp;lt;&lt;/code&gt; 等等&#xA;无副作用的运算符：&lt;code&gt;+&lt;/code&gt; &lt;code&gt;&amp;amp;&amp;amp;&lt;/code&gt; 等等&lt;/p&gt;&#xA;&lt;hr&gt;&#xA;&lt;h3 id=&#34;decltype&#34;&gt;decltype&lt;/h3&gt;&#xA;&lt;p&gt;和 auto 有相似之处。&lt;/p&gt;&#xA;&lt;p&gt;auto 和 decltype 都用在声明变量上，都是基于 RTTI 机制实现的。&lt;/p&gt;&#xA;&lt;p&gt;auto 是对&lt;strong&gt;初始化&lt;/strong&gt;的右值进行类型推导，然后给声明的变量确定类型、赋值。&lt;/p&gt;&#xA;&lt;p&gt;decltype 是对传入的参数类型进行类型推导，然后本身就作为这个类型的名称。&lt;/p&gt;&#xA;&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#d8dee9;background-color:#2e3440;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-cpp&#34; data-lang=&#34;cpp&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#81a1c1&#34;&gt;int&lt;/span&gt; x &lt;span style=&#34;color:#81a1c1&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#b48ead&#34;&gt;0&lt;/span&gt;&lt;span style=&#34;color:#eceff4&#34;&gt;;&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#81a1c1&#34;&gt;int&lt;/span&gt;&lt;span style=&#34;color:#81a1c1&#34;&gt;&amp;amp;&lt;/span&gt; ref &lt;span style=&#34;color:#81a1c1&#34;&gt;=&lt;/span&gt; x&lt;span style=&#34;color:#eceff4&#34;&gt;;&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#81a1c1;font-weight:bold&#34;&gt;auto&lt;/span&gt; ref1 &lt;span style=&#34;color:#81a1c1&#34;&gt;=&lt;/span&gt; x&lt;span style=&#34;color:#eceff4&#34;&gt;;&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#81a1c1;font-weight:bold&#34;&gt;decltype&lt;/span&gt;&lt;span style=&#34;color:#eceff4&#34;&gt;(&lt;/span&gt;ref&lt;span style=&#34;color:#eceff4&#34;&gt;)&lt;/span&gt; ref2 &lt;span style=&#34;color:#81a1c1&#34;&gt;=&lt;/span&gt; x&lt;span style=&#34;color:#eceff4&#34;&gt;;&lt;/span&gt;  &lt;span style=&#34;color:#616e87;font-style:italic&#34;&gt;// equals to &amp;#34;int&amp;amp; ref2 = x&amp;#34;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;既然本身就作为这个类型的名称，我们也可以结合 using 和 typedef：&lt;/p&gt;&#xA;&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#d8dee9;background-color:#2e3440;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-cpp&#34; data-lang=&#34;cpp&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#81a1c1&#34;&gt;int&lt;/span&gt; x &lt;span style=&#34;color:#81a1c1&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#b48ead&#34;&gt;0&lt;/span&gt;&lt;span style=&#34;color:#eceff4&#34;&gt;;&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#81a1c1&#34;&gt;int&lt;/span&gt;&lt;span style=&#34;color:#81a1c1&#34;&gt;&amp;amp;&lt;/span&gt; ref &lt;span style=&#34;color:#81a1c1&#34;&gt;=&lt;/span&gt; x&lt;span style=&#34;color:#eceff4&#34;&gt;;&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#81a1c1;font-weight:bold&#34;&gt;using&lt;/span&gt; int_ref &lt;span style=&#34;color:#81a1c1&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#81a1c1;font-weight:bold&#34;&gt;decltype&lt;/span&gt;&lt;span style=&#34;color:#eceff4&#34;&gt;(&lt;/span&gt;ref&lt;span style=&#34;color:#eceff4&#34;&gt;);&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;h4 id=&#34;参考&#34;&gt;参考&lt;/h4&gt;&#xA;&lt;p&gt;&lt;a href=&#34;https://www.cnblogs.com/QG-whz/p/4952980.html&#34;&gt;C++11特性：decltype关键字 - melonstreet - 博客园&lt;/a&gt;&lt;/p&gt;</description>
    </item>
    <item>
      <title>Lec-5 评估技术-观察用户</title>
      <link>https://huoxj.github.io/posts/%E4%BA%BA%E6%9C%BA%E4%BA%A4%E4%BA%92/lec-5-%E8%AF%84%E4%BC%B0%E6%8A%80%E6%9C%AF-%E8%A7%82%E5%AF%9F%E7%94%A8%E6%88%B7/</link>
      <pubDate>Sun, 22 Dec 2024 00:00:00 +0000</pubDate>
      <guid>https://huoxj.github.io/posts/%E4%BA%BA%E6%9C%BA%E4%BA%A4%E4%BA%92/lec-5-%E8%AF%84%E4%BC%B0%E6%8A%80%E6%9C%AF-%E8%A7%82%E5%AF%9F%E7%94%A8%E6%88%B7/</guid>
      <description>&lt;h2 id=&#34;背景&#34;&gt;背景&lt;/h2&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;观察用户怎样工作，很重要&#xA;&lt;ul&gt;&#xA;&lt;li&gt;用户口头描述可能不客观、不完整、不真实&lt;/li&gt;&#xA;&lt;li&gt;用户会忽略细节&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;观察用户是所有可用性方法中最简单的方法&lt;/li&gt;&#xA;&lt;li&gt;观察用户适用于开发的任何阶段&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;h2 id=&#34;观察方式&#34;&gt;观察方式&lt;/h2&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;真实环境观察&#xA;&lt;ul&gt;&#xA;&lt;li&gt;观察者可以是参与者&lt;/li&gt;&#xA;&lt;li&gt;重点是应用的上下文&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;受控环境观察&#xA;&lt;ul&gt;&#xA;&lt;li&gt;观察者不能参与&lt;/li&gt;&#xA;&lt;li&gt;重点是研究用户执行任务的细节&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;p&gt;二者差别不大（？）。两者经常互为补充、互相参考。&lt;/p&gt;&#xA;&lt;hr&gt;&#xA;&lt;p&gt;以下是具体的观察方法。&lt;/p&gt;&#xA;&lt;h2 id=&#34;直接观察&#34;&gt;直接观察&lt;/h2&gt;&#xA;&lt;h3 id=&#34;实验室观察&#34;&gt;实验室观察&lt;/h3&gt;&#xA;&lt;p&gt;在专门为可用性测试而安装配置的固定设备的环境下进行的观察。&lt;/p&gt;&#xA;&lt;h4 id=&#34;布局&#34;&gt;布局&lt;/h4&gt;&#xA;&lt;p&gt;测试区、观察区&lt;/p&gt;&#xA;&lt;p&gt;二者分开，防止互相干扰。&lt;/p&gt;&#xA;&lt;p&gt;还可以让用户坐在家里测试。&lt;/p&gt;&#xA;&lt;h4 id=&#34;优缺点&#34;&gt;优缺点&lt;/h4&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;&#xA;&lt;p&gt;优点：提供了可控且一致的评估环境&lt;/p&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;&#xA;&lt;p&gt;缺点：&lt;/p&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;人为环境，不自然。可能降低测试结论的一般性。&lt;/li&gt;&#xA;&lt;li&gt;不利于观察多人之间的协作&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;h4 id=&#34;实际问题&#34;&gt;实际问题&lt;/h4&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;地点选择&lt;/li&gt;&#xA;&lt;li&gt;设备安装&#xA;&lt;ul&gt;&#xA;&lt;li&gt;录面部表情&lt;/li&gt;&#xA;&lt;li&gt;录交互过程&lt;/li&gt;&#xA;&lt;li&gt;录肢体语言&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;测试设备&lt;/li&gt;&#xA;&lt;li&gt;文档准备&#xA;&lt;ul&gt;&#xA;&lt;li&gt;协议书：说明测试目的、时间、用户权利等细节&lt;/li&gt;&#xA;&lt;li&gt;脚本：用户要执行什么任务&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;h3 id=&#34;现场观察&#34;&gt;现场观察&lt;/h3&gt;&#xA;&lt;p&gt;在用户的实际环境中观察用户在使用软件时的情况。&lt;/p&gt;&#xA;&lt;p&gt;是发现同使用环境有关的问题的最佳手段&lt;/p&gt;&#xA;&lt;h4 id=&#34;问题清单&#34;&gt;问题清单&lt;/h4&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;明确初步的研究目标和问题&lt;/li&gt;&#xA;&lt;li&gt;选择一个框架指导观察&lt;/li&gt;&#xA;&lt;li&gt;决定数据记录方式&#xA;&lt;ul&gt;&#xA;&lt;li&gt;笔记、录音、摄像，还是三者结合&lt;/li&gt;&#xA;&lt;li&gt;确保设备到位并能正常工作&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;评估后，尽快与观察者或被观察者共同检查所记录的笔记和其他数据&#xA;&lt;ul&gt;&#xA;&lt;li&gt;研究细节，找出含糊之处&lt;/li&gt;&#xA;&lt;li&gt;人的记忆能力是有限的，最好24小时内回顾数据&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;数据记录时，应区分个人意见和观察数据&#xA;&lt;ul&gt;&#xA;&lt;li&gt;明确标注需要进一步了解的事项&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;培养良好的合作关系&#xA;&lt;ul&gt;&#xA;&lt;li&gt;取得被观察对象的认可和信任&lt;/li&gt;&#xA;&lt;li&gt;避免只关注某些人，应注意小组的所有成员&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;处理敏感问题&#xA;&lt;ul&gt;&#xA;&lt;li&gt;避免让观察对象产生被冒犯的感觉&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;注重团队协作&#xA;&lt;ul&gt;&#xA;&lt;li&gt;通过比较不同评估人员的记录，得到更为可信的数据&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;应从不同的角度进行观察，避免只专注于某些特定行为&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;h4 id=&#34;注意事项&#34;&gt;注意事项&lt;/h4&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;观察人员自始至终应尽量保持安静&#xA;&lt;ol&gt;&#xA;&lt;li&gt;让用户感觉不到观察人员的存在&lt;/li&gt;&#xA;&lt;li&gt;保证用户操作和平时工作的状态一样&lt;/li&gt;&#xA;&lt;/ol&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;当用户的操作令观察人员无法理解时&#xA;&lt;ol&gt;&#xA;&lt;li&gt;需要打断用户，请他对所做的某些操作进行解释&lt;/li&gt;&#xA;&lt;li&gt;或把用户莫名其妙的操作行为记录下来&lt;/li&gt;&#xA;&lt;/ol&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;观察初期，应该拒绝用户的任何帮助请求&#xA;&lt;ol&gt;&#xA;&lt;li&gt;希望观察用户在没有系统专家指点的情况下如何操作&lt;/li&gt;&#xA;&lt;li&gt;待评估完成后为用户提供适当帮助&lt;/li&gt;&#xA;&lt;/ol&gt;&#xA;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;h2 id=&#34;间接观察&#34;&gt;间接观察&lt;/h2&gt;&#xA;&lt;h3 id=&#34;日志和交互记录&#34;&gt;日志和交互记录&lt;/h3&gt;&#xA;&lt;h4 id=&#34;适用场合&#34;&gt;适用场合&lt;/h4&gt;&#xA;&lt;ol&gt;&#xA;&lt;li&gt;直接观察可能影响用户&lt;/li&gt;&#xA;&lt;li&gt;或者评估人员无法在现场进行研究&lt;/li&gt;&#xA;&lt;li&gt;可根据搜集到的数据，推断实际情形，并找出可用性和用户体验方面的问题&lt;/li&gt;&#xA;&lt;/ol&gt;&#xA;&lt;h4 id=&#34;优点&#34;&gt;优点&lt;/h4&gt;&#xA;&lt;ol&gt;&#xA;&lt;li&gt;体现了用户是如何完成真实任务的&lt;/li&gt;&#xA;&lt;li&gt;使得从工作在不同环境下的大量用户那里自动收集数据变得相当容易&#xA;&lt;ol&gt;&#xA;&lt;li&gt;适用于用户分散、无法当面测试的情形&lt;/li&gt;&#xA;&lt;li&gt;如互联网应用和网站设计项目等&lt;/li&gt;&#xA;&lt;/ol&gt;&#xA;&lt;/li&gt;&#xA;&lt;/ol&gt;&#xA;&lt;h2 id=&#34;观察框架&#34;&gt;观察框架&lt;/h2&gt;&#xA;&lt;p&gt;用于组织观察活动和明确观察重点。因为观察过程中发生的事件都非常复杂且变化迅速。&lt;/p&gt;</description>
    </item>
    <item>
      <title>Lec-6 评估技术-询问用户与专家</title>
      <link>https://huoxj.github.io/posts/%E4%BA%BA%E6%9C%BA%E4%BA%A4%E4%BA%92/lec-6-%E8%AF%84%E4%BC%B0%E6%8A%80%E6%9C%AF-%E8%AF%A2%E9%97%AE%E7%94%A8%E6%88%B7%E4%B8%8E%E4%B8%93%E5%AE%B6/</link>
      <pubDate>Sun, 22 Dec 2024 00:00:00 +0000</pubDate>
      <guid>https://huoxj.github.io/posts/%E4%BA%BA%E6%9C%BA%E4%BA%A4%E4%BA%92/lec-6-%E8%AF%84%E4%BC%B0%E6%8A%80%E6%9C%AF-%E8%AF%A2%E9%97%AE%E7%94%A8%E6%88%B7%E4%B8%8E%E4%B8%93%E5%AE%B6/</guid>
      <description>&lt;h2 id=&#34;背景&#34;&gt;背景&lt;/h2&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;了解&lt;strong&gt;用户&lt;/strong&gt;的需要和对产品的意见和建议&#xA;&lt;ul&gt;&#xA;&lt;li&gt;观察用户&lt;/li&gt;&#xA;&lt;li&gt;询问用户&#xA;&lt;ul&gt;&#xA;&lt;li&gt;适用于客观上较难度量的、与用户主观满意度和可能的忧虑心情相关的问题&lt;/li&gt;&#xA;&lt;li&gt;访谈和问卷调查&#xA;&lt;ul&gt;&#xA;&lt;li&gt;在研究用户如何使用系统，以及哪些系统功能是用户非常喜欢或不喜欢的方面也非常有效&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;不知道该怎么做或者对预期的结果没有把握&#xA;&lt;ul&gt;&#xA;&lt;li&gt;请专家帮忙&lt;/li&gt;&#xA;&lt;li&gt;不能帮助大家成为可用性专家&lt;/li&gt;&#xA;&lt;li&gt;但有助于更好地去评估自己和他人的工作&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;h2 id=&#34;询问用户-访谈&#34;&gt;询问用户-访谈&lt;/h2&gt;&#xA;&lt;p&gt;有目的的对话过程。&lt;/p&gt;&#xA;&lt;h3 id=&#34;分类&#34;&gt;分类&lt;/h3&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;开放式（或非结构化）访谈&#xA;&lt;ul&gt;&#xA;&lt;li&gt;问题是&lt;strong&gt;开放式&lt;/strong&gt;的，不限定内容和格式&lt;/li&gt;&#xA;&lt;li&gt;受访人自行选择详细回答还是简要回答&lt;/li&gt;&#xA;&lt;li&gt;访问人应确保能够搜集到重要问题的回答&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;结构化访谈&#xA;&lt;ul&gt;&#xA;&lt;li&gt;根据&lt;strong&gt;预先确定&lt;/strong&gt;的一组问题进行访谈&lt;/li&gt;&#xA;&lt;li&gt;问题通常是“封闭式”的，它要求&lt;strong&gt;准确的回答&lt;/strong&gt;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;半结构化访谈&#xA;&lt;ul&gt;&#xA;&lt;li&gt;开放式问题+封闭式问题&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;集体访谈&#xA;&lt;ul&gt;&#xA;&lt;li&gt;基本思想：个别成员的看法是在应用的上下文中通过与其他用户的交流而形成的&lt;/li&gt;&#xA;&lt;li&gt;“焦点小组”是集体访谈的一种形式&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;h3 id=&#34;原则&#34;&gt;原则&lt;/h3&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;避免过长的问题&lt;/li&gt;&#xA;&lt;li&gt;避免使用复合句&lt;/li&gt;&#xA;&lt;li&gt;避免使用可能让用户感觉尴尬的术语或他们无法理解的语言&lt;/li&gt;&#xA;&lt;li&gt;避免使用有诱导性的问题&lt;/li&gt;&#xA;&lt;li&gt;尽可能保证问题是中性的&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;h3 id=&#34;焦点小组&#34;&gt;焦点小组&lt;/h3&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;非正式的评估方法&#xA;&lt;ul&gt;&#xA;&lt;li&gt;在界面设计之前和经过一段使用之后评估用户的需要和感受&lt;/li&gt;&#xA;&lt;li&gt;是市场、政治和社会科学研究经常使用的方法&lt;/li&gt;&#xA;&lt;li&gt;人数限制：由大约6到9个典型用户组成&lt;/li&gt;&#xA;&lt;li&gt;如在评估大学的网站时，可考虑由行政人员、教师和学生们组成3个分别的焦点小组&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;主持人工作&#xA;&lt;ul&gt;&#xA;&lt;li&gt;事先列出一张讨论问题和数据收集目标的清单&lt;/li&gt;&#xA;&lt;li&gt;保持所谈论的内容不离题&lt;/li&gt;&#xA;&lt;li&gt;保证小组的每个成员都积极参与谈论&lt;/li&gt;&#xA;&lt;li&gt;讨论结果的分析报告&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;焦点小组存在风险&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;h2 id=&#34;询问用户-问卷调查&#34;&gt;询问用户-问卷调查&lt;/h2&gt;&#xA;&lt;p&gt;问卷调查是用于搜集统计数据和用户意见的常用方法。&lt;/p&gt;&#xA;&lt;h3 id=&#34;问卷设计原则&#34;&gt;问卷设计原则&lt;/h3&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;问题明确，具体&lt;/li&gt;&#xA;&lt;li&gt;在可能时，采用封闭式问题并提供充分的答案选项&lt;/li&gt;&#xA;&lt;li&gt;对于征求用户意见的问题，应提供一个“无看法”的答案选项&lt;/li&gt;&#xA;&lt;li&gt;注意提问次序，先提出一般化问题，再提出具体问题&lt;/li&gt;&#xA;&lt;li&gt;避免使用复杂的多重问题&lt;/li&gt;&#xA;&lt;li&gt;在使用等级标度时，应设定适当的等级范围，并确保它们不重叠&lt;/li&gt;&#xA;&lt;li&gt;避免使用术语&lt;/li&gt;&#xA;&lt;li&gt;明确说明如何完成问卷&lt;/li&gt;&#xA;&lt;li&gt;既要做到紧凑，也应适当留空&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;h3 id=&#34;问题类型&#34;&gt;问题类型&lt;/h3&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;常规问题&#xA;&lt;ul&gt;&#xA;&lt;li&gt;年龄、性别、职业、居住地、应用计算机的经验等&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;自由回答问题&lt;/li&gt;&#xA;&lt;li&gt;量化分级问题&lt;/li&gt;&#xA;&lt;li&gt;多选题&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;h3 id=&#34;用户满意度调查表-quis&#34;&gt;用户满意度调查表 QUIS&lt;/h3&gt;&#xA;&lt;p&gt;QUIS: questionnaire for user interaction satisfaction&lt;/p&gt;</description>
    </item>
    <item>
      <title>Lec-7 评估技术-用户测试</title>
      <link>https://huoxj.github.io/posts/%E4%BA%BA%E6%9C%BA%E4%BA%A4%E4%BA%92/lec-7-%E8%AF%84%E4%BC%B0%E6%8A%80%E6%9C%AF-%E7%94%A8%E6%88%B7%E6%B5%8B%E8%AF%95/</link>
      <pubDate>Sun, 22 Dec 2024 00:00:00 +0000</pubDate>
      <guid>https://huoxj.github.io/posts/%E4%BA%BA%E6%9C%BA%E4%BA%A4%E4%BA%92/lec-7-%E8%AF%84%E4%BC%B0%E6%8A%80%E6%9C%AF-%E7%94%A8%E6%88%B7%E6%B5%8B%E8%AF%95/</guid>
      <description>&lt;p&gt;用户测试主要是指在&lt;strong&gt;受控环境中&lt;/strong&gt;测量典型用户&lt;strong&gt;执行典型任务&lt;/strong&gt;的情况，目标是获取&lt;strong&gt;客观&lt;/strong&gt;的性能数据来评价系统的可用性，适合对原型和现有系统进行评估。&lt;/p&gt;&#xA;&lt;h2 id=&#34;decide-评估框架&#34;&gt;DECIDE 评估框架&lt;/h2&gt;&#xA;&lt;h3 id=&#34;六个步骤&#34;&gt;六个步骤&lt;/h3&gt;&#xA;&lt;ol&gt;&#xA;&lt;li&gt;决定评估需要完成的总体目标&lt;/li&gt;&#xA;&lt;li&gt;发掘需要回答的具体问题&lt;/li&gt;&#xA;&lt;li&gt;选择用于回答具体问题的评估范型和技术&lt;/li&gt;&#xA;&lt;li&gt;标识必须解决的实际问题，如测试用户的选择&lt;/li&gt;&#xA;&lt;li&gt;决定如何处理有关道德的问题&lt;/li&gt;&#xA;&lt;li&gt;评估解释并表示数据&lt;/li&gt;&#xA;&lt;/ol&gt;&#xA;&lt;h3 id=&#34;1-确定目标&#34;&gt;1. 确定目标&lt;/h3&gt;&#xA;&lt;p&gt;评估目标决定了评估过程，影响&lt;strong&gt;评估范型&lt;/strong&gt;的选择。&lt;/p&gt;&#xA;&lt;p&gt;评估的 why：&lt;/p&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;产品设计是否理解了用户需要&lt;/li&gt;&#xA;&lt;li&gt;为概念设计选择最佳隐喻&lt;/li&gt;&#xA;&lt;li&gt;界面是否满足一致性需要&lt;/li&gt;&#xA;&lt;li&gt;探讨新产品应做的改进&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;h3 id=&#34;2-发掘问题&#34;&gt;2. 发掘问题&lt;/h3&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;根据目标确定问题。&lt;/li&gt;&#xA;&lt;li&gt;问题可逐层分解&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;h3 id=&#34;3-选择评估范型和技术&#34;&gt;3. 选择评估范型和技术&lt;/h3&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;范型决定了技术类型&lt;/li&gt;&#xA;&lt;li&gt;必须权衡实际问题和道德问题&#xA;&lt;ul&gt;&#xA;&lt;li&gt;最适合的技术可能成本过高、所需时间过长、不具备必要设备和技能&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;可结合使用多种技术&#xA;&lt;ul&gt;&#xA;&lt;li&gt;不同技术有助于了解设计的不同方面&lt;/li&gt;&#xA;&lt;li&gt;不同类型数据可从不同角度看待问题&lt;/li&gt;&#xA;&lt;li&gt;组合有助于全面了解设计的情况&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;h3 id=&#34;4-明确实际问题&#34;&gt;4. 明确实际问题&lt;/h3&gt;&#xA;&lt;blockquote&gt;&#xA;&lt;p&gt;即如下因素的选择，以及明确限制等注意事项。&lt;/p&gt;&#xA;&lt;/blockquote&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;用户&#xA;&lt;ul&gt;&#xA;&lt;li&gt;选择恰当的用户&lt;/li&gt;&#xA;&lt;li&gt;用户任务时间&lt;/li&gt;&#xA;&lt;li&gt;安排用户熟悉系统&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;设施及设备&lt;/li&gt;&#xA;&lt;li&gt;期限与预算&lt;/li&gt;&#xA;&lt;li&gt;技能技术&#xA;&lt;ul&gt;&#xA;&lt;li&gt;是否需要可用性专家&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;h4 id=&#34;选择参与者&#34;&gt;选择参与者&lt;/h4&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;选择&lt;strong&gt;具有代表性&lt;/strong&gt;的典型用户；&lt;/li&gt;&#xA;&lt;li&gt;通常需要根据实际情况平衡性别比例。&lt;/li&gt;&#xA;&lt;li&gt;至少 4−5 位，5−12 位用户就足够了。&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;h3 id=&#34;5-处理道德问题&#34;&gt;5. 处理道德问题&lt;/h3&gt;&#xA;&lt;p&gt;保护个人隐私&lt;/p&gt;&#xA;&lt;h4 id=&#34;指导原则&#34;&gt;指导原则&lt;/h4&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;说明研究的&lt;strong&gt;目的&lt;/strong&gt;及要求参与者做的&lt;strong&gt;工作&lt;/strong&gt;&lt;/li&gt;&#xA;&lt;li&gt;说明保密事项&lt;/li&gt;&#xA;&lt;li&gt;测试对象是软件，而非个人&lt;/li&gt;&#xA;&lt;li&gt;对测试过程的特殊要求，是否边做边说等&lt;/li&gt;&#xA;&lt;li&gt;用户可自由表达对产品的意见&lt;/li&gt;&#xA;&lt;li&gt;说明是否对过程进行录像&#xA;&lt;ul&gt;&#xA;&lt;li&gt;不能拍摄用户的面部&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;欢迎用户提问&lt;/li&gt;&#xA;&lt;li&gt;用户有随时终止测试的权利&lt;/li&gt;&#xA;&lt;li&gt;对用户话语的使用应征得同意，并选择匿名方式&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;h3 id=&#34;6-评估解释并表示数据&#34;&gt;6. 评估、解释并表示数据&lt;/h3&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;评估技术决定了：搜集什么类型的数据，如何分析，如何表示&lt;/li&gt;&#xA;&lt;li&gt;可靠性&lt;/li&gt;&#xA;&lt;li&gt;有效性&lt;/li&gt;&#xA;&lt;li&gt;偏见&lt;/li&gt;&#xA;&lt;li&gt;普遍性&lt;/li&gt;&#xA;&lt;li&gt;环境影响&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;h2 id=&#34;小规模试验&#34;&gt;小规模试验&lt;/h2&gt;&#xA;&lt;p&gt;对评估计划进行小范围测试&lt;/p&gt;</description>
    </item>
    <item>
      <title>三剑客</title>
      <link>https://huoxj.github.io/posts/c&#43;&#43;%E6%8B%BE%E9%81%97/%E4%B8%89%E5%89%91%E5%AE%A2/</link>
      <pubDate>Sat, 21 Dec 2024 00:00:00 +0000</pubDate>
      <guid>https://huoxj.github.io/posts/c&#43;&#43;%E6%8B%BE%E9%81%97/%E4%B8%89%E5%89%91%E5%AE%A2/</guid>
      <description>&lt;p&gt;std::optional&#xA;std::tuple&#xA;std::any&lt;/p&gt;</description>
    </item>
    <item>
      <title>流</title>
      <link>https://huoxj.github.io/posts/c&#43;&#43;%E6%8B%BE%E9%81%97/%E6%B5%81/</link>
      <pubDate>Thu, 12 Dec 2024 00:00:00 +0000</pubDate>
      <guid>https://huoxj.github.io/posts/c&#43;&#43;%E6%8B%BE%E9%81%97/%E6%B5%81/</guid>
      <description>&lt;h2 id=&#34;输入输出处理&#34;&gt;输入、输出处理&lt;/h2&gt;&#xA;&lt;h2 id=&#34;用流替代-sprintf--sscanf&#34;&gt;用流替代 sprintf / sscanf&lt;/h2&gt;&#xA;&lt;p&gt;&lt;a href=&#34;https://blog.csdn.net/Hodors/article/details/136045381&#34;&gt;C++如何理解 sprintf 函数 ，寻找更好的替代方案_c++ sprintf-CSDN博客&lt;/a&gt;&lt;/p&gt;</description>
    </item>
    <item>
      <title>锁与条件变量</title>
      <link>https://huoxj.github.io/posts/c&#43;&#43;%E6%8B%BE%E9%81%97/%E9%94%81%E4%B8%8E%E6%9D%A1%E4%BB%B6%E5%8F%98%E9%87%8F/</link>
      <pubDate>Wed, 11 Dec 2024 00:00:00 +0000</pubDate>
      <guid>https://huoxj.github.io/posts/c&#43;&#43;%E6%8B%BE%E9%81%97/%E9%94%81%E4%B8%8E%E6%9D%A1%E4%BB%B6%E5%8F%98%E9%87%8F/</guid>
      <description>&lt;ul&gt;&#xA;&lt;li&gt;std::mutex&lt;/li&gt;&#xA;&lt;li&gt;std::condition_variable&lt;/li&gt;&#xA;&lt;li&gt;std::unique_lock&lt;/li&gt;&#xA;&lt;li&gt;std::atomic&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;h2 id=&#34;参考&#34;&gt;参考&lt;/h2&gt;&#xA;&lt;p&gt;&lt;a href=&#34;https://blog.csdn.net/u012507022/article/details/85909567&#34;&gt;C++11多线程 unique_lock详解_uniquelock-CSDN博客&lt;/a&gt;&#xA;&lt;a href=&#34;https://blog.csdn.net/qq_38210354/article/details/107168532&#34;&gt;C++11多线程条件变量std::condition_variable详解（转 ）_while (!ready) cv.wait(lck);-CSDN博客&lt;/a&gt;&#xA;&lt;a href=&#34;https://blog.csdn.net/m0_75215937/article/details/135074541&#34;&gt;【C++入门到精通】condition_variable（条件变量）C++11 [ C++入门 ]_c++ condition variable-CSDN博客&lt;/a&gt;&#xA;&lt;a href=&#34;https://www.runoob.com/cplusplus/cpp-libs-atomic.html&#34;&gt;C++ 标准库 atomic | 菜鸟教程&lt;/a&gt;&lt;/p&gt;</description>
    </item>
    <item>
      <title>运算符重载</title>
      <link>https://huoxj.github.io/posts/c&#43;&#43;%E6%8B%BE%E9%81%97/%E8%BF%90%E7%AE%97%E7%AC%A6%E9%87%8D%E8%BD%BD/</link>
      <pubDate>Thu, 05 Dec 2024 00:00:00 +0000</pubDate>
      <guid>https://huoxj.github.io/posts/c&#43;&#43;%E6%8B%BE%E9%81%97/%E8%BF%90%E7%AE%97%E7%AC%A6%E9%87%8D%E8%BD%BD/</guid>
      <description>&lt;h2 id=&#34;可重载的运算符&#34;&gt;可重载的运算符&lt;/h2&gt;&#xA;&lt;p&gt;大部分运算符都可重载：&lt;/p&gt;&#xA;&lt;table&gt;&#xA;  &lt;thead&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;th style=&#34;text-align: left&#34;&gt;双目算术运算符&lt;/th&gt;&#xA;          &lt;th style=&#34;text-align: left&#34;&gt;+ (加)，-(减)，*(乘)，/(除)，% (取模)&lt;/th&gt;&#xA;      &lt;/tr&gt;&#xA;  &lt;/thead&gt;&#xA;  &lt;tbody&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;td style=&#34;text-align: left&#34;&gt;关系运算符&lt;/td&gt;&#xA;          &lt;td style=&#34;text-align: left&#34;&gt;==(等于)，!= (不等于)，&amp;lt; (小于)，&amp;gt; (大于)，&amp;lt;=(小于等于)，&amp;gt;=(大于等于)&lt;/td&gt;&#xA;      &lt;/tr&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;td style=&#34;text-align: left&#34;&gt;逻辑运算符&lt;/td&gt;&#xA;          &lt;td style=&#34;text-align: left&#34;&gt;||(逻辑或)，&amp;amp;&amp;amp;(逻辑与)，!(逻辑非)&lt;/td&gt;&#xA;      &lt;/tr&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;td style=&#34;text-align: left&#34;&gt;单目运算符&lt;/td&gt;&#xA;          &lt;td style=&#34;text-align: left&#34;&gt;+ (正)，-(负)，*(指针)，&amp;amp;(取地址)&lt;/td&gt;&#xA;      &lt;/tr&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;td style=&#34;text-align: left&#34;&gt;自增自减运算符&lt;/td&gt;&#xA;          &lt;td style=&#34;text-align: left&#34;&gt;++(自增)，&amp;ndash;(自减)&lt;/td&gt;&#xA;      &lt;/tr&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;td style=&#34;text-align: left&#34;&gt;位运算符&lt;/td&gt;&#xA;          &lt;td style=&#34;text-align: left&#34;&gt;| (按位或)，&amp;amp; (按位与)，~(按位取反)，^(按位异或),，&amp;laquo; (左移)，&amp;raquo;(右移)&lt;/td&gt;&#xA;      &lt;/tr&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;td style=&#34;text-align: left&#34;&gt;赋值运算符&lt;/td&gt;&#xA;          &lt;td style=&#34;text-align: left&#34;&gt;=, +=, -=, *=, /= , % = , &amp;amp;=, |=, ^=, &amp;laquo;=, &amp;raquo;=&lt;/td&gt;&#xA;      &lt;/tr&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;td style=&#34;text-align: left&#34;&gt;空间申请与释放&lt;/td&gt;&#xA;          &lt;td style=&#34;text-align: left&#34;&gt;new, delete, new[ ] , delete[]&lt;/td&gt;&#xA;      &lt;/tr&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;td style=&#34;text-align: left&#34;&gt;其他运算符&lt;/td&gt;&#xA;          &lt;td style=&#34;text-align: left&#34;&gt;&lt;strong&gt;()&lt;/strong&gt;(函数调用)，&lt;strong&gt;-&amp;gt;&lt;/strong&gt;(成员访问)，&lt;strong&gt;,&lt;/strong&gt;(逗号)，&lt;strong&gt;[]&lt;/strong&gt;(下标)&lt;/td&gt;&#xA;      &lt;/tr&gt;&#xA;  &lt;/tbody&gt;&#xA;&lt;/table&gt;&#xA;&lt;p&gt;所以，只需要记住不可重载的：&lt;/p&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;&lt;code&gt;.&lt;/code&gt;：成员访问&lt;/li&gt;&#xA;&lt;li&gt;&lt;code&gt;.*&lt;/code&gt;：成员指针的成员访问&lt;/li&gt;&#xA;&lt;li&gt;&lt;code&gt;::&lt;/code&gt;: 域运算符&lt;/li&gt;&#xA;&lt;li&gt;&lt;code&gt;?:&lt;/code&gt;: 三目运算符&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;p&gt;还有，&lt;strong&gt;不建议重载&lt;/strong&gt;的：&lt;/p&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;&lt;code&gt;&amp;amp;&amp;amp;&lt;/code&gt;, &lt;code&gt;||&lt;/code&gt;: 重载会影响短路机制&lt;/li&gt;&#xA;&lt;li&gt;改变原运算符含义的。比如 &lt;code&gt;+&lt;/code&gt; 重载成减法&lt;/li&gt;&#xA;&lt;li&gt;改变运算符的优先级、结合方向或操作数&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;p&gt;只能用成员函数重载的：&lt;/p&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;&lt;code&gt;=&lt;/code&gt;, &lt;code&gt;()&lt;/code&gt;, &lt;code&gt;[]&lt;/code&gt;, &lt;code&gt;-&amp;gt;&lt;/code&gt;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;h2 id=&#34;类内重载&#34;&gt;类内重载&lt;/h2&gt;&#xA;&lt;p&gt;类内重载，重载函数作为类的成员函数。运算符的操作数（中的&lt;strong&gt;第一个&lt;/strong&gt;）隐含了 this 指针。&lt;/p&gt;</description>
    </item>
    <item>
      <title>Pytorch DataLoader 加速</title>
      <link>https://huoxj.github.io/posts/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/pytorch-dataloader-%E5%8A%A0%E9%80%9F/</link>
      <pubDate>Mon, 02 Dec 2024 00:00:00 +0000</pubDate>
      <guid>https://huoxj.github.io/posts/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/pytorch-dataloader-%E5%8A%A0%E9%80%9F/</guid>
      <description>&lt;h2 id=&#34;问题&#34;&gt;问题&lt;/h2&gt;&#xA;&lt;p&gt;在训练机器学习作业的 ResNet 网络时，发现每一个 epoch 之前都会卡上十几二十秒才开始 模型真正的训练。具体表现如下：&lt;/p&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;每个 epoch 的 tqdm 进度条之间要卡十几秒才会出现&#xA;&lt;img src=&#34;https://runzblog.oss-cn-hangzhou.aliyuncs.com/postimg/202412022032540.png&#34; alt=&#34;&#34;&gt;&lt;/li&gt;&#xA;&lt;li&gt;显卡占用率时高时低，没有全力干活&#xA;&lt;img src=&#34;https://runzblog.oss-cn-hangzhou.aliyuncs.com/postimg/202412022042166.png&#34; alt=&#34;&#34;&gt;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;h2 id=&#34;原因&#34;&gt;原因&lt;/h2&gt;&#xA;&lt;p&gt;一句话概括，是每个 epoch 前&lt;strong&gt;数据读取到内存再到显存&lt;/strong&gt;占用了绝大部分时间。&lt;/p&gt;&#xA;&lt;p&gt;看下面两张图，时间都花到读数据了，显卡基本全程摸鱼。&lt;/p&gt;&#xA;&lt;p&gt;&lt;img src=&#34;https://runzblog.oss-cn-hangzhou.aliyuncs.com/postimg/202412022151904.png&#34; alt=&#34;&#34;&gt;&#xA;&lt;img src=&#34;https://runzblog.oss-cn-hangzhou.aliyuncs.com/postimg/202412022151536.png&#34; alt=&#34;&#34;&gt;&lt;/p&gt;&#xA;&lt;p&gt;详细来说，在每个 epoch 开始之前，dataloader 从传入的 dataset 中通过 getitem，将初始化时准备好的数据返回。&lt;/p&gt;&#xA;&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#d8dee9;background-color:#2e3440;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-python&#34; data-lang=&#34;python&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#81a1c1;font-weight:bold&#34;&gt;class&lt;/span&gt; &lt;span style=&#34;color:#8fbcbb&#34;&gt;MyDataset&lt;/span&gt;&lt;span style=&#34;color:#eceff4&#34;&gt;(&lt;/span&gt;Dataset&lt;span style=&#34;color:#eceff4&#34;&gt;):&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&#x9;&lt;span style=&#34;color:#81a1c1&#34;&gt;...&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&#x9;&lt;span style=&#34;color:#81a1c1;font-weight:bold&#34;&gt;def&lt;/span&gt; __getitem__&lt;span style=&#34;color:#eceff4&#34;&gt;(&lt;/span&gt;self&lt;span style=&#34;color:#eceff4&#34;&gt;,&lt;/span&gt; idx&lt;span style=&#34;color:#eceff4&#34;&gt;):&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&#x9;&#x9;image &lt;span style=&#34;color:#81a1c1&#34;&gt;=&lt;/span&gt; self&lt;span style=&#34;color:#81a1c1&#34;&gt;.&lt;/span&gt;images&lt;span style=&#34;color:#eceff4&#34;&gt;[&lt;/span&gt;idx&lt;span style=&#34;color:#eceff4&#34;&gt;]&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        label &lt;span style=&#34;color:#81a1c1&#34;&gt;=&lt;/span&gt; self&lt;span style=&#34;color:#81a1c1&#34;&gt;.&lt;/span&gt;labels&lt;span style=&#34;color:#eceff4&#34;&gt;[&lt;/span&gt;idx&lt;span style=&#34;color:#eceff4&#34;&gt;]&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        &lt;span style=&#34;color:#81a1c1;font-weight:bold&#34;&gt;if&lt;/span&gt; self&lt;span style=&#34;color:#81a1c1&#34;&gt;.&lt;/span&gt;transform&lt;span style=&#34;color:#eceff4&#34;&gt;:&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;            image &lt;span style=&#34;color:#81a1c1&#34;&gt;=&lt;/span&gt; self&lt;span style=&#34;color:#81a1c1&#34;&gt;.&lt;/span&gt;transform&lt;span style=&#34;color:#eceff4&#34;&gt;(&lt;/span&gt;image&lt;span style=&#34;color:#eceff4&#34;&gt;)&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        &lt;span style=&#34;color:#81a1c1;font-weight:bold&#34;&gt;return&lt;/span&gt; image&lt;span style=&#34;color:#eceff4&#34;&gt;,&lt;/span&gt; label&#xA;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;而且，这里 transform 将图像转换成 tensor 也花了不少时间。这种与数据增强无关的 transform 显然可以提前处理好。但这里每次读取都要 transform 一遍，很浪费。&lt;/p&gt;&#xA;&lt;p&gt;再来看 dataloader：&lt;/p&gt;&#xA;&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#d8dee9;background-color:#2e3440;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-python&#34; data-lang=&#34;python&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;trainLoader &lt;span style=&#34;color:#81a1c1&#34;&gt;=&lt;/span&gt; Data&lt;span style=&#34;color:#81a1c1&#34;&gt;.&lt;/span&gt;DataLoader&lt;span style=&#34;color:#eceff4&#34;&gt;(&lt;/span&gt;trainSet&lt;span style=&#34;color:#eceff4&#34;&gt;,&lt;/span&gt; batch_size&lt;span style=&#34;color:#81a1c1&#34;&gt;=&lt;/span&gt;batch_size&lt;span style=&#34;color:#eceff4&#34;&gt;,&lt;/span&gt; shuffle&lt;span style=&#34;color:#81a1c1&#34;&gt;=&lt;/span&gt;&lt;span style=&#34;color:#81a1c1;font-weight:bold&#34;&gt;True&lt;/span&gt;&lt;span style=&#34;color:#eceff4&#34;&gt;,&lt;/span&gt; num_workers&lt;span style=&#34;color:#81a1c1&#34;&gt;=&lt;/span&gt;&lt;span style=&#34;color:#b48ead&#34;&gt;16&lt;/span&gt;&lt;span style=&#34;color:#eceff4&#34;&gt;,&lt;/span&gt; drop_last&lt;span style=&#34;color:#81a1c1&#34;&gt;=&lt;/span&gt;&lt;span style=&#34;color:#81a1c1;font-weight:bold&#34;&gt;True&lt;/span&gt;&lt;span style=&#34;color:#eceff4&#34;&gt;)&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;windows 上设置 num_workers 不为 0 时会让数据提供给 cpu，也就是到内存里去。这样我们 getitem 返回的数据又被拷贝了一份。&lt;/p&gt;</description>
    </item>
    <item>
      <title>Python 虚拟环境</title>
      <link>https://huoxj.github.io/posts/python/python-%E8%99%9A%E6%8B%9F%E7%8E%AF%E5%A2%83/</link>
      <pubDate>Thu, 28 Nov 2024 00:00:00 +0000</pubDate>
      <guid>https://huoxj.github.io/posts/python/python-%E8%99%9A%E6%8B%9F%E7%8E%AF%E5%A2%83/</guid>
      <description>&lt;p&gt;对于 Python 来说，环境管理有着十分甚至九分的作用。本文列出一些常用的虚拟环境管理方式，以供参考。&lt;/p&gt;&#xA;&lt;h2 id=&#34;conda&#34;&gt;Conda&lt;/h2&gt;&#xA;&lt;p&gt;最常用的虚拟环境管理器。&lt;/p&gt;&#xA;&lt;h2 id=&#34;venv&#34;&gt;venv&lt;/h2&gt;&#xA;&lt;p&gt;Python 自带的虚拟环境管理器。&lt;/p&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;使用 VSCode&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;p&gt;&lt;code&gt;ctrl + shift + p&lt;/code&gt; 呼出命令面板，搜索 &lt;code&gt;Python: Create Environment&lt;/code&gt;。&lt;/p&gt;&#xA;&lt;p&gt;&lt;img src=&#34;https://runzblog.oss-cn-hangzhou.aliyuncs.com/postimg/202411281445582.png&#34; alt=&#34;&#34;&gt;&lt;/p&gt;&#xA;&lt;p&gt;按步骤来就行。选择 venv 放哪个文件夹、有 requirements.txt 就选。&lt;/p&gt;</description>
    </item>
    <item>
      <title>Lec-1 人机交互概述</title>
      <link>https://huoxj.github.io/posts/%E4%BA%BA%E6%9C%BA%E4%BA%A4%E4%BA%92/lec-1-%E4%BA%BA%E6%9C%BA%E4%BA%A4%E4%BA%92%E6%A6%82%E8%BF%B0/</link>
      <pubDate>Mon, 25 Nov 2024 00:00:00 +0000</pubDate>
      <guid>https://huoxj.github.io/posts/%E4%BA%BA%E6%9C%BA%E4%BA%A4%E4%BA%92/lec-1-%E4%BA%BA%E6%9C%BA%E4%BA%A4%E4%BA%92%E6%A6%82%E8%BF%B0/</guid>
      <description>&lt;h2 id=&#34;术语&#34;&gt;术语&lt;/h2&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;&lt;code&gt;HMI&lt;/code&gt;: Human-Machine Interaction&#xA;&lt;ul&gt;&#xA;&lt;li&gt;&lt;code&gt;MMI&lt;/code&gt;: Man-Machine Interaction&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;&lt;code&gt;HCI&lt;/code&gt;: Human-Computer Interaction&#xA;&lt;ul&gt;&#xA;&lt;li&gt;&lt;code&gt;MCI&lt;/code&gt;: Man&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;&lt;code&gt;CHI&lt;/code&gt;: Computer-Human Interaction&lt;/li&gt;&#xA;&lt;li&gt;&lt;code&gt;UCD&lt;/code&gt;: User-Centered Design&lt;/li&gt;&#xA;&lt;li&gt;&lt;code&gt;HF&lt;/code&gt;: Human Factors&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;h2 id=&#34;人机交互的定义&#34;&gt;人机交互的定义&lt;/h2&gt;&#xA;&lt;p&gt;By ACM&lt;/p&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;HCI is a discipline concerned with the design, evaluation and implementation of interactive computing systems for human use and with the study of major phenomena surrounding them.&lt;/li&gt;&#xA;&lt;li&gt;&#xA;&lt;ol&gt;&#xA;&lt;li&gt;HCI 是一门涉及&lt;strong&gt;人类&lt;/strong&gt;使用的&lt;strong&gt;交互式计算系统&lt;/strong&gt;的&lt;strong&gt;设计、评估和实施&lt;/strong&gt;以及围绕它们的主要&lt;strong&gt;现象&lt;/strong&gt;的研究的学科.&lt;/li&gt;&#xA;&lt;/ol&gt;&#xA;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;h2 id=&#34;hci-研究内容&#34;&gt;HCI 研究内容&lt;/h2&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;U（使⽤用计算机的上下文）&lt;/li&gt;&#xA;&lt;li&gt;H（⼈人的特性）&lt;/li&gt;&#xA;&lt;li&gt;C（计算机系统和⽤用户接口架构）&lt;/li&gt;&#xA;&lt;li&gt;D（开发过程）（&lt;strong&gt;本课重点&lt;/strong&gt;）保证产品开发/交互性能的有效性&#xA;&lt;ul&gt;&#xA;&lt;li&gt;D1：设计方法&lt;/li&gt;&#xA;&lt;li&gt;D2：实现技术与工具&lt;/li&gt;&#xA;&lt;li&gt;D3：评估技术&lt;/li&gt;&#xA;&lt;li&gt;D4：示例系统和样例学习&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;h2 id=&#34;hci-是典型的交叉学科&#34;&gt;HCI 是典型的交叉学科&lt;/h2&gt;&#xA;&lt;p&gt;孤立地从一个学科出发不可能设计出有效的交互式系统&lt;/p&gt;&#xA;&lt;h2 id=&#34;hci-重要性&#34;&gt;HCI 重要性&lt;/h2&gt;&#xA;&lt;h3 id=&#34;市场角度&#34;&gt;市场角度&lt;/h3&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;用户期望简单易用的系统&lt;/li&gt;&#xA;&lt;li&gt;对设计低劣系统的容忍度越来越差&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;h3 id=&#34;企业角度&#34;&gt;企业角度&lt;/h3&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;提高员工的生产效率&lt;/li&gt;&#xA;&lt;li&gt;降低产品的开发成本&lt;/li&gt;&#xA;&lt;li&gt;降低产品的后续支持成本&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;h3 id=&#34;用户角度&#34;&gt;用户角度&lt;/h3&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;获得较高的主观满意度&lt;/li&gt;&#xA;&lt;li&gt;减少时间、金钱、生命损失&lt;/li&gt;&#xA;&lt;/ul&gt;</description>
    </item>
    <item>
      <title>Lec-3 交互设计原则与目标</title>
      <link>https://huoxj.github.io/posts/%E4%BA%BA%E6%9C%BA%E4%BA%A4%E4%BA%92/lec-3-%E4%BA%A4%E4%BA%92%E8%AE%BE%E8%AE%A1%E5%8E%9F%E5%88%99%E4%B8%8E%E7%9B%AE%E6%A0%87/</link>
      <pubDate>Mon, 25 Nov 2024 00:00:00 +0000</pubDate>
      <guid>https://huoxj.github.io/posts/%E4%BA%BA%E6%9C%BA%E4%BA%A4%E4%BA%92/lec-3-%E4%BA%A4%E4%BA%92%E8%AE%BE%E8%AE%A1%E5%8E%9F%E5%88%99%E4%B8%8E%E7%9B%AE%E6%A0%87/</guid>
      <description>&lt;p&gt;不知道为什么没有 Lec-2，往年这个标题是 Lec-2 来着，但是今年老师发的 PPT 直接跳过 2 了。具体什么情况无从知晓，因为上课根本没听嘛。&lt;/p&gt;&#xA;&lt;hr&gt;&#xA;&lt;h2 id=&#34;交互框架&#34;&gt;交互框架&lt;/h2&gt;&#xA;&lt;p&gt;交互框架是提供理解或定义某种事务的一种结构。&lt;/p&gt;&#xA;&lt;p&gt;说白了，就是给交互建模得到的框架。&lt;/p&gt;&#xA;&lt;h2 id=&#34;ecc-框架---执行--评估活动周期&#34;&gt;ECC 框架 - 执行 / 评估活动周期&lt;/h2&gt;&#xA;&lt;p&gt;一种具体的交互框架。PPT 上说是最有名的。&lt;/p&gt;&#xA;&lt;h3 id=&#34;模型基础&#34;&gt;模型基础&lt;/h3&gt;&#xA;&lt;p&gt;ECC 定义了&lt;strong&gt;活动&lt;/strong&gt;的四个组成部分：&lt;/p&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;目标(Goal)&lt;/li&gt;&#xA;&lt;li&gt;执行(Execution)&lt;/li&gt;&#xA;&lt;li&gt;客观因素(World)&lt;/li&gt;&#xA;&lt;li&gt;评估(Evaluation)&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;blockquote&gt;&#xA;&lt;p&gt;目标就是交互要达到的目的，意图可以理解为实现目标的一系列活动。一个目标可以对应多个意图。目标≠意图(Intention)&lt;/p&gt;&#xA;&lt;/blockquote&gt;&#xA;&lt;h3 id=&#34;图示&#34;&gt;图示&lt;/h3&gt;&#xA;&lt;p&gt;&lt;img src=&#34;https://runzblog.oss-cn-hangzhou.aliyuncs.com/postimg/202411251017185.png&#34; alt=&#34;&#34;&gt;&lt;/p&gt;&#xA;&lt;p&gt;图中，每个循环代表一个动作。&lt;/p&gt;&#xA;&lt;p&gt;执行阶段：&lt;/p&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;形成目标&lt;/li&gt;&#xA;&lt;li&gt;形成意图&lt;/li&gt;&#xA;&lt;li&gt;明确动作&lt;/li&gt;&#xA;&lt;li&gt;执行动作&#xA;评估阶段&lt;/li&gt;&#xA;&lt;li&gt;感知系统状态&lt;/li&gt;&#xA;&lt;li&gt;解释系统状态&lt;/li&gt;&#xA;&lt;li&gt;评估输出&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;h3 id=&#34;作用与意义&#34;&gt;作用与意义&lt;/h3&gt;&#xA;&lt;p&gt;ECC 模型可以解释为什么有些交互设计得有问题。因为我们可以从两个阶段进行分析了。&lt;/p&gt;&#xA;&lt;p&gt;在执行阶段出现问题，叫&lt;strong&gt;执行隔阂&lt;/strong&gt;；&lt;/p&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;用户为达到目标而&lt;em&gt;做出的动作&lt;/em&gt;，与系统&lt;em&gt;允许的动作&lt;/em&gt;之间有差别&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;p&gt;评估阶段，&lt;strong&gt;评估隔阂&lt;/strong&gt;。&lt;/p&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;系统状态的&lt;em&gt;实际表现&lt;/em&gt;，与&lt;em&gt;用户预期&lt;/em&gt;之间有差别&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;p&gt;因此，我们分别能从两个阶段知道：&lt;/p&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;如何才能够使用户简单地确定哪些活动是被允许的&lt;/li&gt;&#xA;&lt;li&gt;如何确定系统是否处于期望的运行状态等问题&#xA;也即 ECC 模型的意义所在。圆上这段第一句话了。&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;h2 id=&#34;扩展-ecc-模型&#34;&gt;扩展 ECC 模型&lt;/h2&gt;&#xA;&lt;p&gt;EEC模型不能描述人与系统通过界面进行的通信。&lt;/p&gt;&#xA;&lt;h3 id=&#34;图示-1&#34;&gt;图示&lt;/h3&gt;&#xA;&lt;p&gt;&lt;img src=&#34;https://runzblog.oss-cn-hangzhou.aliyuncs.com/postimg/202411251029727.png&#34; alt=&#34;&#34;&gt;&lt;/p&gt;&#xA;&lt;p&gt;扩展 ECC 模型将交互抽象成了&lt;strong&gt;语言的翻译&lt;/strong&gt;过程。&lt;/p&gt;&#xA;&lt;p&gt;S I O U 意义如下：&lt;/p&gt;&#xA;&lt;table&gt;&#xA;  &lt;thead&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;th style=&#34;text-align: left&#34;&gt;$S$&lt;/th&gt;&#xA;          &lt;th style=&#34;text-align: left&#34;&gt;$U$&lt;/th&gt;&#xA;          &lt;th style=&#34;text-align: left&#34;&gt;$I$&lt;/th&gt;&#xA;          &lt;th style=&#34;text-align: left&#34;&gt;$O$&lt;/th&gt;&#xA;      &lt;/tr&gt;&#xA;  &lt;/thead&gt;&#xA;  &lt;tbody&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;td style=&#34;text-align: left&#34;&gt;系统&lt;/td&gt;&#xA;          &lt;td style=&#34;text-align: left&#34;&gt;用户&lt;/td&gt;&#xA;          &lt;td style=&#34;text-align: left&#34;&gt;输入&lt;/td&gt;&#xA;          &lt;td style=&#34;text-align: left&#34;&gt;输出&lt;/td&gt;&#xA;      &lt;/tr&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;td style=&#34;text-align: left&#34;&gt;内核（核心）语言&lt;/td&gt;&#xA;          &lt;td style=&#34;text-align: left&#34;&gt;任务语言&lt;/td&gt;&#xA;          &lt;td style=&#34;text-align: left&#34;&gt;输入语言&lt;/td&gt;&#xA;          &lt;td style=&#34;text-align: left&#34;&gt;输出语言&lt;/td&gt;&#xA;      &lt;/tr&gt;&#xA;  &lt;/tbody&gt;&#xA;&lt;/table&gt;&#xA;&lt;p&gt;箭头表示翻译过程；图示左侧是系统，右侧是用户。&lt;/p&gt;</description>
    </item>
    <item>
      <title>Lec-4 评估的基础知识</title>
      <link>https://huoxj.github.io/posts/%E4%BA%BA%E6%9C%BA%E4%BA%A4%E4%BA%92/lec-4-%E8%AF%84%E4%BC%B0%E7%9A%84%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/</link>
      <pubDate>Mon, 25 Nov 2024 00:00:00 +0000</pubDate>
      <guid>https://huoxj.github.io/posts/%E4%BA%BA%E6%9C%BA%E4%BA%A4%E4%BA%92/lec-4-%E8%AF%84%E4%BC%B0%E7%9A%84%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/</guid>
      <description>&lt;h2 id=&#34;背景&#34;&gt;背景&lt;/h2&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;评估是设计过程的组成部分&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;h3 id=&#34;评估&#34;&gt;评估&lt;/h3&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;评估是系统化的数据搜集过程&lt;/li&gt;&#xA;&lt;li&gt;用户在与原型、应用程序等交互时收集关于&lt;strong&gt;用户体验&lt;/strong&gt;方面的信息，从而改进其设计&lt;/li&gt;&#xA;&lt;li&gt;评估侧重系统的&lt;strong&gt;可用性&lt;/strong&gt;和&lt;strong&gt;用户体验&lt;/strong&gt;&lt;/li&gt;&#xA;&lt;li&gt;目的不是设法理解用户，而是评估特定用户在一个特定的环境背景中&lt;em&gt;如何使用一个系统来执行一个特定的任务&lt;/em&gt;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;h2 id=&#34;评估的四-w&#34;&gt;评估的四 W&lt;/h2&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;&lt;code&gt;Why&lt;/code&gt;：肯定是要设计一个好的交互系统呀&lt;/li&gt;&#xA;&lt;li&gt;&lt;code&gt;What&lt;/code&gt;：交互系统的可用性和用户体验&lt;/li&gt;&#xA;&lt;li&gt;&lt;code&gt;Where&lt;/code&gt;：取决于评估的对象&lt;/li&gt;&#xA;&lt;li&gt;&lt;code&gt;When&lt;/code&gt;：取决于产品类型。可以在研发前，也可以在完成产品后。&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;hr&gt;&#xA;&lt;h2 id=&#34;评估原则&#34;&gt;评估原则&lt;/h2&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;评估应当依赖产品的用户&lt;/li&gt;&#xA;&lt;li&gt;评估与设计应当结合进行&lt;/li&gt;&#xA;&lt;li&gt;评估应该在用户的实际工作任务和操作环境下进行&lt;/li&gt;&#xA;&lt;li&gt;评估要选择有广泛代表性的用户&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;hr&gt;&#xA;&lt;h2 id=&#34;评估范型&#34;&gt;评估范型&lt;/h2&gt;&#xA;&lt;p&gt;“范型”与“技术”：&lt;/p&gt;&#xA;&lt;ol&gt;&#xA;&lt;li&gt;范型与具体学科相关，对如何评估有很大影响：可用性测试是一种评估范型&lt;/li&gt;&#xA;&lt;li&gt;每种范型有特定的技术：可用性测试的技术有观察、问卷调查、访谈等&lt;/li&gt;&#xA;&lt;/ol&gt;&#xA;&lt;h3 id=&#34;快速评估&#34;&gt;快速评估&lt;/h3&gt;&#xA;&lt;p&gt;设计人员非正式地向用户或顾问了解反馈信息，以证实设计构思是否符合用户需要。&lt;/p&gt;&#xA;&lt;p&gt;&lt;strong&gt;基本特征&lt;/strong&gt;：快速&lt;/p&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;可在任何阶段进行&lt;/li&gt;&#xA;&lt;li&gt;强调 “快速了解”，而非仔细记录研究发现&lt;/li&gt;&#xA;&lt;li&gt;得到的数据通常是非正式、叙述性的&lt;/li&gt;&#xA;&lt;li&gt;是设计网站时常用的方法&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;h3 id=&#34;可用性测试&#34;&gt;可用性测试&lt;/h3&gt;&#xA;&lt;p&gt;&lt;strong&gt;基本特征&lt;/strong&gt;：在评估人员的密切控制之下实行&lt;/p&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;评测典型用户执行典型任务时的情况。并进行量化&lt;/li&gt;&#xA;&lt;li&gt;缺点：测试用户的数量通常较少、不适合进行细致的统计分析&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;h3 id=&#34;实地研究&#34;&gt;实地研究&lt;/h3&gt;&#xA;&lt;p&gt;理解用户的实际工作情形以及技术对他们的影响。&lt;/p&gt;&#xA;&lt;p&gt;&lt;strong&gt;基本特征&lt;/strong&gt;：在自然工作环境中进行&lt;/p&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;探索新技术的应用契机&lt;/li&gt;&#xA;&lt;li&gt;确定产品的需求&lt;/li&gt;&#xA;&lt;li&gt;促进技术的引入&lt;/li&gt;&#xA;&lt;li&gt;评估技术的应用&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;p&gt;难点：&lt;/p&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;如何不对受试者造成影响&lt;/li&gt;&#xA;&lt;li&gt;控制权在用户，很难预测即将发生和出现的情况&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;h3 id=&#34;预测性评估&#34;&gt;预测性评估&lt;/h3&gt;&#xA;&lt;p&gt;研究人员通过想象或对界面的使用过程进行建模。&lt;/p&gt;&#xA;&lt;p&gt;&lt;strong&gt;基本特征&lt;/strong&gt;：用户可以不在场；快速成本低&lt;/p&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;专家们根据自己对典型用户的了解预测可用性问题的可用性评估&lt;/li&gt;&#xA;&lt;li&gt;逐步通过场景或基于问题回答的走查法&lt;/li&gt;&#xA;&lt;li&gt;用于比较相同应用不同界面的原型法，如使用Fitts定律预测使用设备定位目标的时间&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;h2 id=&#34;评估技术&#34;&gt;评估技术&lt;/h2&gt;&#xA;&lt;p&gt;似乎今年 PPT 上没有。但是这肯定&lt;strong&gt;很重要&lt;/strong&gt;，毕竟下列评估方法就是后面几节讲的内容。&lt;/p&gt;&#xA;&lt;h4 id=&#34;内容&#34;&gt;内容&lt;/h4&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;观察用户&lt;/li&gt;&#xA;&lt;li&gt;询问用户意见、专家意见&lt;/li&gt;&#xA;&lt;li&gt;用户测试&lt;/li&gt;&#xA;&lt;li&gt;基于模型和理论评估&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;h4 id=&#34;区分评估技术的因素&#34;&gt;区分评估技术的因素&lt;/h4&gt;&#xA;&lt;ol&gt;&#xA;&lt;li&gt;评估在周期中的位置：设计早期阶段的评估更快速、便宜&lt;/li&gt;&#xA;&lt;li&gt;评估的形式：实验室环境 or 工作环境&lt;/li&gt;&#xA;&lt;li&gt;技术的主客观程度&#xA;&lt;ol&gt;&#xA;&lt;li&gt;技术越主观，受评估人员知识的影响越大，如认知走查等&lt;/li&gt;&#xA;&lt;/ol&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;测量的类型：与技术的主客观性有关&#xA;&lt;ol&gt;&#xA;&lt;li&gt;主观技术：定性数据&lt;/li&gt;&#xA;&lt;li&gt;客观技术：定量数据&lt;/li&gt;&#xA;&lt;/ol&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;提供的信息&#xA;&lt;ol&gt;&#xA;&lt;li&gt;低层信息：这个图标是可理解的吗？&lt;/li&gt;&#xA;&lt;li&gt;高层信息：这个系统是可用的吗？&lt;/li&gt;&#xA;&lt;/ol&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;响应的及时性&#xA;&lt;ol&gt;&#xA;&lt;li&gt;边做边说法可及时记录用户行为&lt;/li&gt;&#xA;&lt;li&gt;任务后的走查取决于对事件的回忆&lt;/li&gt;&#xA;&lt;/ol&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;干扰程度：直接响应测量可能会影响用户表现&lt;/li&gt;&#xA;&lt;li&gt;所需资源：设备、时间、资金、参与者、评估人员的专业技术及环境等&lt;/li&gt;&#xA;&lt;/ol&gt;&#xA;&lt;hr&gt;&#xA;&lt;h2 id=&#34;评估方法组合&#34;&gt;评估方法组合&lt;/h2&gt;&#xA;&lt;p&gt;评估方法的组合取决于项目待评估的具体特性。&lt;/p&gt;</description>
    </item>
    <item>
      <title>OO-继承与派生</title>
      <link>https://huoxj.github.io/posts/c&#43;&#43;%E6%8B%BE%E9%81%97/oo-%E7%BB%A7%E6%89%BF%E4%B8%8E%E6%B4%BE%E7%94%9F/</link>
      <pubDate>Thu, 21 Nov 2024 00:00:00 +0000</pubDate>
      <guid>https://huoxj.github.io/posts/c&#43;&#43;%E6%8B%BE%E9%81%97/oo-%E7%BB%A7%E6%89%BF%E4%B8%8E%E6%B4%BE%E7%94%9F/</guid>
      <description>&lt;h2 id=&#34;前言&#34;&gt;前言&lt;/h2&gt;&#xA;&lt;p&gt;考试必考。所以在网上找一些笔记，记下有价值的部分以供复习。&lt;/p&gt;&#xA;&lt;p&gt;继承和派生这对名词基本是一个意思，只是各自用语习惯不一样：&lt;/p&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;继承 —— 基类 —— 派生类&lt;/li&gt;&#xA;&lt;li&gt;派生 —— 基类 —— 派生类&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;p&gt;OO 是 Java 学的，所以我倾向于第一种表达。&lt;/p&gt;&#xA;&lt;h2 id=&#34;继承权限&#34;&gt;继承权限&lt;/h2&gt;&#xA;&lt;h3 id=&#34;继承方式&#34;&gt;继承方式&lt;/h3&gt;&#xA;&lt;p&gt;C++ 很神奇地提供了三种继承方式：public、private 和 protected。&lt;/p&gt;&#xA;&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#d8dee9;background-color:#2e3440;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-cpp&#34; data-lang=&#34;cpp&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#81a1c1;font-weight:bold&#34;&gt;class&lt;/span&gt; &lt;span style=&#34;color:#8fbcbb&#34;&gt;parent&lt;/span&gt;&lt;span style=&#34;color:#eceff4&#34;&gt;{};&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#81a1c1;font-weight:bold&#34;&gt;class&lt;/span&gt; &lt;span style=&#34;color:#8fbcbb&#34;&gt;child1&lt;/span&gt;&lt;span style=&#34;color:#81a1c1&#34;&gt;:&lt;/span&gt; &lt;span style=&#34;color:#81a1c1;font-weight:bold&#34;&gt;public&lt;/span&gt; parent&lt;span style=&#34;color:#eceff4&#34;&gt;{};&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#81a1c1;font-weight:bold&#34;&gt;class&lt;/span&gt; &lt;span style=&#34;color:#8fbcbb&#34;&gt;child2&lt;/span&gt;&lt;span style=&#34;color:#81a1c1&#34;&gt;:&lt;/span&gt; &lt;span style=&#34;color:#81a1c1;font-weight:bold&#34;&gt;protected&lt;/span&gt; parent&lt;span style=&#34;color:#eceff4&#34;&gt;{};&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#81a1c1;font-weight:bold&#34;&gt;class&lt;/span&gt; &lt;span style=&#34;color:#8fbcbb&#34;&gt;child3&lt;/span&gt;&lt;span style=&#34;color:#81a1c1&#34;&gt;:&lt;/span&gt; &lt;span style=&#34;color:#81a1c1;font-weight:bold&#34;&gt;private&lt;/span&gt; parent&lt;span style=&#34;color:#eceff4&#34;&gt;{};&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;继承方式决定了基类成员在派生类中的访问权限，权限高于继承方式的会被限制。&lt;/p&gt;&#xA;&lt;p&gt;比如 protected 继承会将基类中 public 的成员变成 protected。&lt;/p&gt;&#xA;&lt;h3 id=&#34;修改基类成员的访问权限&#34;&gt;修改基类成员的访问权限&lt;/h3&gt;&#xA;&lt;p&gt;使用 using 关键字可以修改基类成员在派生类中的访问权限。权限提高和降低都没问题。&lt;/p&gt;&#xA;&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#d8dee9;background-color:#2e3440;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-cpp&#34; data-lang=&#34;cpp&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#81a1c1;font-weight:bold&#34;&gt;class&lt;/span&gt; &lt;span style=&#34;color:#8fbcbb&#34;&gt;parent&lt;/span&gt;&lt;span style=&#34;color:#eceff4&#34;&gt;{&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#81a1c1;font-weight:bold&#34;&gt;protected&lt;/span&gt;&lt;span style=&#34;color:#81a1c1&#34;&gt;:&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&#x9;&lt;span style=&#34;color:#81a1c1&#34;&gt;int&lt;/span&gt; element&lt;span style=&#34;color:#eceff4&#34;&gt;;&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#eceff4&#34;&gt;};&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#81a1c1;font-weight:bold&#34;&gt;class&lt;/span&gt; &lt;span style=&#34;color:#8fbcbb&#34;&gt;child&lt;/span&gt;&lt;span style=&#34;color:#eceff4&#34;&gt;{&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#81a1c1;font-weight:bold&#34;&gt;public&lt;/span&gt;&lt;span style=&#34;color:#81a1c1&#34;&gt;:&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&#x9;&lt;span style=&#34;color:#81a1c1;font-weight:bold&#34;&gt;using&lt;/span&gt; parent&lt;span style=&#34;color:#81a1c1&#34;&gt;::&lt;/span&gt;element&lt;span style=&#34;color:#eceff4&#34;&gt;;&lt;/span&gt;    &lt;span style=&#34;color:#616e87;font-style:italic&#34;&gt;// protected -&amp;gt; public&#xA;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#616e87;font-style:italic&#34;&gt;&lt;/span&gt;&lt;span style=&#34;color:#81a1c1;font-weight:bold&#34;&gt;private&lt;/span&gt;&lt;span style=&#34;color:#81a1c1&#34;&gt;:&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&#x9;&lt;span style=&#34;color:#81a1c1;font-weight:bold&#34;&gt;using&lt;/span&gt; parent&lt;span style=&#34;color:#81a1c1&#34;&gt;::&lt;/span&gt;element&lt;span style=&#34;color:#eceff4&#34;&gt;;&lt;/span&gt;    &lt;span style=&#34;color:#616e87;font-style:italic&#34;&gt;// protected -&amp;gt; private&#xA;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#616e87;font-style:italic&#34;&gt;&lt;/span&gt;&lt;span style=&#34;color:#eceff4&#34;&gt;}&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;h2 id=&#34;成员覆盖&#34;&gt;成员覆盖&lt;/h2&gt;&#xA;&lt;p&gt;继承中的成员覆盖问题，本质是作用域的问题。&lt;/p&gt;&#xA;&lt;p&gt;通过派生类访问成员时，首先会在派生类的作用域下寻找这个名字的成员。如果没找到，再到基类的作用域里找。&lt;/p&gt;&#xA;&lt;p&gt;主要注意以下情景：&lt;/p&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;派生类同名成员变量访问权限低于基类时&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#d8dee9;background-color:#2e3440;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-cpp&#34; data-lang=&#34;cpp&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;parent&lt;span style=&#34;color:#eceff4&#34;&gt;{&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#81a1c1;font-weight:bold&#34;&gt;public&lt;/span&gt;&lt;span style=&#34;color:#81a1c1&#34;&gt;:&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&#x9;&lt;span style=&#34;color:#81a1c1&#34;&gt;int&lt;/span&gt; a&lt;span style=&#34;color:#eceff4&#34;&gt;;&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#eceff4&#34;&gt;};&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;child&lt;span style=&#34;color:#eceff4&#34;&gt;{&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#81a1c1;font-weight:bold&#34;&gt;private&lt;/span&gt;&lt;span style=&#34;color:#81a1c1&#34;&gt;:&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&#x9;&lt;span style=&#34;color:#81a1c1&#34;&gt;int&lt;/span&gt; a&lt;span style=&#34;color:#eceff4&#34;&gt;;&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#eceff4&#34;&gt;}&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;child c&lt;span style=&#34;color:#eceff4&#34;&gt;;&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;c&lt;span style=&#34;color:#eceff4&#34;&gt;.&lt;/span&gt;a&lt;span style=&#34;color:#eceff4&#34;&gt;;&lt;/span&gt;         &lt;span style=&#34;color:#616e87;font-style:italic&#34;&gt;// cannot access a.&#xA;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#616e87;font-style:italic&#34;&gt;&lt;/span&gt;c&lt;span style=&#34;color:#eceff4&#34;&gt;.&lt;/span&gt;parent&lt;span style=&#34;color:#eceff4&#34;&gt;.&lt;/span&gt;a&lt;span style=&#34;color:#eceff4&#34;&gt;;&lt;/span&gt;  &lt;span style=&#34;color:#616e87;font-style:italic&#34;&gt;// ok&#xA;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;ul&gt;&#xA;&lt;li&gt;派生类与基类不会发生函数重载&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#d8dee9;background-color:#2e3440;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-cpp&#34; data-lang=&#34;cpp&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;parent&lt;span style=&#34;color:#eceff4&#34;&gt;{&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&#x9;&lt;span style=&#34;color:#81a1c1&#34;&gt;void&lt;/span&gt; &lt;span style=&#34;color:#88c0d0&#34;&gt;foo&lt;/span&gt;&lt;span style=&#34;color:#eceff4&#34;&gt;(&lt;/span&gt;&lt;span style=&#34;color:#81a1c1&#34;&gt;int&lt;/span&gt; a&lt;span style=&#34;color:#eceff4&#34;&gt;);&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#eceff4&#34;&gt;};&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;child&lt;span style=&#34;color:#eceff4&#34;&gt;{&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&#x9;&lt;span style=&#34;color:#81a1c1&#34;&gt;void&lt;/span&gt; &lt;span style=&#34;color:#88c0d0&#34;&gt;foo&lt;/span&gt;&lt;span style=&#34;color:#eceff4&#34;&gt;(&lt;/span&gt;&lt;span style=&#34;color:#81a1c1&#34;&gt;double&lt;/span&gt; a&lt;span style=&#34;color:#eceff4&#34;&gt;);&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#eceff4&#34;&gt;}&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;child c&lt;span style=&#34;color:#eceff4&#34;&gt;;&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#81a1c1&#34;&gt;int&lt;/span&gt; a&lt;span style=&#34;color:#eceff4&#34;&gt;;&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;c&lt;span style=&#34;color:#eceff4&#34;&gt;.&lt;/span&gt;foo&lt;span style=&#34;color:#eceff4&#34;&gt;(&lt;/span&gt;a&lt;span style=&#34;color:#eceff4&#34;&gt;);&lt;/span&gt;          &lt;span style=&#34;color:#616e87;font-style:italic&#34;&gt;// double&#xA;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#616e87;font-style:italic&#34;&gt;&lt;/span&gt;c&lt;span style=&#34;color:#eceff4&#34;&gt;.&lt;/span&gt;parent&lt;span style=&#34;color:#81a1c1&#34;&gt;::&lt;/span&gt;foo&lt;span style=&#34;color:#eceff4&#34;&gt;(&lt;/span&gt;a&lt;span style=&#34;color:#eceff4&#34;&gt;);&lt;/span&gt;  &lt;span style=&#34;color:#616e87;font-style:italic&#34;&gt;// int&#xA;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;h2 id=&#34;构造函数&#34;&gt;构造函数&lt;/h2&gt;&#xA;&lt;p&gt;构造函数无法继承。&lt;/p&gt;</description>
    </item>
    <item>
      <title>南京-幕府山-24-11</title>
      <link>https://huoxj.github.io/posts/%E6%B8%B8%E8%AE%B0/%E5%8D%97%E4%BA%AC-%E5%B9%95%E5%BA%9C%E5%B1%B1-24-11/</link>
      <pubDate>Thu, 21 Nov 2024 00:00:00 +0000</pubDate>
      <guid>https://huoxj.github.io/posts/%E6%B8%B8%E8%AE%B0/%E5%8D%97%E4%BA%AC-%E5%B9%95%E5%BA%9C%E5%B1%B1-24-11/</guid>
      <description>&lt;h2 id=&#34;起因&#34;&gt;起因&lt;/h2&gt;</description>
    </item>
    <item>
      <title>OO 杂项</title>
      <link>https://huoxj.github.io/posts/c&#43;&#43;%E6%8B%BE%E9%81%97/oo-%E6%9D%82%E9%A1%B9/</link>
      <pubDate>Wed, 20 Nov 2024 00:00:00 +0000</pubDate>
      <guid>https://huoxj.github.io/posts/c&#43;&#43;%E6%8B%BE%E9%81%97/oo-%E6%9D%82%E9%A1%B9/</guid>
      <description>&lt;h2 id=&#34;类的内存模型&#34;&gt;类的内存模型&lt;/h2&gt;&#xA;&lt;p&gt;&lt;a href=&#34;https://nimrod.blog/posts/what-does-cpp-object-layout-look-like/&#34;&gt;What does C++ Object Layout Look Like? | Nimrod&amp;rsquo;s Coding Lab&lt;/a&gt;&lt;/p&gt;&#xA;&lt;h2 id=&#34;空类默认提供的方法&#34;&gt;空类默认提供的方法&lt;/h2&gt;&#xA;&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#d8dee9;background-color:#2e3440;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-cpp&#34; data-lang=&#34;cpp&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#81a1c1;font-weight:bold&#34;&gt;class&lt;/span&gt; &lt;span style=&#34;color:#8fbcbb&#34;&gt;T&lt;/span&gt; &lt;span style=&#34;color:#eceff4&#34;&gt;{};&lt;/span&gt;  &#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#81a1c1;font-weight:bold&#34;&gt;class&lt;/span&gt; &lt;span style=&#34;color:#8fbcbb&#34;&gt;T&lt;/span&gt; &lt;span style=&#34;color:#eceff4&#34;&gt;{&lt;/span&gt;  &#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&#x9;T&lt;span style=&#34;color:#eceff4&#34;&gt;();&lt;/span&gt;                            &lt;span style=&#34;color:#616e87;font-style:italic&#34;&gt;// 构造函数&#xA;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#616e87;font-style:italic&#34;&gt;&lt;/span&gt;&#x9;T&lt;span style=&#34;color:#eceff4&#34;&gt;(&lt;/span&gt;&lt;span style=&#34;color:#81a1c1;font-weight:bold&#34;&gt;const&lt;/span&gt; T&lt;span style=&#34;color:#81a1c1&#34;&gt;&amp;amp;&lt;/span&gt;&lt;span style=&#34;color:#eceff4&#34;&gt;);&lt;/span&gt;                    &lt;span style=&#34;color:#616e87;font-style:italic&#34;&gt;// 拷贝构造&#xA;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#616e87;font-style:italic&#34;&gt;&lt;/span&gt;&#x9;T&lt;span style=&#34;color:#eceff4&#34;&gt;(&lt;/span&gt;&lt;span style=&#34;color:#81a1c1;font-weight:bold&#34;&gt;const&lt;/span&gt; T&lt;span style=&#34;color:#81a1c1&#34;&gt;&amp;amp;&amp;amp;&lt;/span&gt;&lt;span style=&#34;color:#eceff4&#34;&gt;);&lt;/span&gt;                   &lt;span style=&#34;color:#616e87;font-style:italic&#34;&gt;// 拷贝构造 rval&#xA;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#616e87;font-style:italic&#34;&gt;&lt;/span&gt;&#x9;&lt;span style=&#34;color:#81a1c1&#34;&gt;~&lt;/span&gt;T&lt;span style=&#34;color:#eceff4&#34;&gt;();&lt;/span&gt;                           &lt;span style=&#34;color:#616e87;font-style:italic&#34;&gt;// 析构函数&#xA;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#616e87;font-style:italic&#34;&gt;&lt;/span&gt;&#x9;T&lt;span style=&#34;color:#81a1c1&#34;&gt;&amp;amp;&lt;/span&gt; &lt;span style=&#34;color:#81a1c1;font-weight:bold&#34;&gt;operator&lt;/span&gt;&lt;span style=&#34;color:#81a1c1&#34;&gt;=&lt;/span&gt;&lt;span style=&#34;color:#eceff4&#34;&gt;(&lt;/span&gt;&lt;span style=&#34;color:#81a1c1;font-weight:bold&#34;&gt;const&lt;/span&gt; T&lt;span style=&#34;color:#81a1c1&#34;&gt;&amp;amp;&lt;/span&gt;&lt;span style=&#34;color:#eceff4&#34;&gt;);&lt;/span&gt;         &lt;span style=&#34;color:#616e87;font-style:italic&#34;&gt;// 拷贝赋值&#xA;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#616e87;font-style:italic&#34;&gt;&lt;/span&gt;&#x9;T&lt;span style=&#34;color:#81a1c1&#34;&gt;&amp;amp;&lt;/span&gt; &lt;span style=&#34;color:#81a1c1;font-weight:bold&#34;&gt;operator&lt;/span&gt;&lt;span style=&#34;color:#81a1c1&#34;&gt;=&lt;/span&gt;&lt;span style=&#34;color:#eceff4&#34;&gt;(&lt;/span&gt;&lt;span style=&#34;color:#81a1c1;font-weight:bold&#34;&gt;const&lt;/span&gt; T&lt;span style=&#34;color:#81a1c1&#34;&gt;&amp;amp;&amp;amp;&lt;/span&gt;&lt;span style=&#34;color:#eceff4&#34;&gt;);&lt;/span&gt;        &lt;span style=&#34;color:#616e87;font-style:italic&#34;&gt;// 拷贝赋值 rval&#xA;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#616e87;font-style:italic&#34;&gt;&lt;/span&gt;&#x9;T &lt;span style=&#34;color:#81a1c1&#34;&gt;*&lt;/span&gt;&lt;span style=&#34;color:#81a1c1;font-weight:bold&#34;&gt;operator&lt;/span&gt; &lt;span style=&#34;color:#81a1c1&#34;&gt;&amp;amp;&lt;/span&gt;&lt;span style=&#34;color:#eceff4&#34;&gt;();&lt;/span&gt;                &lt;span style=&#34;color:#616e87;font-style:italic&#34;&gt;// 取地址&#xA;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#616e87;font-style:italic&#34;&gt;&lt;/span&gt;&#x9;&lt;span style=&#34;color:#81a1c1;font-weight:bold&#34;&gt;const&lt;/span&gt; T&lt;span style=&#34;color:#81a1c1&#34;&gt;*&lt;/span&gt; &lt;span style=&#34;color:#81a1c1;font-weight:bold&#34;&gt;operator&lt;/span&gt; &lt;span style=&#34;color:#81a1c1&#34;&gt;&amp;amp;&lt;/span&gt;&lt;span style=&#34;color:#eceff4&#34;&gt;()&lt;/span&gt; &lt;span style=&#34;color:#81a1c1;font-weight:bold&#34;&gt;const&lt;/span&gt;&lt;span style=&#34;color:#eceff4&#34;&gt;;&lt;/span&gt;    &lt;span style=&#34;color:#616e87;font-style:italic&#34;&gt;// 取地址 const 重载版&#xA;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#616e87;font-style:italic&#34;&gt;&lt;/span&gt;&lt;span style=&#34;color:#eceff4&#34;&gt;};&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;最后两个函数比较怪。一个是返回非 const 的指针，另一个返回 const 的。在调用时，编译器如何决定调用哪个呢？&lt;/p&gt;&#xA;&lt;p&gt;注意函数后的 const 修饰符。这两个函数实际应该长这样：&lt;/p&gt;&#xA;&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#d8dee9;background-color:#2e3440;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-cpp&#34; data-lang=&#34;cpp&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;T &lt;span style=&#34;color:#81a1c1&#34;&gt;*&lt;/span&gt;&lt;span style=&#34;color:#81a1c1;font-weight:bold&#34;&gt;operator&lt;/span&gt; &lt;span style=&#34;color:#81a1c1&#34;&gt;&amp;amp;&lt;/span&gt;&lt;span style=&#34;color:#eceff4&#34;&gt;(&lt;/span&gt;T &lt;span style=&#34;color:#81a1c1&#34;&gt;*&lt;/span&gt;&lt;span style=&#34;color:#81a1c1;font-weight:bold&#34;&gt;this&lt;/span&gt;&lt;span style=&#34;color:#eceff4&#34;&gt;);&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#81a1c1;font-weight:bold&#34;&gt;const&lt;/span&gt; T&lt;span style=&#34;color:#81a1c1&#34;&gt;*&lt;/span&gt; &lt;span style=&#34;color:#81a1c1;font-weight:bold&#34;&gt;operator&lt;/span&gt; &lt;span style=&#34;color:#81a1c1&#34;&gt;&amp;amp;&lt;/span&gt;&lt;span style=&#34;color:#eceff4&#34;&gt;(&lt;/span&gt;&lt;span style=&#34;color:#81a1c1;font-weight:bold&#34;&gt;const&lt;/span&gt; T &lt;span style=&#34;color:#81a1c1&#34;&gt;*&lt;/span&gt;&lt;span style=&#34;color:#81a1c1;font-weight:bold&#34;&gt;this&lt;/span&gt;&lt;span style=&#34;color:#eceff4&#34;&gt;);&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;是 this 指针的功劳。调用方是哪种就执行哪个。&lt;/p&gt;&#xA;&lt;h2 id=&#34;const-与-static-成员&#34;&gt;const 与 static 成员&lt;/h2&gt;&#xA;&lt;h3 id=&#34;static-const-成员变量&#34;&gt;static const 成员变量&lt;/h3&gt;&#xA;&lt;p&gt;对于成员变量，变量会在&lt;strong&gt;编译期&lt;/strong&gt;确定，并被放到程序静态区。运行时，这个成员和类与对象在内存上没有关系，但是要通过类名来访问。&lt;/p&gt;</description>
    </item>
    <item>
      <title>杂项</title>
      <link>https://huoxj.github.io/posts/c&#43;&#43;%E6%8B%BE%E9%81%97/%E6%9D%82%E9%A1%B9/</link>
      <pubDate>Sun, 17 Nov 2024 00:00:00 +0000</pubDate>
      <guid>https://huoxj.github.io/posts/c&#43;&#43;%E6%8B%BE%E9%81%97/%E6%9D%82%E9%A1%B9/</guid>
      <description>&lt;h2 id=&#34;raii--智能指针&#34;&gt;RAII &amp;amp; 智能指针&lt;/h2&gt;&#xA;&lt;h3 id=&#34;raii&#34;&gt;RAII&lt;/h3&gt;&#xA;&lt;p&gt;RAII： Resource acquisition is initialization&lt;/p&gt;&#xA;&lt;p&gt;将资源管理交给其本身的思想。&lt;/p&gt;&#xA;&lt;p&gt;尽量使用对象的生命周期来管理资源，初始化时调用构造函数进行资源分配，离开作用域时自动调用析构函数释放资源。而不是自己来管理资源的分配与释放。&lt;/p&gt;&#xA;&lt;h3 id=&#34;智能指针&#34;&gt;智能指针&lt;/h3&gt;&#xA;&lt;p&gt;所以很自然想到智能指针：&lt;/p&gt;&#xA;&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#d8dee9;background-color:#2e3440;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-cpp&#34; data-lang=&#34;cpp&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#81a1c1;font-weight:bold&#34;&gt;template&lt;/span&gt;&lt;span style=&#34;color:#81a1c1&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span style=&#34;color:#81a1c1;font-weight:bold&#34;&gt;class&lt;/span&gt; &lt;span style=&#34;color:#8fbcbb&#34;&gt;T&lt;/span&gt;&lt;span style=&#34;color:#81a1c1&#34;&gt;&amp;gt;&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#81a1c1;font-weight:bold&#34;&gt;class&lt;/span&gt; &lt;span style=&#34;color:#8fbcbb&#34;&gt;auto_ptr&lt;/span&gt;&lt;span style=&#34;color:#eceff4&#34;&gt;{&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&#x9;&lt;span style=&#34;color:#81a1c1;font-weight:bold&#34;&gt;public&lt;/span&gt;&lt;span style=&#34;color:#81a1c1&#34;&gt;:&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&#x9;&#x9;auto_ptr&lt;span style=&#34;color:#eceff4&#34;&gt;(&lt;/span&gt;T &lt;span style=&#34;color:#81a1c1&#34;&gt;*&lt;/span&gt;p&lt;span style=&#34;color:#81a1c1&#34;&gt;=&lt;/span&gt;&lt;span style=&#34;color:#b48ead&#34;&gt;0&lt;/span&gt;&lt;span style=&#34;color:#eceff4&#34;&gt;)&lt;/span&gt;&lt;span style=&#34;color:#81a1c1&#34;&gt;:&lt;/span&gt;ptr&lt;span style=&#34;color:#eceff4&#34;&gt;(&lt;/span&gt;p&lt;span style=&#34;color:#eceff4&#34;&gt;)&lt;/span&gt; &lt;span style=&#34;color:#eceff4&#34;&gt;{}&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&#x9;&#x9;&lt;span style=&#34;color:#81a1c1&#34;&gt;~&lt;/span&gt;auto_ptr&lt;span style=&#34;color:#eceff4&#34;&gt;()&lt;/span&gt; &lt;span style=&#34;color:#eceff4&#34;&gt;{&lt;/span&gt; &lt;span style=&#34;color:#81a1c1;font-weight:bold&#34;&gt;delete&lt;/span&gt; ptr&lt;span style=&#34;color:#eceff4&#34;&gt;;&lt;/span&gt; &lt;span style=&#34;color:#eceff4&#34;&gt;}&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&#x9;&#x9;T&lt;span style=&#34;color:#81a1c1&#34;&gt;*&lt;/span&gt; &lt;span style=&#34;color:#81a1c1;font-weight:bold&#34;&gt;operator&lt;/span&gt;&lt;span style=&#34;color:#81a1c1&#34;&gt;-&amp;gt;&lt;/span&gt;&lt;span style=&#34;color:#eceff4&#34;&gt;()&lt;/span&gt; &lt;span style=&#34;color:#81a1c1;font-weight:bold&#34;&gt;const&lt;/span&gt; &lt;span style=&#34;color:#eceff4&#34;&gt;{&lt;/span&gt; &lt;span style=&#34;color:#81a1c1;font-weight:bold&#34;&gt;return&lt;/span&gt; ptr&lt;span style=&#34;color:#eceff4&#34;&gt;;&lt;/span&gt; &lt;span style=&#34;color:#eceff4&#34;&gt;}&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&#x9;&#x9;T&lt;span style=&#34;color:#81a1c1&#34;&gt;&amp;amp;&lt;/span&gt; &lt;span style=&#34;color:#81a1c1;font-weight:bold&#34;&gt;operator&lt;/span&gt; &lt;span style=&#34;color:#81a1c1&#34;&gt;*&lt;/span&gt;&lt;span style=&#34;color:#eceff4&#34;&gt;()&lt;/span&gt; &lt;span style=&#34;color:#81a1c1;font-weight:bold&#34;&gt;const&lt;/span&gt; &lt;span style=&#34;color:#eceff4&#34;&gt;{&lt;/span&gt; &lt;span style=&#34;color:#81a1c1;font-weight:bold&#34;&gt;return&lt;/span&gt; &lt;span style=&#34;color:#81a1c1&#34;&gt;*&lt;/span&gt;ptr&lt;span style=&#34;color:#eceff4&#34;&gt;;&lt;/span&gt; &lt;span style=&#34;color:#eceff4&#34;&gt;}&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&#x9;&lt;span style=&#34;color:#81a1c1;font-weight:bold&#34;&gt;private&lt;/span&gt;&lt;span style=&#34;color:#81a1c1&#34;&gt;:&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&#x9;&#x9;T&lt;span style=&#34;color:#81a1c1&#34;&gt;*&lt;/span&gt; ptr&lt;span style=&#34;color:#eceff4&#34;&gt;;&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#eceff4&#34;&gt;}&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;这种手搓的是会出问题的。比如拷贝构造后，两个智能指针对象指向同一块内存，会导致这块内存被析构函数释放两次。&lt;/p&gt;&#xA;&lt;h3 id=&#34;标准库智能指针&#34;&gt;标准库智能指针&lt;/h3&gt;&#xA;&lt;p&gt;头文件：&lt;code&gt;#include &amp;lt;memory&amp;gt;&lt;/code&gt;&lt;/p&gt;&#xA;&lt;h4 id=&#34;auto_ptr&#34;&gt;auto_ptr&lt;/h4&gt;&#xA;&lt;p&gt;和手搓的基本一样。代码不是很复杂的情况下用这个就行。&lt;/p&gt;&#xA;&lt;h4 id=&#34;unique_ptr&#34;&gt;unique_ptr&lt;/h4&gt;&#xA;&lt;p&gt;独占所有权的指针。就是说，unique_ptr 指向的内存只能被它一个人占有。同一时间内只会有一个 unique_ptr 指向同一块内存。&lt;/p&gt;&#xA;&lt;p&gt;这建立在你完全使用 unique_ptr 提供的接口的情况之上。也就是说完全有办法让两个 unique_ptr 指向同一块内存。&lt;/p&gt;&#xA;&lt;p&gt;C++14 以后，使用 &lt;code&gt;std::make_unique&lt;/code&gt; 来创建 unique_ptr。&lt;/p&gt;&#xA;&lt;p&gt;特点是：&lt;/p&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;不允许拷贝构造&lt;/li&gt;&#xA;&lt;li&gt;支持移动语义&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#d8dee9;background-color:#2e3440;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-cpp&#34; data-lang=&#34;cpp&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#81a1c1;font-weight:bold&#34;&gt;using&lt;/span&gt; int_ptr&lt;span style=&#34;color:#81a1c1&#34;&gt;=&lt;/span&gt;std&lt;span style=&#34;color:#81a1c1&#34;&gt;::&lt;/span&gt;unique_ptr&lt;span style=&#34;color:#81a1c1&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span style=&#34;color:#81a1c1&#34;&gt;int&lt;/span&gt;&lt;span style=&#34;color:#81a1c1&#34;&gt;&amp;gt;&lt;/span&gt;&lt;span style=&#34;color:#eceff4&#34;&gt;;&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#81a1c1&#34;&gt;int&lt;/span&gt; &lt;span style=&#34;color:#81a1c1&#34;&gt;*&lt;/span&gt;ptr &lt;span style=&#34;color:#81a1c1&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#81a1c1;font-weight:bold&#34;&gt;new&lt;/span&gt; &lt;span style=&#34;color:#81a1c1&#34;&gt;int&lt;/span&gt;&lt;span style=&#34;color:#eceff4&#34;&gt;(&lt;/span&gt;&lt;span style=&#34;color:#b48ead&#34;&gt;5&lt;/span&gt;&lt;span style=&#34;color:#eceff4&#34;&gt;);&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;int_ptr &lt;span style=&#34;color:#88c0d0&#34;&gt;p&lt;/span&gt;&lt;span style=&#34;color:#eceff4&#34;&gt;(&lt;/span&gt;ptr&lt;span style=&#34;color:#eceff4&#34;&gt;);&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;int_ptr p_ &lt;span style=&#34;color:#81a1c1&#34;&gt;=&lt;/span&gt; std&lt;span style=&#34;color:#81a1c1&#34;&gt;::&lt;/span&gt;make_unique&lt;span style=&#34;color:#81a1c1&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span style=&#34;color:#81a1c1&#34;&gt;int&lt;/span&gt;&lt;span style=&#34;color:#81a1c1&#34;&gt;&amp;gt;&lt;/span&gt;&lt;span style=&#34;color:#eceff4&#34;&gt;(&lt;/span&gt;&lt;span style=&#34;color:#b48ead&#34;&gt;5&lt;/span&gt;&lt;span style=&#34;color:#eceff4&#34;&gt;);&lt;/span&gt;  &lt;span style=&#34;color:#616e87;font-style:italic&#34;&gt;// In c++14&#xA;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#616e87;font-style:italic&#34;&gt;&lt;/span&gt;cout&lt;span style=&#34;color:#81a1c1&#34;&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span style=&#34;color:#81a1c1&#34;&gt;*&lt;/span&gt;p &lt;span style=&#34;color:#81a1c1&#34;&gt;&amp;lt;&amp;lt;&lt;/span&gt; endl&lt;span style=&#34;color:#eceff4&#34;&gt;;&lt;/span&gt;  &lt;span style=&#34;color:#616e87;font-style:italic&#34;&gt;// 5&#xA;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#616e87;font-style:italic&#34;&gt;&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;int_ptr q &lt;span style=&#34;color:#81a1c1&#34;&gt;=&lt;/span&gt; p&lt;span style=&#34;color:#eceff4&#34;&gt;;&lt;/span&gt;  &lt;span style=&#34;color:#616e87;font-style:italic&#34;&gt;// you can not clone unique_ptr!!!&#xA;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#616e87;font-style:italic&#34;&gt;&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;int_ptr &lt;span style=&#34;color:#88c0d0&#34;&gt;r&lt;/span&gt;&lt;span style=&#34;color:#eceff4&#34;&gt;(&lt;/span&gt;std&lt;span style=&#34;color:#81a1c1&#34;&gt;::&lt;/span&gt;move&lt;span style=&#34;color:#eceff4&#34;&gt;(&lt;/span&gt;p&lt;span style=&#34;color:#eceff4&#34;&gt;));&lt;/span&gt;  &lt;span style=&#34;color:#616e87;font-style:italic&#34;&gt;// move semantic&#xA;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#616e87;font-style:italic&#34;&gt;&lt;/span&gt;cout&lt;span style=&#34;color:#81a1c1&#34;&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span style=&#34;color:#81a1c1&#34;&gt;*&lt;/span&gt;r &lt;span style=&#34;color:#81a1c1&#34;&gt;&amp;lt;&amp;lt;&lt;/span&gt; endl&lt;span style=&#34;color:#eceff4&#34;&gt;;&lt;/span&gt;  &lt;span style=&#34;color:#616e87;font-style:italic&#34;&gt;// 5&#xA;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#616e87;font-style:italic&#34;&gt;&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;int_ptr &lt;span style=&#34;color:#88c0d0&#34;&gt;s&lt;/span&gt;&lt;span style=&#34;color:#eceff4&#34;&gt;(&lt;/span&gt;ptr&lt;span style=&#34;color:#eceff4&#34;&gt;);&lt;/span&gt;  &lt;span style=&#34;color:#616e87;font-style:italic&#34;&gt;// this will cause double free!!!&#xA;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;h4 id=&#34;shared_ptr&#34;&gt;shared_ptr&lt;/h4&gt;&#xA;&lt;p&gt;含引用计数的指针。这样就可以实现多个指针指向同一对象了。&lt;/p&gt;</description>
    </item>
    <item>
      <title>可变参数</title>
      <link>https://huoxj.github.io/posts/c&#43;&#43;%E6%8B%BE%E9%81%97/%E5%8F%AF%E5%8F%98%E5%8F%82%E6%95%B0/</link>
      <pubDate>Fri, 15 Nov 2024 00:00:00 +0000</pubDate>
      <guid>https://huoxj.github.io/posts/c&#43;&#43;%E6%8B%BE%E9%81%97/%E5%8F%AF%E5%8F%98%E5%8F%82%E6%95%B0/</guid>
      <description>&lt;p&gt;向函数传不定个数的参数就是可变参数。标识符为 &lt;code&gt;...&lt;/code&gt;。&lt;/p&gt;&#xA;&lt;p&gt;举例：&lt;/p&gt;&#xA;&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#d8dee9;background-color:#2e3440;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-c&#34; data-lang=&#34;c&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#81a1c1&#34;&gt;int&lt;/span&gt; &lt;span style=&#34;color:#88c0d0&#34;&gt;printf&lt;/span&gt;&lt;span style=&#34;color:#eceff4&#34;&gt;(&lt;/span&gt;&lt;span style=&#34;color:#81a1c1;font-weight:bold&#34;&gt;const&lt;/span&gt; &lt;span style=&#34;color:#81a1c1&#34;&gt;char&lt;/span&gt; &lt;span style=&#34;color:#81a1c1&#34;&gt;*&lt;/span&gt;format&lt;span style=&#34;color:#eceff4&#34;&gt;,&lt;/span&gt; &lt;span style=&#34;color:#eceff4&#34;&gt;...);&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;h2 id=&#34;在-c-中的使用&#34;&gt;在 C 中的使用&lt;/h2&gt;&#xA;&lt;p&gt;C 中使用可变参数需要引入头文件 &lt;code&gt;stdarg.h&lt;/code&gt;。&lt;/p&gt;</description>
    </item>
    <item>
      <title>移动语义与右值引用</title>
      <link>https://huoxj.github.io/posts/c&#43;&#43;%E6%8B%BE%E9%81%97/%E7%A7%BB%E5%8A%A8%E8%AF%AD%E4%B9%89%E4%B8%8E%E5%8F%B3%E5%80%BC%E5%BC%95%E7%94%A8/</link>
      <pubDate>Sun, 10 Nov 2024 00:00:00 +0000</pubDate>
      <guid>https://huoxj.github.io/posts/c&#43;&#43;%E6%8B%BE%E9%81%97/%E7%A7%BB%E5%8A%A8%E8%AF%AD%E4%B9%89%E4%B8%8E%E5%8F%B3%E5%80%BC%E5%BC%95%E7%94%A8/</guid>
      <description>&lt;h2 id=&#34;参考&#34;&gt;参考&lt;/h2&gt;&#xA;&lt;p&gt;&lt;a href=&#34;https://www.cprogramming.com/c++11/rvalue-references-and-move-semantics-in-c++11.html#google_vignette&#34;&gt;Rvalue References and Move Semantics in C++11 - Cprogramming.com&lt;/a&gt;&lt;/p&gt;&#xA;&lt;p&gt;&lt;a href=&#34;https://zhuanlan.zhihu.com/p/347977300&#34;&gt;认识C++移动语义与右值引用 - 知乎&lt;/a&gt;&lt;/p&gt;</description>
    </item>
    <item>
      <title>Asst1</title>
      <link>https://huoxj.github.io/posts/cs149-%E5%B9%B6%E8%A1%8C%E8%AE%A1%E7%AE%97/asst1/</link>
      <pubDate>Fri, 08 Nov 2024 00:00:00 +0000</pubDate>
      <guid>https://huoxj.github.io/posts/cs149-%E5%B9%B6%E8%A1%8C%E8%AE%A1%E7%AE%97/asst1/</guid>
      <description>&lt;h2 id=&#34;prog1-mandelbrot_threads&#34;&gt;Prog1-mandelbrot_threads&lt;/h2&gt;&#xA;&lt;p&gt;使用 &lt;code&gt;std::thread&lt;/code&gt; 来绘制分形图像。&lt;/p&gt;&#xA;&lt;h3 id=&#34;默认策略&#34;&gt;默认策略&lt;/h3&gt;&#xA;&lt;p&gt;默认策略是将图像分成高度相同的几块，每一块分给一个线程画。&lt;/p&gt;&#xA;&lt;p&gt;这样其实做不到负载均衡，因为每一块画的工作量是不同的。&lt;/p&gt;&#xA;&lt;p&gt;特别是 view1，很明显发现画中间部分的线程工作时间远高于两边的线程。&#xA;&lt;img src=&#34;https://runzblog.oss-cn-hangzhou.aliyuncs.com/postimg/202411080945106.png&#34; alt=&#34;&#34;&gt;&lt;/p&gt;&#xA;&lt;p&gt;代码实现很朴实，均分然后画就好了。&lt;/p&gt;&#xA;&lt;p&gt;在 R7 5800x上（原生 8 核心 16 线程），画 view1：&lt;/p&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;8 线程倍率：4.04x&lt;/li&gt;&#xA;&lt;li&gt;16线程倍率：7.55x&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;p&gt;都被 view1 中的画中间部分的线程拖后腿了。&lt;/p&gt;&#xA;&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#d8dee9;background-color:#2e3440;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-cpp&#34; data-lang=&#34;cpp&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#81a1c1&#34;&gt;int&lt;/span&gt; startRow &lt;span style=&#34;color:#81a1c1&#34;&gt;=&lt;/span&gt; args&lt;span style=&#34;color:#81a1c1&#34;&gt;-&amp;gt;&lt;/span&gt;height &lt;span style=&#34;color:#81a1c1&#34;&gt;/&lt;/span&gt; args&lt;span style=&#34;color:#81a1c1&#34;&gt;-&amp;gt;&lt;/span&gt;numThreads &lt;span style=&#34;color:#81a1c1&#34;&gt;*&lt;/span&gt; args&lt;span style=&#34;color:#81a1c1&#34;&gt;-&amp;gt;&lt;/span&gt;threadId&lt;span style=&#34;color:#eceff4&#34;&gt;,&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    numRows &lt;span style=&#34;color:#81a1c1&#34;&gt;=&lt;/span&gt; args&lt;span style=&#34;color:#81a1c1&#34;&gt;-&amp;gt;&lt;/span&gt;height &lt;span style=&#34;color:#81a1c1&#34;&gt;/&lt;/span&gt; args&lt;span style=&#34;color:#81a1c1&#34;&gt;-&amp;gt;&lt;/span&gt;numThreads&lt;span style=&#34;color:#eceff4&#34;&gt;;&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;mandelbrotSerial&lt;span style=&#34;color:#eceff4&#34;&gt;(&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&#x9;args&lt;span style=&#34;color:#81a1c1&#34;&gt;-&amp;gt;&lt;/span&gt;x0&lt;span style=&#34;color:#eceff4&#34;&gt;,&lt;/span&gt; args&lt;span style=&#34;color:#81a1c1&#34;&gt;-&amp;gt;&lt;/span&gt;y0&lt;span style=&#34;color:#eceff4&#34;&gt;,&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&#x9;args&lt;span style=&#34;color:#81a1c1&#34;&gt;-&amp;gt;&lt;/span&gt;x1&lt;span style=&#34;color:#eceff4&#34;&gt;,&lt;/span&gt; args&lt;span style=&#34;color:#81a1c1&#34;&gt;-&amp;gt;&lt;/span&gt;y1&lt;span style=&#34;color:#eceff4&#34;&gt;,&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&#x9;args&lt;span style=&#34;color:#81a1c1&#34;&gt;-&amp;gt;&lt;/span&gt;width&lt;span style=&#34;color:#eceff4&#34;&gt;,&lt;/span&gt; args&lt;span style=&#34;color:#81a1c1&#34;&gt;-&amp;gt;&lt;/span&gt;height&lt;span style=&#34;color:#eceff4&#34;&gt;,&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&#x9;startRow&lt;span style=&#34;color:#eceff4&#34;&gt;,&lt;/span&gt; numRows&lt;span style=&#34;color:#eceff4&#34;&gt;,&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&#x9;args&lt;span style=&#34;color:#81a1c1&#34;&gt;-&amp;gt;&lt;/span&gt;maxIterations&lt;span style=&#34;color:#eceff4&#34;&gt;,&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&#x9;args&lt;span style=&#34;color:#81a1c1&#34;&gt;-&amp;gt;&lt;/span&gt;output&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&#x9;&lt;span style=&#34;color:#eceff4&#34;&gt;);&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;h3 id=&#34;均衡策略&#34;&gt;均衡策略&lt;/h3&gt;&#xA;&lt;p&gt;让线程按行交错绘制图像。&lt;/p&gt;&#xA;&lt;p&gt;其实这个策略是在模拟随机分配任务。思想是将任务分成尽可能小的部分，然后让大家随机挑任务做。&lt;/p&gt;&#xA;&lt;p&gt;可以证明对长度为 $n$ 的数列 $a$（工作量），在其中随机取 $n/s$ 项（$s$就是线程数），其和的期望是相同的。&lt;/p&gt;&#xA;&lt;p&gt;代码实现是按行交错绘制，实现起来比较简单。&lt;/p&gt;&#xA;&lt;p&gt;对于 view1：&lt;/p&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;8 线程：7.53x&lt;/li&gt;&#xA;&lt;li&gt;16 线程： 11.48x&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;p&gt;16线程反而缩水得很严重，主要原因应该是 8 线程时每个线程独享一个核心，基本做到了并行。但是 16 线程时就是两个线程争抢一个核心了，需要并发。&lt;/p&gt;</description>
    </item>
    <item>
      <title>读论文-YOLO v1</title>
      <link>https://huoxj.github.io/posts/%E8%8A%9D%E5%A3%AB%E6%94%B6%E5%AE%B9%E6%89%80/%E8%AF%BB%E8%AE%BA%E6%96%87-yolo-v1/</link>
      <pubDate>Fri, 08 Nov 2024 00:00:00 +0000</pubDate>
      <guid>https://huoxj.github.io/posts/%E8%8A%9D%E5%A3%AB%E6%94%B6%E5%AE%B9%E6%89%80/%E8%AF%BB%E8%AE%BA%E6%96%87-yolo-v1/</guid>
      <description>&lt;p&gt;大创要做一个基于两个特征矩阵的信号分割与分类（不知道该不该这么描述），精确度要求不高，但对实时性要求比较高。我想到了借鉴 YOLO 来解决这个问题，所以顺便就来读一下 YOLO 初代的论文，太复杂了猪脑是理解不能的。&lt;/p&gt;&#xA;&lt;h2 id=&#34;skimming&#34;&gt;Skimming&lt;/h2&gt;&#xA;&lt;h3 id=&#34;摘要&#34;&gt;摘要&lt;/h3&gt;&#xA;&lt;p&gt;YOLO 做的活是 object detection。有如下特点：&lt;/p&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;单 CNN 实现图像分割与分类，而不是两个阶段两个网络&lt;/li&gt;&#xA;&lt;li&gt;推理快，能做到实时 45 fps 以上&lt;/li&gt;&#xA;&lt;li&gt;比传统的 DPM 和 R-CNN 泛化性更好，准确性也是其他模型的大约两倍&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;p&gt;佬就是佬，不需要什么花里胡哨的背景介绍，上来就是我们的模型吊打其他模型。&lt;/p&gt;&#xA;&lt;h3 id=&#34;介绍&#34;&gt;介绍&lt;/h3&gt;&#xA;&lt;p&gt;首先，YOLO 的推理过程和人眼很像。这应该是在暗示模型的名字由来（&lt;/p&gt;&#xA;&lt;p&gt;然后三大点：&lt;/p&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;YOLO 很快。&lt;/li&gt;&#xA;&lt;li&gt;YOLO 视野更广。推理图片是依靠图像全局信息，而不是滑动窗口那种局部信息。&lt;/li&gt;&#xA;&lt;li&gt;YOLO 泛化很强。&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;h3 id=&#34;原理&#34;&gt;原理&lt;/h3&gt;&#xA;&lt;p&gt;这里得好好看，所以先跳过。&lt;/p&gt;&#xA;&lt;h3 id=&#34;对比其他网络&#34;&gt;对比其他网络&lt;/h3&gt;&#xA;&lt;p&gt;对比了 DPM 和 R-CNN 等模型。除了这两个模型稍微认识以外，其他的都认不得。&lt;/p&gt;&#xA;&lt;p&gt;反正很强。&lt;/p&gt;&#xA;&lt;h2 id=&#34;原理-1&#34;&gt;原理&lt;/h2&gt;&#xA;&lt;h3 id=&#34;one-stage-如何实现&#34;&gt;One-stage 如何实现&lt;/h3&gt;&#xA;&lt;p&gt;YOLO 将一张图像分成了 $S$ 行 $S$ 列块方格。&lt;/p&gt;&#xA;&lt;p&gt;每一块方格负责预测：&lt;/p&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;物体类别&lt;/li&gt;&#xA;&lt;li&gt;$B$ 个预测框 (Bounding box)，以及对应置信度&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;p&gt;参考下方图片。&lt;/p&gt;&#xA;&lt;p&gt;&lt;img src=&#34;https://runzblog.oss-cn-hangzhou.aliyuncs.com/postimg/202411101019480.png&#34; alt=&#34;&#34;&gt;&lt;/p&gt;&#xA;&lt;h2 id=&#34;参考&#34;&gt;参考&lt;/h2&gt;&#xA;&lt;p&gt;&lt;a href=&#34;https://www.cnblogs.com/xiaoxiaojiea/p/14534513.html&#34;&gt;目标检测入门论文YOLOV1精读以及pytorch源码复现(yolov1) - 小小猿笔记 - 博客园&lt;/a&gt;&lt;/p&gt;</description>
    </item>
    <item>
      <title>小米路由器 4Av2 刷 Openwrt 并开启 NAT6</title>
      <link>https://huoxj.github.io/posts/%E6%9C%89%E6%84%8F%E6%80%9D%E7%9A%84%E6%8A%98%E8%85%BE/%E5%B0%8F%E7%B1%B3%E8%B7%AF%E7%94%B1%E5%99%A8-4av2-%E5%88%B7-openwrt-%E5%B9%B6%E5%BC%80%E5%90%AF-nat6/</link>
      <pubDate>Sun, 03 Nov 2024 00:00:00 +0000</pubDate>
      <guid>https://huoxj.github.io/posts/%E6%9C%89%E6%84%8F%E6%80%9D%E7%9A%84%E6%8A%98%E8%85%BE/%E5%B0%8F%E7%B1%B3%E8%B7%AF%E7%94%B1%E5%99%A8-4av2-%E5%88%B7-openwrt-%E5%B9%B6%E5%BC%80%E5%90%AF-nat6/</guid>
      <description>&lt;h2 id=&#34;需求&#34;&gt;需求&lt;/h2&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;校园网 128 位前缀的 IPV6 地址做 NAT6&lt;/li&gt;&#xA;&lt;li&gt;IPV6 访问 PT 站&lt;/li&gt;&#xA;&lt;li&gt;其他功能，比如魔法&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;p&gt;网络环境是&lt;code&gt;南京大学鼓楼校区校园网&lt;/code&gt;。仙林应该是差不多的。&lt;/p&gt;&#xA;&lt;p&gt;设备是&lt;code&gt;小米路由器 4A v2&lt;/code&gt;。这个设备导致我装 Openwrt 的过程相当坎坷 TAT，再也不贪便宜买低端设备了。&lt;/p&gt;&#xA;&lt;h2 id=&#34;刷-openwrt&#34;&gt;刷 Openwrt&lt;/h2&gt;&#xA;&lt;h3 id=&#34;breed&#34;&gt;Breed&lt;/h3&gt;&#xA;&lt;p&gt;Breed 是一种 bootloader，路由器会先引导至 Breed 后再引导你刷的其他系统。这样就不怕系统刷坏变砖了。&lt;/p&gt;&#xA;&lt;p&gt;刷 Breed 的教程很多，这里不再赘述。（刷一次基本一劳永逸了，所以不太记得怎么刷）&lt;/p&gt;&#xA;&lt;h3 id=&#34;自编译-openwrt&#34;&gt;自编译 Openwrt&lt;/h3&gt;&#xA;&lt;p&gt;你也可以选择在线编译 Openwrt 的方案，比如 Github Action 、&lt;a href=&#34;https://firmware-selector.openwrt.org/&#34;&gt;OpenWrt Firmware Selector&lt;/a&gt; 和 &lt;a href=&#34;https://openwrt.ai&#34;&gt;openwrt.ai&lt;/a&gt;。&lt;/p&gt;&#xA;&lt;p&gt;我之前直接使用了别人编译好的系统，但存在许许多多的问题导致 IPV6 配不起来，故尝试了自己编译，也还算有趣。抖m指数++。&lt;/p&gt;&#xA;&lt;p&gt;编译的环境最好选 Linux 或者 WSL。常用的包和依赖得备齐，并且最好全程有魔法，否则很难编译成功。&lt;/p&gt;&#xA;&lt;p&gt;首先拉取 openwrt 源码。&lt;/p&gt;&#xA;&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#d8dee9;background-color:#2e3440;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-bash&#34; data-lang=&#34;bash&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;git clone https://github.com/openwrt/openwrt&#xA;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;拉取下来的 &lt;code&gt;main&lt;/code&gt; 分支是 snapshot 版本，建议还是选择稳定版，否则有些软件包装不了。写作本文时最新版为 23.05.5，对应 branch 为 &lt;code&gt;openwrt-23.05&lt;/code&gt;，下文以此为准。&lt;/p&gt;&#xA;&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#d8dee9;background-color:#2e3440;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-bash&#34; data-lang=&#34;bash&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;git checkout openwrt-23.05&#xA;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;如果你想从其他版本构建，比如 LEDE 或者老版本 Openwrt，可以参考&lt;a href=&#34;https://www.bilibili.com/read/cv23234832/&#34;&gt;小米4A千兆版V2刷自己编译的OpenWRT以及IPV6设置（包括中继与NAT6） - 哔哩哔哩&lt;/a&gt;&lt;/p&gt;</description>
    </item>
    <item>
      <title>SE-ML05-K 邻近</title>
      <link>https://huoxj.github.io/posts/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/se-ml05-k-%E9%82%BB%E8%BF%91/</link>
      <pubDate>Fri, 25 Oct 2024 00:00:00 +0000</pubDate>
      <guid>https://huoxj.github.io/posts/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/se-ml05-k-%E9%82%BB%E8%BF%91/</guid>
      <description>&lt;h2 id=&#34;k-nn-分类器&#34;&gt;k-NN 分类器&lt;/h2&gt;&#xA;&lt;h3 id=&#34;算法流程&#34;&gt;算法流程&lt;/h3&gt;&#xA;&lt;p&gt;对测试样本，找训练样本中最近的 $k$ 个，这 $k$ 个样本中&lt;strong&gt;标签最多&lt;/strong&gt;的就是测试样本的类。&lt;/p&gt;&#xA;&lt;h3 id=&#34;k-的取值&#34;&gt;k 的取值&lt;/h3&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;k 一般取奇数值，避免平局&lt;/li&gt;&#xA;&lt;li&gt;k 取不同的值，分类结果可能不同&lt;/li&gt;&#xA;&lt;li&gt;k 值较小时，对噪声敏感，整体模型变得复杂，容易过拟合&lt;/li&gt;&#xA;&lt;li&gt;k 值较大时，对噪声不敏感，整体模型变得简单，容易欠拟合&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;h3 id=&#34;变种&#34;&gt;变种&lt;/h3&gt;&#xA;&lt;h4 id=&#34;最邻近分类器&#34;&gt;最邻近分类器&lt;/h4&gt;&#xA;&lt;p&gt;k-NN 的 $k=1$ 的特殊情况。&lt;/p&gt;&#xA;&lt;p&gt;泛化错误率，不超过贝叶斯分类器错误率的两倍。&lt;/p&gt;&#xA;&lt;h2 id=&#34;k-nn-回归&#34;&gt;k-NN 回归&lt;/h2&gt;&#xA;&lt;h3 id=&#34;算法流程-1&#34;&gt;算法流程&lt;/h3&gt;&#xA;&lt;p&gt;对测试样本，找训练样本中最近的 $k$ 个，将这 $k$ 个样本的标签&lt;strong&gt;加权平均&lt;/strong&gt;得到预测值。&lt;/p&gt;&#xA;&lt;h3 id=&#34;近邻平滑&#34;&gt;近邻平滑&lt;/h3&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;二次核&lt;/li&gt;&#xA;&lt;li&gt;次方核&lt;/li&gt;&#xA;&lt;li&gt;高斯核&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;h2 id=&#34;降低近邻计算&#34;&gt;降低近邻计算&lt;/h2&gt;&#xA;&lt;h3 id=&#34;维诺图&#34;&gt;维诺图&lt;/h3&gt;&#xA;&lt;p&gt;就是类别预测图，根据决策边界，将边界内填色。&lt;/p&gt;&#xA;&lt;p&gt;&lt;img src=&#34;https://runzblog.oss-cn-hangzhou.aliyuncs.com/postimg/202501051051813.png&#34; alt=&#34;&#34;&gt;&lt;/p&gt;&#xA;&lt;h3 id=&#34;kd-tree&#34;&gt;KD-Tree&lt;/h3&gt;&#xA;&lt;p&gt;OI-wiki 讲得更好一点。&lt;/p&gt;&#xA;&lt;p&gt;&lt;a href=&#34;https://oi-wiki.org/ds/kdt/&#34;&gt;K-D Tree - OI Wiki&lt;/a&gt;&lt;/p&gt;&#xA;&lt;ol&gt;&#xA;&lt;li&gt;选择维度，标准是方差&lt;/li&gt;&#xA;&lt;li&gt;选择切割点，可以选第一步选择的维度中，为中位数的点&lt;/li&gt;&#xA;&lt;li&gt;切割点作为当前根节点，切割的两个空间作为左右子树&lt;/li&gt;&#xA;&lt;li&gt;递归。直到当前空间只有一个点&lt;/li&gt;&#xA;&lt;/ol&gt;</description>
    </item>
    <item>
      <title>关键字</title>
      <link>https://huoxj.github.io/posts/c&#43;&#43;%E6%8B%BE%E9%81%97/%E5%85%B3%E9%94%AE%E5%AD%97/</link>
      <pubDate>Sun, 20 Oct 2024 00:00:00 +0000</pubDate>
      <guid>https://huoxj.github.io/posts/c&#43;&#43;%E6%8B%BE%E9%81%97/%E5%85%B3%E9%94%AE%E5%AD%97/</guid>
      <description>&lt;h2 id=&#34;typedef&#34;&gt;typedef&lt;/h2&gt;&#xA;&lt;p&gt;字面意思，给类型取别名。&lt;/p&gt;&#xA;&lt;h3 id=&#34;和-define-的区别&#34;&gt;和 define 的区别&lt;/h3&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;&#xA;&lt;p&gt;define 可以替换任何东西，比如常量、编译开关等&lt;/p&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;&#xA;&lt;p&gt;define 在编译之前的预处理阶段生效，typedef 在编译阶段生效。&lt;/p&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;&#xA;&lt;p&gt;typedef可以只在某个作用域内生效。&lt;/p&gt;&#xA;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#d8dee9;background-color:#2e3440;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-cpp&#34; data-lang=&#34;cpp&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#81a1c1&#34;&gt;int&lt;/span&gt; &lt;span style=&#34;color:#88c0d0&#34;&gt;main&lt;/span&gt;&lt;span style=&#34;color:#eceff4&#34;&gt;()&lt;/span&gt; &lt;span style=&#34;color:#eceff4&#34;&gt;{&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&#x9;&lt;span style=&#34;color:#81a1c1;font-weight:bold&#34;&gt;typedef&lt;/span&gt; &lt;span style=&#34;color:#81a1c1&#34;&gt;int&lt;/span&gt; size_t&lt;span style=&#34;color:#eceff4&#34;&gt;;&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&#x9;size_t s &lt;span style=&#34;color:#81a1c1&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#b48ead&#34;&gt;3&lt;/span&gt;&lt;span style=&#34;color:#eceff4&#34;&gt;;&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&#x9;fun&lt;span style=&#34;color:#eceff4&#34;&gt;();&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#eceff4&#34;&gt;}&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#81a1c1&#34;&gt;int&lt;/span&gt; &lt;span style=&#34;color:#88c0d0&#34;&gt;fun&lt;/span&gt;&lt;span style=&#34;color:#eceff4&#34;&gt;()&lt;/span&gt; &lt;span style=&#34;color:#eceff4&#34;&gt;{&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&#x9;size_t t &lt;span style=&#34;color:#81a1c1&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#b48ead&#34;&gt;2&lt;/span&gt;&lt;span style=&#34;color:#eceff4&#34;&gt;;&lt;/span&gt; &lt;span style=&#34;color:#616e87;font-style:italic&#34;&gt;// ERROR&#xA;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#616e87;font-style:italic&#34;&gt;&lt;/span&gt;&lt;span style=&#34;color:#eceff4&#34;&gt;}&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;ul&gt;&#xA;&lt;li&gt;对指针的修饰不同&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;p&gt;含 const 时，两者不等价&#xA;TODO&lt;/p&gt;&#xA;&lt;h3 id=&#34;类型别名&#34;&gt;类型别名&lt;/h3&gt;&#xA;&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#d8dee9;background-color:#2e3440;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-cpp&#34; data-lang=&#34;cpp&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#81a1c1;font-weight:bold&#34;&gt;typedef&lt;/span&gt; &lt;span style=&#34;color:#81a1c1&#34;&gt;unsigned&lt;/span&gt; &lt;span style=&#34;color:#81a1c1&#34;&gt;int&lt;/span&gt; size_t&#xA;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;h3 id=&#34;结构体别名&#34;&gt;结构体别名&lt;/h3&gt;&#xA;&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#d8dee9;background-color:#2e3440;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-cpp&#34; data-lang=&#34;cpp&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#81a1c1;font-weight:bold&#34;&gt;typedef&lt;/span&gt; &lt;span style=&#34;color:#81a1c1;font-weight:bold&#34;&gt;struct&lt;/span&gt; &lt;span style=&#34;color:#8fbcbb&#34;&gt;person&lt;/span&gt;&lt;span style=&#34;color:#eceff4&#34;&gt;{&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&#x9;&lt;span style=&#34;color:#81a1c1&#34;&gt;char&lt;/span&gt; name&lt;span style=&#34;color:#eceff4&#34;&gt;[&lt;/span&gt;&lt;span style=&#34;color:#b48ead&#34;&gt;128&lt;/span&gt;&lt;span style=&#34;color:#eceff4&#34;&gt;];&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#eceff4&#34;&gt;}&lt;/span&gt;Person&lt;span style=&#34;color:#eceff4&#34;&gt;;&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;Person a&lt;span style=&#34;color:#eceff4&#34;&gt;;&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;h3 id=&#34;函数指针别名&#34;&gt;函数指针别名&lt;/h3&gt;&#xA;&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#d8dee9;background-color:#2e3440;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-cpp&#34; data-lang=&#34;cpp&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#81a1c1;font-weight:bold&#34;&gt;typedef&lt;/span&gt; &lt;span style=&#34;color:#81a1c1&#34;&gt;void&lt;/span&gt;&lt;span style=&#34;color:#81a1c1&#34;&gt;*&lt;/span&gt;&lt;span style=&#34;color:#eceff4&#34;&gt;(&lt;/span&gt;&lt;span style=&#34;color:#81a1c1&#34;&gt;*&lt;/span&gt;Fun&lt;span style=&#34;color:#eceff4&#34;&gt;)&lt;/span&gt; &#xA;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;h2 id=&#34;sizeof&#34;&gt;sizeof&lt;/h2&gt;&#xA;&lt;p&gt;sizeof 有两种。一种带括号的，另一种不带。&lt;/p&gt;&#xA;&lt;h3 id=&#34;sizeof-无括号&#34;&gt;sizeof 无括号&lt;/h3&gt;&#xA;&lt;p&gt;返回所给类型的字节数。后面只能跟类型名。&lt;/p&gt;&#xA;&lt;h3 id=&#34;sizeof-1&#34;&gt;sizeof()&lt;/h3&gt;&#xA;&lt;p&gt;返回括号中变量所占字节数。&lt;/p&gt;&#xA;&lt;p&gt;可以理解为在识别了这个变量的类型后，再使用无括号的 sizeof 返回这个类型占的字节数。&lt;/p&gt;&#xA;&lt;p&gt;注意：&lt;/p&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;指向数组首元素的指针传入时，只会返回 4。因为传入的是指针变量而不是数组变量（e.g. &lt;code&gt;int*&lt;/code&gt;  和 &lt;code&gt;int[5]&lt;/code&gt;）&lt;/li&gt;&#xA;&lt;/ul&gt;</description>
    </item>
    <item>
      <title>类型解释</title>
      <link>https://huoxj.github.io/posts/c&#43;&#43;%E6%8B%BE%E9%81%97/%E7%B1%BB%E5%9E%8B%E8%A7%A3%E9%87%8A/</link>
      <pubDate>Sun, 13 Oct 2024 00:00:00 +0000</pubDate>
      <guid>https://huoxj.github.io/posts/c&#43;&#43;%E6%8B%BE%E9%81%97/%E7%B1%BB%E5%9E%8B%E8%A7%A3%E9%87%8A/</guid>
      <description>&lt;h2 id=&#34;写在前面&#34;&gt;写在前面&lt;/h2&gt;&#xA;&lt;p&gt;写这部分是为了：&lt;/p&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;读懂复杂且恶心的类型声明，比如 &lt;code&gt;void (*signal(int, void (*fp)(int)))(int);&lt;/code&gt;&lt;/li&gt;&#xA;&lt;li&gt;考试&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;p&gt;记住要：&lt;/p&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;不写这种不符合规范，并且恶心他人的声明&lt;/li&gt;&#xA;&lt;li&gt;多用 &lt;code&gt;using&lt;/code&gt; 以及 STL 封装好的类型，适度用 &lt;code&gt;typedef&lt;/code&gt;&lt;/li&gt;&#xA;&lt;li&gt;对恶心的写法说 no&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;p&gt;推荐这个网站，能帮你把 C 类型声明翻译成自然语言：&lt;/p&gt;&#xA;&lt;p&gt;&lt;a href=&#34;https://cdecl.org/&#34;&gt;cdecl: C gibberish ↔ English&lt;/a&gt;&lt;/p&gt;&#xA;&lt;h2 id=&#34;变量声明说明符&#34;&gt;变量声明说明符&lt;/h2&gt;&#xA;&lt;p&gt;本文中，我们只关心如下几种说明符，因为这几种说明符是最困难的部分：&lt;/p&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;&lt;code&gt;*&lt;/code&gt;: 指针&lt;/li&gt;&#xA;&lt;li&gt;&lt;code&gt;[]&lt;/code&gt;: 数组&lt;/li&gt;&#xA;&lt;li&gt;&lt;code&gt;()&lt;/code&gt;: 括号（改变声明优先级）或者 函数指针&lt;/li&gt;&#xA;&lt;li&gt;&lt;code&gt;&amp;amp;&lt;/code&gt;: 引用&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;h2 id=&#34;优先级&#34;&gt;优先级&lt;/h2&gt;&#xA;&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#d8dee9;background-color:#2e3440;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-text&#34; data-lang=&#34;text&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;括号括住的部分 &amp;gt; 后缀说明符 &amp;gt; 前缀说明符&#xA;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;h2 id=&#34;读声明&#34;&gt;读声明&lt;/h2&gt;&#xA;&lt;p&gt;优先级规律总结出来其实就是 &lt;code&gt;右左法则&lt;/code&gt;，或者叫 &lt;code&gt;clockwise/spiral Rule&lt;/code&gt;。&lt;/p&gt;&#xA;&lt;p&gt;法则内容如下：&lt;/p&gt;&#xA;&lt;h3 id=&#34;从唯一的未定义的标识符开始&#34;&gt;从唯一的未定义的标识符开始&lt;/h3&gt;&#xA;&lt;p&gt;声明语句中，有且仅有一个之前没定义过的标识符。我们就从这个标识符开始。&lt;/p&gt;&#xA;&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#d8dee9;background-color:#2e3440;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-cpp&#34; data-lang=&#34;cpp&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#81a1c1&#34;&gt;int&lt;/span&gt; &lt;span style=&#34;color:#eceff4&#34;&gt;((&lt;/span&gt;&lt;span style=&#34;color:#81a1c1&#34;&gt;*&lt;/span&gt;fp&lt;span style=&#34;color:#eceff4&#34;&gt;)[&lt;/span&gt;MAXN&lt;span style=&#34;color:#eceff4&#34;&gt;])(&lt;/span&gt;&lt;span style=&#34;color:#81a1c1&#34;&gt;int&lt;/span&gt; x&lt;span style=&#34;color:#eceff4&#34;&gt;,&lt;/span&gt; &lt;span style=&#34;color:#81a1c1&#34;&gt;int&lt;/span&gt; y&lt;span style=&#34;color:#eceff4&#34;&gt;);&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;上例就是 &lt;code&gt;fp&lt;/code&gt;。&lt;/p&gt;&#xA;&lt;h3 id=&#34;先看右边的声明符再看左边&#34;&gt;先看右边的声明符，再看左边&lt;/h3&gt;&#xA;&lt;p&gt;因为后缀说明符优先级更高，所以先看右边。&lt;/p&gt;&#xA;&lt;h3 id=&#34;将看到的声明符转译为英文&#34;&gt;将看到的声明符转译为英文&lt;/h3&gt;&#xA;&lt;p&gt;看到了哪个声明符，就将如下列出的翻译模板加到我们当前的翻译栈中。&lt;/p&gt;&#xA;&lt;p&gt;指针 / 引用：a pointer / reference to&lt;/p&gt;&#xA;&lt;p&gt;数组：an array of&lt;/p&gt;</description>
    </item>
    <item>
      <title>STL-容器</title>
      <link>https://huoxj.github.io/posts/c&#43;&#43;%E6%8B%BE%E9%81%97/stl-%E5%AE%B9%E5%99%A8/</link>
      <pubDate>Sat, 12 Oct 2024 00:00:00 +0000</pubDate>
      <guid>https://huoxj.github.io/posts/c&#43;&#43;%E6%8B%BE%E9%81%97/stl-%E5%AE%B9%E5%99%A8/</guid>
      <description>&lt;h1 id=&#34;序列容器&#34;&gt;序列容器&lt;/h1&gt;&#xA;&lt;p&gt;序列容器实现能按顺序访问的数据结构。&lt;/p&gt;&#xA;&lt;p&gt;有如下容器：&lt;/p&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;&lt;code&gt;vector&lt;/code&gt;：动态数组&lt;/li&gt;&#xA;&lt;li&gt;&lt;code&gt;deque&lt;/code&gt;：双端队列&lt;/li&gt;&#xA;&lt;li&gt;&lt;code&gt;list&lt;/code&gt;：双向链表&lt;/li&gt;&#xA;&lt;li&gt;&lt;code&gt;array&lt;/code&gt;：C 风格的固定大小的数组 &lt;em&gt;C++11&lt;/em&gt;&lt;/li&gt;&#xA;&lt;li&gt;&lt;code&gt;forward_list&lt;/code&gt;：单向链表。性能比 list 略好，基本和 C 中的链表无异 C++11&lt;/li&gt;&#xA;&lt;li&gt;&lt;code&gt;inpalce_vector&lt;/code&gt;：可动态调整大小的固定容量原位连续数组 C++26&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;h2 id=&#34;一般操作&#34;&gt;一般操作&lt;/h2&gt;&#xA;&lt;h3 id=&#34;构造&#34;&gt;构造&lt;/h3&gt;&#xA;&lt;p&gt;省略返回类型以及一些无关紧要的参数类型。&lt;/p&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;&lt;code&gt;()&lt;/code&gt;：默认无参数构造&lt;/li&gt;&#xA;&lt;li&gt;&lt;code&gt;(&amp;amp;&amp;amp; other)&lt;/code&gt;：拷贝构造&lt;/li&gt;&#xA;&lt;li&gt;&lt;code&gt;(it1, it2)&lt;/code&gt;：从另一个 vector 的迭代器构造，得到子 vector&lt;/li&gt;&#xA;&lt;li&gt;&lt;code&gt;(count, T element)&lt;/code&gt;：含 count 个 element&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;h3 id=&#34;赋值&#34;&gt;赋值&lt;/h3&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;赋值号&lt;/li&gt;&#xA;&lt;li&gt;&lt;code&gt;assign&lt;/code&gt; 函数。和构造函数参数是一致的。&lt;/li&gt;&#xA;&lt;li&gt;&lt;code&gt;swap&lt;/code&gt; 交互两个容器。&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;h3 id=&#34;元素访问&#34;&gt;元素访问&lt;/h3&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;&lt;code&gt;operator[]&lt;/code&gt;。数组的访问方式。可以访问任意下标的元素。&lt;/li&gt;&#xA;&lt;li&gt;&lt;code&gt;at(index)&lt;/code&gt;。访问下标 index 处的元素。&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;h3 id=&#34;元素操作&#34;&gt;元素操作&lt;/h3&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;&lt;code&gt;push_front(T e)&lt;/code&gt; &lt;code&gt;push_back(T e)&lt;/code&gt;：头尾部加入元素&lt;/li&gt;&#xA;&lt;li&gt;&lt;code&gt;pop_back()&lt;/code&gt; &lt;code&gt;pop_front()&lt;/code&gt;：尾部删除&lt;/li&gt;&#xA;&lt;li&gt;&lt;code&gt;insert(it, T e) / insert(it, count, T e)&lt;/code&gt;：it 处插入一个或多个 e&lt;/li&gt;&#xA;&lt;li&gt;&lt;code&gt;erase(it) / erase(it1, it2)&lt;/code&gt;：it 处删除 / [it, it2) 处删除&lt;/li&gt;&#xA;&lt;li&gt;&lt;code&gt;clear()&lt;/code&gt;：清空&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;blockquote&gt;&#xA;&lt;p&gt;push_back V.S. emplace_back&#xA;tl dr. 如果传入的是构造参数，后者直接在vector里构造，效率比前者更高。&#xA;如果传入的是一个已经构造好的对象，二者是一样的。&#xA;如果感兴趣，网上有很多详细的解析。&lt;/p&gt;</description>
    </item>
    <item>
      <title>String</title>
      <link>https://huoxj.github.io/posts/c&#43;&#43;%E6%8B%BE%E9%81%97/string/</link>
      <pubDate>Sat, 12 Oct 2024 00:00:00 +0000</pubDate>
      <guid>https://huoxj.github.io/posts/c&#43;&#43;%E6%8B%BE%E9%81%97/string/</guid>
      <description>&lt;h2 id=&#34;前言&#34;&gt;前言&lt;/h2&gt;&#xA;&lt;p&gt;在以前打竞赛的时候，基本都是用字符数组配合&lt;code&gt;string.h&lt;/code&gt;里的函数去处理字符串。现在开始系统地接触C++，所以来记录一下&lt;code&gt;string&lt;/code&gt;类的知识。&lt;/p&gt;&#xA;&lt;h2 id=&#34;简介&#34;&gt;简介&lt;/h2&gt;&#xA;&lt;p&gt;&lt;code&gt;string&lt;/code&gt; 是 C++ 风格的字符串类，也是一种STL容器(根据CppReference说法，string是唯一的&lt;code&gt;伪容器&lt;/code&gt;)。相比于 C 风格的字符串 &lt;code&gt;char[]&lt;/code&gt; ，string 支持自动内存管理，并且拥有很多方便的函数。&lt;/p&gt;&#xA;&lt;p&gt;头文件：&lt;code&gt;string&lt;/code&gt;&lt;/p&gt;&#xA;&lt;h2 id=&#34;构造&#34;&gt;构造&lt;/h2&gt;&#xA;&lt;h3 id=&#34;一般构造&#34;&gt;一般构造&lt;/h3&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;&lt;code&gt;std::string(const char* s)&lt;/code&gt;&lt;/li&gt;&#xA;&lt;li&gt;&lt;code&gt;std::string(const string&amp;amp; s)&lt;/code&gt;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;p&gt;传入一个 C 字符串或者字符串类，变成 C++ string类。没什么好说的。&lt;/p&gt;&#xA;&lt;h3 id=&#34;特殊构造&#34;&gt;特殊构造&lt;/h3&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;直接赋值&lt;code&gt;string str = &amp;quot;...&amp;quot;&lt;/code&gt;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;p&gt;直接将 C 字符串赋值或者类型转换。&lt;/p&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;&lt;code&gt;std::string(size_t n, char c)&lt;/code&gt;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;p&gt;构造一个 n 个 c 的字符串。也就是将 c 重复 n 次。&lt;/p&gt;&#xA;&lt;h2 id=&#34;属性&#34;&gt;属性&lt;/h2&gt;&#xA;&lt;h3 id=&#34;长度&#34;&gt;长度&lt;/h3&gt;&#xA;&lt;p&gt;优先 &lt;code&gt;string.length()&lt;/code&gt;。&lt;/p&gt;&#xA;&lt;p&gt;其他诸如 &lt;code&gt;string.size()&lt;/code&gt; 和 &lt;code&gt;strlen(const &amp;amp;string)&lt;/code&gt;。&lt;/p&gt;&#xA;&lt;h3 id=&#34;是否空&#34;&gt;是否空&lt;/h3&gt;&#xA;&lt;p&gt;和其他 STL 容器一样，判断 string 是否为空：&lt;/p&gt;&#xA;&lt;p&gt;&lt;code&gt;string.empty()&lt;/code&gt;&lt;/p&gt;&#xA;&lt;h2 id=&#34;访问与遍历&#34;&gt;访问与遍历&lt;/h2&gt;&#xA;&lt;h3 id=&#34;索引&#34;&gt;索引&lt;/h3&gt;&#xA;&lt;p&gt;&lt;code&gt;str[i]&lt;/code&gt; 直接得到对应字符。&lt;/p&gt;&#xA;&lt;h3 id=&#34;迭代器&#34;&gt;迭代器&lt;/h3&gt;&#xA;&lt;p&gt;&lt;code&gt;string.begin()&lt;/code&gt;, &lt;code&gt;string.end()&lt;/code&gt; 得到头尾 iterator。&lt;/p&gt;</description>
    </item>
    <item>
      <title>粗浅理解指针、引用与数组</title>
      <link>https://huoxj.github.io/posts/c&#43;&#43;%E6%8B%BE%E9%81%97/%E7%B2%97%E6%B5%85%E7%90%86%E8%A7%A3%E6%8C%87%E9%92%88%E5%BC%95%E7%94%A8%E4%B8%8E%E6%95%B0%E7%BB%84/</link>
      <pubDate>Sat, 12 Oct 2024 00:00:00 +0000</pubDate>
      <guid>https://huoxj.github.io/posts/c&#43;&#43;%E6%8B%BE%E9%81%97/%E7%B2%97%E6%B5%85%E7%90%86%E8%A7%A3%E6%8C%87%E9%92%88%E5%BC%95%E7%94%A8%E4%B8%8E%E6%95%B0%E7%BB%84/</guid>
      <description>&lt;h2 id=&#34;引用&#34;&gt;引用&lt;/h2&gt;&#xA;&lt;h3 id=&#34;引用和指针&#34;&gt;引用和指针&lt;/h3&gt;&#xA;&lt;p&gt;以我的粗浅且可能有很大错误的理解，引用就是有着一些限制、有一些封装的指针，这些限制在编译器层面解决，底层就是以指针形式实现。&lt;/p&gt;&#xA;&lt;p&gt;限制在如下几点：&lt;/p&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;引用创建时需要初始化&lt;/li&gt;&#xA;&lt;li&gt;引用在初始化后无法再改变指向&#xA;&lt;ul&gt;&#xA;&lt;li&gt;所以不存在 &lt;code&gt;const int&amp;amp; &lt;/code&gt;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;p&gt;引用带来的方便：&lt;/p&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;引用的元素可以直接按名访问，不需要解指针&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;h2 id=&#34;指针&#34;&gt;指针&lt;/h2&gt;&#xA;&lt;p&gt;指针是指向一块内存首地址的变量。指针的类型提供了对于这个首地址该如何解释的信息。&lt;/p&gt;&#xA;&lt;h3 id=&#34;智能指针&#34;&gt;智能指针&lt;/h3&gt;&#xA;&lt;blockquote&gt;&#xA;&lt;p&gt;TODO：目前是从 YDJSIR 笔记中复制粘贴的&#xA;智能指针内容繁杂，需要开一篇专门文章&lt;/p&gt;&#xA;&lt;/blockquote&gt;&#xA;&lt;ol&gt;&#xA;&lt;li&gt;&#xA;&lt;p&gt;通过将一些需要的信息进行封装的方法，来保证不管出现什么异常，在退出相应操作部分时，自动调用对象的析构函数来保证不会出现内存泄漏的问题。&lt;/p&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;&#xA;&lt;p&gt;同样的还有句柄类(C++ 异常中有)&lt;/p&gt;&#xA;&lt;/li&gt;&#xA;&lt;/ol&gt;&#xA;&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#d8dee9;background-color:#2e3440;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-c++&#34; data-lang=&#34;c++&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#81a1c1;font-weight:bold&#34;&gt;template&lt;/span&gt; &lt;span style=&#34;color:#81a1c1&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span style=&#34;color:#81a1c1;font-weight:bold&#34;&gt;class&lt;/span&gt; &lt;span style=&#34;color:#8fbcbb&#34;&gt;T&lt;/span&gt;&lt;span style=&#34;color:#81a1c1&#34;&gt;&amp;gt;&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#81a1c1;font-weight:bold&#34;&gt;class&lt;/span&gt; &lt;span style=&#34;color:#8fbcbb&#34;&gt;auto_ptr&lt;/span&gt;&lt;span style=&#34;color:#eceff4&#34;&gt;{&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#81a1c1;font-weight:bold&#34;&gt;public&lt;/span&gt;&lt;span style=&#34;color:#81a1c1&#34;&gt;:&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        auto_ptr&lt;span style=&#34;color:#eceff4&#34;&gt;(&lt;/span&gt;T &lt;span style=&#34;color:#81a1c1&#34;&gt;*&lt;/span&gt;p&lt;span style=&#34;color:#81a1c1&#34;&gt;=&lt;/span&gt;&lt;span style=&#34;color:#b48ead&#34;&gt;0&lt;/span&gt;&lt;span style=&#34;color:#eceff4&#34;&gt;)&lt;/span&gt;&lt;span style=&#34;color:#81a1c1&#34;&gt;:&lt;/span&gt;ptr&lt;span style=&#34;color:#eceff4&#34;&gt;(&lt;/span&gt;p&lt;span style=&#34;color:#eceff4&#34;&gt;)&lt;/span&gt; &lt;span style=&#34;color:#eceff4&#34;&gt;{}&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        &lt;span style=&#34;color:#81a1c1&#34;&gt;~&lt;/span&gt;auto_ptr&lt;span style=&#34;color:#eceff4&#34;&gt;()&lt;/span&gt; &lt;span style=&#34;color:#eceff4&#34;&gt;{&lt;/span&gt; &lt;span style=&#34;color:#81a1c1;font-weight:bold&#34;&gt;delete&lt;/span&gt; ptr&lt;span style=&#34;color:#eceff4&#34;&gt;;&lt;/span&gt; &lt;span style=&#34;color:#eceff4&#34;&gt;}&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        T&lt;span style=&#34;color:#81a1c1&#34;&gt;*&lt;/span&gt; &lt;span style=&#34;color:#81a1c1;font-weight:bold&#34;&gt;operator&lt;/span&gt;&lt;span style=&#34;color:#81a1c1&#34;&gt;-&amp;gt;&lt;/span&gt;&lt;span style=&#34;color:#eceff4&#34;&gt;()&lt;/span&gt;  &lt;span style=&#34;color:#81a1c1;font-weight:bold&#34;&gt;const&lt;/span&gt; &lt;span style=&#34;color:#eceff4&#34;&gt;{&lt;/span&gt; &lt;span style=&#34;color:#81a1c1;font-weight:bold&#34;&gt;return&lt;/span&gt; ptr&lt;span style=&#34;color:#eceff4&#34;&gt;;}&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&#x9;    T&lt;span style=&#34;color:#81a1c1&#34;&gt;&amp;amp;&lt;/span&gt; &lt;span style=&#34;color:#81a1c1;font-weight:bold&#34;&gt;operator&lt;/span&gt; &lt;span style=&#34;color:#81a1c1&#34;&gt;*&lt;/span&gt;&lt;span style=&#34;color:#eceff4&#34;&gt;()&lt;/span&gt;  &lt;span style=&#34;color:#81a1c1;font-weight:bold&#34;&gt;const&lt;/span&gt; &lt;span style=&#34;color:#eceff4&#34;&gt;{&lt;/span&gt; &lt;span style=&#34;color:#81a1c1;font-weight:bold&#34;&gt;return&lt;/span&gt; &lt;span style=&#34;color:#81a1c1&#34;&gt;*&lt;/span&gt;ptr&lt;span style=&#34;color:#eceff4&#34;&gt;;&lt;/span&gt; &lt;span style=&#34;color:#eceff4&#34;&gt;}&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#81a1c1;font-weight:bold&#34;&gt;private&lt;/span&gt;&lt;span style=&#34;color:#81a1c1&#34;&gt;:&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        T&lt;span style=&#34;color:#81a1c1&#34;&gt;*&lt;/span&gt;  ptr&lt;span style=&#34;color:#eceff4&#34;&gt;;&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#eceff4&#34;&gt;};&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#616e87;font-style:italic&#34;&gt;//结合智慧指针使用&#xA;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#616e87;font-style:italic&#34;&gt;&lt;/span&gt;&lt;span style=&#34;color:#81a1c1&#34;&gt;void&lt;/span&gt; &lt;span style=&#34;color:#88c0d0&#34;&gt;processAdoptions&lt;/span&gt;&lt;span style=&#34;color:#eceff4&#34;&gt;(&lt;/span&gt;istream&lt;span style=&#34;color:#81a1c1&#34;&gt;&amp;amp;&lt;/span&gt; dataSource&lt;span style=&#34;color:#eceff4&#34;&gt;){&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#81a1c1;font-weight:bold&#34;&gt;while&lt;/span&gt; &lt;span style=&#34;color:#eceff4&#34;&gt;(&lt;/span&gt;dataSource&lt;span style=&#34;color:#eceff4&#34;&gt;){&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        auto_ptr&lt;span style=&#34;color:#81a1c1&#34;&gt;&amp;lt;&lt;/span&gt;ALA&lt;span style=&#34;color:#81a1c1&#34;&gt;&amp;gt;&lt;/span&gt; pa&lt;span style=&#34;color:#eceff4&#34;&gt;(&lt;/span&gt;readALA&lt;span style=&#34;color:#eceff4&#34;&gt;(&lt;/span&gt;dataSource&lt;span style=&#34;color:#eceff4&#34;&gt;));&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        pa&lt;span style=&#34;color:#81a1c1&#34;&gt;-&amp;gt;&lt;/span&gt;processAdoption&lt;span style=&#34;color:#eceff4&#34;&gt;();&lt;/span&gt;&lt;span style=&#34;color:#616e87;font-style:italic&#34;&gt;//只要对象结束，就会自动delete&#xA;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#616e87;font-style:italic&#34;&gt;&lt;/span&gt;    &lt;span style=&#34;color:#eceff4&#34;&gt;}&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#eceff4&#34;&gt;}&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;h3 id=&#34;函数指针&#34;&gt;函数指针&lt;/h3&gt;&#xA;&lt;p&gt;函数指针能够像传递参数一样传递函数。并且也便于我们实现多态。&lt;/p&gt;&#xA;&lt;p&gt;对于函数指针的简单使用，我还是持开放态度的。但是众所周知，函数指针是能够复杂到令人呕吐的程度的。这种情况还是尽可能不要用函数指针了，要不就用 typedef 定义得好看点。不要恶心自己的同时还恶心他人……&lt;/p&gt;&#xA;&lt;h4 id=&#34;定义函数指针&#34;&gt;定义函数指针&lt;/h4&gt;&#xA;&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#d8dee9;background-color:#2e3440;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-cpp&#34; data-lang=&#34;cpp&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#81a1c1&#34;&gt;int&lt;/span&gt; &lt;span style=&#34;color:#eceff4&#34;&gt;(&lt;/span&gt;&lt;span style=&#34;color:#81a1c1&#34;&gt;*&lt;/span&gt;fp&lt;span style=&#34;color:#eceff4&#34;&gt;)(&lt;/span&gt;&lt;span style=&#34;color:#81a1c1&#34;&gt;int&lt;/span&gt;&lt;span style=&#34;color:#eceff4&#34;&gt;);&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;&lt;code&gt;fp&lt;/code&gt; 就可以存放返回值为 int，参数为一个 int 的函数了。&lt;/p&gt;&#xA;&lt;p&gt;可以这样理解：&lt;code&gt;fp&lt;/code&gt; 是标识符，&lt;code&gt;*fp&lt;/code&gt; 中的 &lt;code&gt;*&lt;/code&gt; 在说这个变量是个指针，最前面的 &lt;code&gt;int&lt;/code&gt; 和后面括号中的 &lt;code&gt;(int)&lt;/code&gt; 说明了这是函数指针，并指明了参数和返回值。&lt;/p&gt;</description>
    </item>
    <item>
      <title>专题定位</title>
      <link>https://huoxj.github.io/posts/%E7%AE%97%E6%B3%95%E4%B8%8E%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E4%B8%93%E9%A2%98%E5%AE%9A%E4%BD%8D/</link>
      <pubDate>Tue, 08 Oct 2024 00:00:00 +0000</pubDate>
      <guid>https://huoxj.github.io/posts/%E7%AE%97%E6%B3%95%E4%B8%8E%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E4%B8%93%E9%A2%98%E5%AE%9A%E4%BD%8D/</guid>
      <description>&lt;p&gt;本专题(算法与数据结构)主要用以复习与回忆，内容量少且相当不全面。&lt;/p&gt;&#xA;&lt;p&gt;写这个专题的主要原因是刷力扣的时候唤起了曾经竞赛的回忆，借博客给这些陈旧的知识重新打包装好，顺便应对以后保研或者应聘的机试。当然，能学些以前不会的知识自然是最好的。&lt;/p&gt;&#xA;&lt;p&gt;主要内容参考 &lt;a href=&#34;https://oi-wiki.org/&#34;&gt;OI Wiki&lt;/a&gt;，内容分类也是相同的方式。&lt;/p&gt;&#xA;&lt;p&gt;如果要从0开始学还是去看 Wiki 或者别的教程罢。这样一方面能减少写文章的压力，另一方面能学了不至于白学。&lt;/p&gt;&#xA;&lt;h2 id=&#34;已更新&#34;&gt;已更新&lt;/h2&gt;&#xA;&lt;h3 id=&#34;数据结构&#34;&gt;数据结构&lt;/h3&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;单调队列&lt;/li&gt;&#xA;&lt;li&gt;单调栈&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;h2 id=&#34;更新计划&#34;&gt;更新计划&lt;/h2&gt;&#xA;&lt;p&gt;基本是力扣&lt;/p&gt;</description>
    </item>
    <item>
      <title>单调队列 &amp; 单调栈</title>
      <link>https://huoxj.github.io/posts/%E7%AE%97%E6%B3%95%E4%B8%8E%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E5%8D%95%E8%B0%83%E9%98%9F%E5%88%97--%E5%8D%95%E8%B0%83%E6%A0%88/</link>
      <pubDate>Mon, 07 Oct 2024 00:00:00 +0000</pubDate>
      <guid>https://huoxj.github.io/posts/%E7%AE%97%E6%B3%95%E4%B8%8E%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E5%8D%95%E8%B0%83%E9%98%9F%E5%88%97--%E5%8D%95%E8%B0%83%E6%A0%88/</guid>
      <description>&lt;blockquote&gt;&#xA;&lt;p&gt;数据结构篇&lt;/p&gt;&#xA;&lt;/blockquote&gt;&#xA;&lt;h2 id=&#34;省流&#34;&gt;省流&lt;/h2&gt;&#xA;&lt;p&gt;单调队列：获得 区间(滑动窗口)的 最值&lt;/p&gt;&#xA;&lt;p&gt;单调栈：获得 某元素 周围 第一个 大于或者小于它 的元素&lt;/p&gt;&#xA;&lt;p&gt;实际运用多为以上两种情况，但仍需活学活用，不能被上面的两种情况限制。&lt;/p&gt;&#xA;&lt;h2 id=&#34;细说&#34;&gt;细说&lt;/h2&gt;&#xA;&lt;h3 id=&#34;单调队列&#34;&gt;单调队列&lt;/h3&gt;&#xA;&lt;h4 id=&#34;比喻&#34;&gt;比喻&lt;/h4&gt;&#xA;&lt;p&gt;之前在力扣评论区刷到过如下比喻：&lt;/p&gt;&#xA;&lt;p&gt;公司的所有员工按年龄排列成一个单调的队列。&lt;/p&gt;&#xA;&lt;p&gt;公司将不断招入年轻员工。如果年轻员工比某些老员工能力强，那就毫不犹豫踢掉这些老员工(补药啊)。&lt;/p&gt;&#xA;&lt;p&gt;同时，踢掉大于35岁的老员工，无论能力多强都踢掉。&lt;/p&gt;&#xA;&lt;p&gt;这个比喻就把单调队列的出入队概括完了，很好理解。&lt;/p&gt;&#xA;&lt;h4 id=&#34;为什么&#34;&gt;为什么&lt;/h4&gt;&#xA;&lt;p&gt;单调队列怎么做到通过维护一个队列，队头刚好是所求区间上的最大值呢（最小值同理，以下例子为最大值）？&lt;/p&gt;&#xA;&lt;p&gt;首先，很容易明白的一点，就是这个区间的最大值一定能留在队头。&lt;/p&gt;&#xA;&lt;p&gt;我们担心的是，这个最大值一旦离开区间了，谁来当二把手呢？&lt;/p&gt;&#xA;&lt;p&gt;我们想到可以搞个二把手候选人队列，有可能当二把手的元素都进来，从大到小排着，老大挂了就上老二。&lt;/p&gt;&#xA;&lt;p&gt;那为什么要让能力强的新人把比他弱的老东西踢掉呢？因为新人能活最久，并且当二把手的优先级也高于老东西，那这些老东西一定是不可能当二把手的，不符合我们队列的要求，所以直接踢掉。&lt;/p&gt;&#xA;&lt;h3 id=&#34;单调栈&#34;&gt;单调栈&lt;/h3&gt;&#xA;&lt;p&gt;单调栈也完全可以通过上面的比喻来理解。但是不能踢35岁老员工了，&lt;del&gt;单调栈是一个尊重老人的公司&lt;/del&gt;。&lt;/p&gt;&#xA;&lt;p&gt;获得 某元素 周围 第一个 大于或者小于它 的元素 是什么意思呢？&lt;/p&gt;&#xA;&lt;p&gt;当一个新人比一堆老员工强的时候，这些老员工全会被踢。所以，这个新人就是第一个比这些老员工强的人。换句话说，新入栈的元素是第一个比  因为这个元素而退栈的元素  大的元素。这句话很绕，慢点读别噎着了。&lt;/p&gt;&#xA;&lt;p&gt;但这样我们只能做一个方向。所以得维护两个单调栈，就能得到每个元素“周围”的满足要求的元素了。&lt;/p&gt;&#xA;&lt;h2 id=&#34;练练手&#34;&gt;练练手&lt;/h2&gt;&#xA;&lt;h3 id=&#34;单调队列-1&#34;&gt;单调队列&lt;/h3&gt;&#xA;&lt;p&gt;&lt;a href=&#34;https://leetcode.cn/problems/sliding-window-maximum/description/?envType=study-plan-v2&amp;amp;envId=top-100-liked&#34;&gt;力扣-滑动窗口最大值&lt;/a&gt;&lt;/p&gt;&#xA;&lt;p&gt;&lt;a href=&#34;https://www.luogu.com.cn/problem/P2698&#34;&gt;P2698 [USACO12MAR] Flowerpot S - 洛谷 | 计算机科学教育新生态 (luogu.com.cn)&lt;/a&gt; - 此题甚妙，有点难&lt;/p&gt;&#xA;&lt;h3 id=&#34;单调栈-1&#34;&gt;单调栈&lt;/h3&gt;&#xA;&lt;p&gt;&lt;a href=&#34;https://www.luogu.com.cn/problem/P5788&#34;&gt;P5788 【模板】单调栈 - 洛谷 | 计算机科学教育新生态 (luogu.com.cn)&lt;/a&gt;&lt;/p&gt;&#xA;&lt;p&gt;&lt;a href=&#34;https://www.luogu.com.cn/problem/P1901&#34;&gt;P1901 发射站 - 洛谷 | 计算机科学教育新生态 (luogu.com.cn)&lt;/a&gt;&lt;/p&gt;</description>
    </item>
    <item>
      <title>SE-ML04-决策树</title>
      <link>https://huoxj.github.io/posts/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/se-ml04-%E5%86%B3%E7%AD%96%E6%A0%91/</link>
      <pubDate>Mon, 30 Sep 2024 00:00:00 +0000</pubDate>
      <guid>https://huoxj.github.io/posts/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/se-ml04-%E5%86%B3%E7%AD%96%E6%A0%91/</guid>
      <description>&lt;h2 id=&#34;基本思想&#34;&gt;基本思想&lt;/h2&gt;&#xA;&lt;p&gt;决策树就是一颗 &lt;code&gt;if-else&lt;/code&gt; 树。树的每一个结点代表一个决策（测试），同时也代表了这个决策所对应的一个样本空间。我们的目标就是通过多次产生 &lt;code&gt;if-else&lt;/code&gt; 分支，尽可能地让决策树的叶子结点只包含相同标签的样本。&lt;/p&gt;&#xA;&lt;p&gt;既然是一棵树，我们就从&lt;strong&gt;递归建树&lt;/strong&gt;的角度来理解决策树的基本思想。&lt;/p&gt;&#xA;&lt;h3 id=&#34;基础&#34;&gt;基础&lt;/h3&gt;&#xA;&lt;p&gt;决策树的根节点代表了整个样本空间，没有任何划分或决策。&lt;/p&gt;&#xA;&lt;p&gt;下图的例子只有连续属性，将就看吧。&lt;/p&gt;&#xA;&lt;p&gt;&lt;img src=&#34;https://runzblog.oss-cn-hangzhou.aliyuncs.com/postimg/202409301003448.png&#34; alt=&#34;&#34;&gt;&lt;/p&gt;&#xA;&lt;h3 id=&#34;递归&#34;&gt;递归&lt;/h3&gt;&#xA;&lt;p&gt;假设我们在某一结点下。只考虑这个结点所代表的子样本空间。&lt;/p&gt;&#xA;&lt;p&gt;建树就是要加深树的深度，即产生 &lt;code&gt;if-else&lt;/code&gt; 分支。具体来说就是在当前的样本空间中插入决策边界，划分出的多个新的样本空间就是儿子们的样本空间。&lt;/p&gt;&#xA;&lt;p&gt;我们每次递归只选择样本的&lt;strong&gt;某一个属性&lt;/strong&gt;进行划分。&lt;/p&gt;&#xA;&lt;h4 id=&#34;离散属性&#34;&gt;离散属性&lt;/h4&gt;&#xA;&lt;p&gt;将这个属性的每一个取值都划出一个空间。&lt;/p&gt;&#xA;&lt;p&gt;假如这个属性$a$取值集合是$D={x, y, z}$，我们就划出三个空间，对应这三个取值。这样这个结点下就生出了三棵子树。&lt;code&gt;if-else&lt;/code&gt;如下：&lt;/p&gt;&#xA;&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#d8dee9;background-color:#2e3440;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-c&#34; data-lang=&#34;c&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#81a1c1;font-weight:bold&#34;&gt;if&lt;/span&gt;&lt;span style=&#34;color:#eceff4&#34;&gt;(&lt;/span&gt;a &lt;span style=&#34;color:#81a1c1&#34;&gt;==&lt;/span&gt; x&lt;span style=&#34;color:#eceff4&#34;&gt;)&lt;/span&gt; &lt;span style=&#34;color:#eceff4&#34;&gt;{&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&#x9;SubTree1&lt;span style=&#34;color:#eceff4&#34;&gt;;&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#eceff4&#34;&gt;}&lt;/span&gt;&lt;span style=&#34;color:#81a1c1;font-weight:bold&#34;&gt;else&lt;/span&gt; &lt;span style=&#34;color:#81a1c1;font-weight:bold&#34;&gt;if&lt;/span&gt;&lt;span style=&#34;color:#eceff4&#34;&gt;(&lt;/span&gt;a &lt;span style=&#34;color:#81a1c1&#34;&gt;==&lt;/span&gt; y&lt;span style=&#34;color:#eceff4&#34;&gt;)&lt;/span&gt; &lt;span style=&#34;color:#eceff4&#34;&gt;{&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&#x9;SubTree2&lt;span style=&#34;color:#eceff4&#34;&gt;;&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#eceff4&#34;&gt;}&lt;/span&gt;&lt;span style=&#34;color:#81a1c1;font-weight:bold&#34;&gt;else&lt;/span&gt; &lt;span style=&#34;color:#eceff4&#34;&gt;{&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&#x9;SubTree3&lt;span style=&#34;color:#eceff4&#34;&gt;;&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#eceff4&#34;&gt;}&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;h4 id=&#34;连续属性&#34;&gt;连续属性&lt;/h4&gt;&#xA;&lt;p&gt;基本方法就是将连续属性变成离散属性。常用的方法是二分法。&lt;/p&gt;&#xA;&lt;p&gt;对连续属性$A$，取合适的值$x$。通过如下函数，我们能得到一个离散属性$B={X, Y}$。&lt;/p&gt;&#xA;&lt;p&gt;$$&#xA;b=f(a)=\left{&#xA;\begin{aligned}&#xA;X, a\le x \&#xA;Y, a\gt x&#xA;\end{aligned}&#xA;\right.&#xA;$$&lt;/p&gt;&#xA;&lt;p&gt;取合适的值一般会取中位数。&lt;/p&gt;&#xA;&lt;p&gt;&lt;img src=&#34;https://runzblog.oss-cn-hangzhou.aliyuncs.com/postimg/202409301008219.png&#34; alt=&#34;&#34;&gt;&lt;/p&gt;&#xA;&lt;p&gt;如上图，我们横着插了一条决策边界，这条边界代表如下决策：&lt;/p&gt;&#xA;&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#d8dee9;background-color:#2e3440;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-c&#34; data-lang=&#34;c&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#81a1c1;font-weight:bold&#34;&gt;if&lt;/span&gt;&lt;span style=&#34;color:#eceff4&#34;&gt;(&lt;/span&gt;x &lt;span style=&#34;color:#81a1c1&#34;&gt;&amp;lt;=&lt;/span&gt; &lt;span style=&#34;color:#b48ead&#34;&gt;0.0596&lt;/span&gt;&lt;span style=&#34;color:#eceff4&#34;&gt;)&lt;/span&gt; &lt;span style=&#34;color:#eceff4&#34;&gt;{&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&#x9;LeftSubTree&lt;span style=&#34;color:#eceff4&#34;&gt;;&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#eceff4&#34;&gt;}&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#81a1c1;font-weight:bold&#34;&gt;else&lt;/span&gt; &lt;span style=&#34;color:#eceff4&#34;&gt;{&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&#x9;RightSubTree&lt;span style=&#34;color:#eceff4&#34;&gt;;&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#eceff4&#34;&gt;}&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;h3 id=&#34;停止条件&#34;&gt;停止条件&lt;/h3&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;只要当前结点的样本空间只存在一类标签的样本，我们就停止递归此结点。&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;blockquote&gt;&#xA;&lt;p&gt;这样会导致十分严重的过拟合。解决方法看后面。&lt;/p&gt;&#xA;&lt;/blockquote&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;当前属性集为空，或是所有样本在所有属性上取值相同，无法划分&lt;/li&gt;&#xA;&lt;li&gt;当前结点包含的样本集合为空，不能划分&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;h2 id=&#34;取最优划分属性&#34;&gt;取最优划分属性&lt;/h2&gt;&#xA;&lt;p&gt;我能想到三种取决策边界的方法。&lt;/p&gt;&#xA;&lt;h3 id=&#34;随便取&#34;&gt;随便取&lt;/h3&gt;&#xA;&lt;p&gt;没错，&lt;del&gt;随机永远是你大爷&lt;/del&gt;。我们随机取一个属性进行划分。&lt;/p&gt;</description>
    </item>
    <item>
      <title>博客初步搭建道路</title>
      <link>https://huoxj.github.io/posts/%E5%BB%BA%E8%AE%BE%E5%8D%9A%E5%AE%A2%E6%96%B0%E5%BE%81%E7%A8%8B/%E5%8D%9A%E5%AE%A2%E5%88%9D%E6%AD%A5%E6%90%AD%E5%BB%BA%E9%81%93%E8%B7%AF/</link>
      <pubDate>Sat, 28 Sep 2024 00:00:00 +0000</pubDate>
      <guid>https://huoxj.github.io/posts/%E5%BB%BA%E8%AE%BE%E5%8D%9A%E5%AE%A2%E6%96%B0%E5%BE%81%E7%A8%8B/%E5%8D%9A%E5%AE%A2%E5%88%9D%E6%AD%A5%E6%90%AD%E5%BB%BA%E9%81%93%E8%B7%AF/</guid>
      <description>&lt;h2 id=&#34;日益增长的博客需要&#34;&gt;日益增长的博客需要&lt;/h2&gt;&#xA;&lt;p&gt;写博客这件事，从初三开始打竞赛就已经提上日程了。当时很草率地创建了一个洛谷博客，然后一篇文章都没有www。后来又存在各种阻力，例如高中的学业压力、只有周末接触电子设备的机会。但对博客与日俱增的需求的动力也在对冲这些阻力。从一开始只是希望总结竞赛算法，到现在的记录学业、技术、生活等等方面的需求。于是在大三开学刚转完专业能够摸鱼之际，我真正开始着手于部署一个能暂且满足以上需要的博客。&lt;/p&gt;&#xA;&lt;h2 id=&#34;博客搭建初期探索&#34;&gt;博客搭建初期探索&lt;/h2&gt;&#xA;&lt;h3 id=&#34;自建自部署博客&#34;&gt;自建、自部署博客&lt;/h3&gt;&#xA;&lt;p&gt;为什么会考虑自己搭建博客框架、自己部署，原因如下：&lt;/p&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;有一台 阿里云ECS，宿舍有一台小服务器。可以锻炼部署能力，发扬折磨精神。顺便玩一下之前没怎么接触过的 Nginx&lt;/li&gt;&#xA;&lt;li&gt;系统性地修补我支离破碎的前端知识，磨练后端技术，增加项目经历。以后干不下去了可以搞开发。&lt;/li&gt;&#xA;&lt;li&gt;自建博客对日后变化的需求友好，可以随时迭代满足需要。而且能保证满足审美。&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;p&gt;这几个原因看着很踏实，但是当我一开始写了我才发现自己根本没有这个时间和精力。光这一点便难以支撑了😭。&lt;/p&gt;&#xA;&lt;blockquote&gt;&#xA;&lt;p&gt;日后对这一方案的评价：可以像 &lt;a href=&#34;jyywiki.cn&#34;&gt;jyy wiki&lt;/a&gt; 写纯html没css的博客。但还是需要一点时间。&lt;/p&gt;&#xA;&lt;/blockquote&gt;&#xA;&lt;h3 id=&#34;wordpress&#34;&gt;WordPress&lt;/h3&gt;&#xA;&lt;p&gt;上一方案破产之后，我转而尝试他人已经写好的框架。要说这个世界上最著名的自建网站框架，WordPress肯定是首屈一指的，于是我在宿舍的小服务器上搭建了WordPress，过程还是很简单的，网上教程多如牛毛。&lt;/p&gt;&#xA;&lt;p&gt;于我而言，WordPress的优点有三：&lt;/p&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;搭建方便。尤其是用 Docker，起两个容器就行了&lt;/li&gt;&#xA;&lt;li&gt;美化方便。WordPress主题数不胜数，并且很多主题可以在后台用GUI自定义一些元素。&lt;/li&gt;&#xA;&lt;li&gt;管理方便。WordPress后台功能齐全，界面还说的过去。&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;p&gt;缺点也有几个：&lt;/p&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;如果要开https，得每三个月续一次证书（虽然有工具可以自动化）&lt;/li&gt;&#xA;&lt;li&gt;功能太多了，图形界面用起来压力很大。想尽量简洁和轻量&lt;/li&gt;&#xA;&lt;li&gt;服务器反向代理时，我无法解决跨域请求资源的问题，我太菜了🤡&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;p&gt;总之，用起来哪哪都有一点不舒服。但是我感觉WordPress这个框架整体还是相当强大的，用不下去的主要原因除了上述缺点，更多的是我当时不太愿意深入研究这个框架。说不定我以后会用WordPress。&lt;/p&gt;&#xA;&lt;h3 id=&#34;静态博客框架&#34;&gt;静态博客框架&lt;/h3&gt;&#xA;&lt;p&gt;上面两个方案都是自部署的方案。除此之外便是托管部署了，比如 &lt;code&gt;Vercel&lt;/code&gt; 和 &lt;code&gt;Github Pages&lt;/code&gt; 这种。我真正愿意考虑这个方案的一大契机，是我的很多优秀学长的博客都是这个方案搭建的，而且看起来效果相当好。&lt;/p&gt;&#xA;&lt;p&gt;学长普遍是 &lt;code&gt;Hexo&lt;/code&gt; 框架 + &lt;code&gt;Github Pages&lt;/code&gt; 搭建。我也照做。当我在查阅 &lt;code&gt;Hexo&lt;/code&gt; 框架的文档和资料时，了解到了另一个叫&lt;code&gt;Hugo&lt;/code&gt;的框架。&lt;/p&gt;&#xA;&lt;p&gt;经过对比，我选择了&lt;code&gt;Hugo&lt;/code&gt;框架。&lt;code&gt;Hugo&lt;/code&gt;框架是基于&lt;code&gt;Go&lt;/code&gt;语言实现的，比&lt;code&gt;Hexo&lt;/code&gt;的&lt;code&gt;Node.js&lt;/code&gt;编译快很多。但是于我而言最主要的原因还是我在&lt;code&gt;Hugo&lt;/code&gt;的官方主题库里找到了心仪的主题&lt;a href=&#34;https://github.com/nunocoracao/blowfish&#34;&gt;BLowFish&lt;/a&gt;。&lt;/p&gt;&#xA;&lt;p&gt;最后，我习惯&lt;code&gt;Typora&lt;/code&gt;编写文本，所以顺便配了&lt;code&gt;阿里云oss&lt;/code&gt;做图床。再结合一些其他的需求，我目前的方案总结如下（PPT画的，不要在意拼写检查）：&lt;/p&gt;&#xA;&lt;p&gt;&lt;img src=&#34;https://runzblog.oss-cn-hangzhou.aliyuncs.com/postimg/202409281119985.png&#34; alt=&#34;image-20240928111917937&#34;&gt;&lt;/p&gt;&#xA;&lt;blockquote&gt;&#xA;&lt;p&gt;顺便一提，这样的技术栈图我还蛮喜欢的&lt;/p&gt;&#xA;&lt;/blockquote&gt;&#xA;&lt;h2 id=&#34;使用hugo搭建博客&#34;&gt;使用Hugo搭建博客&lt;/h2&gt;&#xA;&lt;h3 id=&#34;基本信息配置&#34;&gt;基本信息配置&lt;/h3&gt;&#xA;&lt;p&gt;基本信息配置主要在&lt;code&gt;hugo.toml&lt;/code&gt;这个文件里。我的主题还有诸如&lt;code&gt;params.toml&lt;/code&gt;、&lt;code&gt;menus.zh-cn.toml&lt;/code&gt;等配置文件。所以这都根据具体主题而定。不过基本按照Hugo文档、主题提供的文档以及自己稍微理解一下就能顺利配置博客的基本信息了。我后面主要介绍一些难点和进阶的部分。&lt;/p&gt;&#xA;&lt;h3 id=&#34;内容目录结构&#34;&gt;内容目录结构&lt;/h3&gt;&#xA;&lt;blockquote&gt;&#xA;&lt;p&gt;可以参考&lt;a href=&#34;https://gohugo.io/content-management/organization/&#34;&gt;Content organization | Hugo (gohugo.io)&lt;/a&gt;&lt;/p&gt;&#xA;&lt;/blockquote&gt;&#xA;&lt;p&gt;这部分是我比较诟病这类静态网页框架的一点，你的文章结构必须按照静态网页url里的结构来组织。比较正规的文件结构是这样的：&lt;/p&gt;</description>
    </item>
    <item>
      <title>使用VMware给物理硬盘装系统</title>
      <link>https://huoxj.github.io/posts/%E6%9C%89%E6%84%8F%E6%80%9D%E7%9A%84%E6%8A%98%E8%85%BE/%E4%BD%BF%E7%94%A8vmware%E7%BB%99%E7%89%A9%E7%90%86%E7%A1%AC%E7%9B%98%E8%A3%85%E7%B3%BB%E7%BB%9F/</link>
      <pubDate>Fri, 27 Sep 2024 00:00:00 +0000</pubDate>
      <guid>https://huoxj.github.io/posts/%E6%9C%89%E6%84%8F%E6%80%9D%E7%9A%84%E6%8A%98%E8%85%BE/%E4%BD%BF%E7%94%A8vmware%E7%BB%99%E7%89%A9%E7%90%86%E7%A1%AC%E7%9B%98%E8%A3%85%E7%B3%BB%E7%BB%9F/</guid>
      <description>&lt;h2 id=&#34;起因&#34;&gt;起因&lt;/h2&gt;&#xA;&lt;p&gt;由于手贱不小心删了Ubuntu自带的Python，服务器上的Ubuntu Server炸了。。。只能重新装一遍系统。但是我懒得做启动U盘了，所以索性直接在VMware里把系统给装起来。&lt;/p&gt;&#xA;&lt;h2 id=&#34;创建虚拟机并挂载物理磁盘&#34;&gt;创建虚拟机并挂载物理磁盘&lt;/h2&gt;&#xA;&lt;p&gt;只需要先下好你要装的系统的映象就行。然后把要装系统的硬盘装到你的电脑上。&#xA;还有很重要的一点，VMware一点要以&lt;strong&gt;管理员身份&lt;/strong&gt;启动！不然Windows不让加物理磁盘！&lt;/p&gt;&#xA;&lt;p&gt;首先随便创建一个虚拟机，配置选自定义。&lt;/p&gt;&#xA;&lt;p&gt;&lt;img src=&#34;https://runzblog.oss-cn-hangzhou.aliyuncs.com/postimg/Pasted%20image%2020240913151634.png&#34; alt=&#34;Pasted image 20240913151634&#34;&gt;&lt;/p&gt;&#xA;&lt;p&gt;在安装来源这里选稍后安装操作系统，或者直接选系统映象。&lt;/p&gt;&#xA;&lt;p&gt;&lt;img src=&#34;https://runzblog.oss-cn-hangzhou.aliyuncs.com/postimg/Pasted%20image%2020240913151818.png&#34; alt=&#34;Pasted image 20240913151818&#34;&gt;&lt;/p&gt;&#xA;&lt;p&gt;安装位置随便选一个地方就行，反正等会就给他删掉了。我直接放桌面。&lt;/p&gt;&#xA;&lt;p&gt;&lt;img src=&#34;https://runzblog.oss-cn-hangzhou.aliyuncs.com/postimg/Pasted%20image%2020240913151919.png&#34; alt=&#34;Pasted image 20240913151919&#34;&gt;&lt;/p&gt;&#xA;&lt;p&gt;内存、网络正常选就行。&#xA;I/O控制器选VMware推荐的&lt;code&gt;LSI Logic&lt;/code&gt;，其他的应该也没差。&lt;/p&gt;&#xA;&lt;p&gt;&lt;img src=&#34;https://runzblog.oss-cn-hangzhou.aliyuncs.com/postimg/Pasted%20image%2020240913152323.png&#34; alt=&#34;Pasted image 20240913152323&#34;&gt;&lt;/p&gt;&#xA;&lt;p&gt;虚拟磁盘类型选SATA或者NVMe，取决于你的物理磁盘是哪种类型的。我装在机械硬盘上，所以选SATA。&lt;/p&gt;&#xA;&lt;p&gt;&lt;img src=&#34;https://runzblog.oss-cn-hangzhou.aliyuncs.com/postimg/Pasted%20image%2020240913155440.png&#34; alt=&#34;Pasted image 20240913155440&#34;&gt;&lt;/p&gt;&#xA;&lt;p&gt;然后重要的来了，使用哪个磁盘这里选择使用物理磁盘。&lt;/p&gt;&#xA;&lt;p&gt;&lt;img src=&#34;https://runzblog.oss-cn-hangzhou.aliyuncs.com/postimg/Pasted%20image%2020240913152548.png&#34; alt=&#34;Pasted image 20240913152548&#34;&gt;&lt;/p&gt;&#xA;&lt;p&gt;这里如果没有用管理员身份启动VMware就会出问题：&lt;/p&gt;&#xA;&lt;p&gt;&lt;img src=&#34;https://runzblog.oss-cn-hangzhou.aliyuncs.com/postimg/Pasted%20image%2020240913152716.png&#34; alt=&#34;Pasted image 20240913152716&#34;&gt;&lt;/p&gt;&#xA;&lt;p&gt;然后就是选哪个PhysicalDrive的问题。这个只需要右键&lt;code&gt;此电脑&lt;/code&gt;-&lt;code&gt;管理&lt;/code&gt;-&lt;code&gt;磁盘管理&lt;/code&gt;里面看就行。&lt;/p&gt;&#xA;&lt;p&gt;&lt;img src=&#34;https://runzblog.oss-cn-hangzhou.aliyuncs.com/postimg/Pasted%20image%2020240913153011.png&#34; alt=&#34;Pasted image 20240913153011&#34;&gt;&lt;/p&gt;&#xA;&lt;p&gt;可以看到磁盘0、磁盘1和磁盘2。这就对应着PhysicalDrive的编号。然后选择&lt;code&gt;使用整个磁盘&lt;/code&gt;。&#xA;磁盘分区信息放桌面那里就行了。&lt;/p&gt;&#xA;&lt;h2 id=&#34;安装ubuntu-server&#34;&gt;安装Ubuntu Server&lt;/h2&gt;&#xA;&lt;p&gt;创建好虚拟机之后，如果你之前创建虚拟机的时候没有选择映象的话，在虚拟机设置里面的&lt;code&gt;CD/DVD&lt;/code&gt;中把映象选上去。然后启动时连接记得打开，不然&lt;/p&gt;&#xA;&lt;p&gt;&lt;img src=&#34;https://runzblog.oss-cn-hangzhou.aliyuncs.com/postimg/Pasted%20image%2020240913155651.png&#34; alt=&#34;Pasted image 20240913155651&#34;&gt;&lt;/p&gt;&#xA;&lt;p&gt;然后在硬盘一项中点击&lt;code&gt;高级&lt;/code&gt;，模式选择&lt;code&gt;独立&lt;/code&gt;-&lt;code&gt;永久&lt;/code&gt;&lt;/p&gt;&#xA;&lt;p&gt;&lt;img src=&#34;https://runzblog.oss-cn-hangzhou.aliyuncs.com/postimg/Pasted%20image%2020240913161135.png&#34; alt=&#34;Pasted image 20240913161135&#34;&gt;&lt;/p&gt;&#xA;&lt;p&gt;然后就是正常的安装流程了。基本会一点英文就能顺利通过啦~&lt;/p&gt;</description>
    </item>
    <item>
      <title>Linux根目录扩容</title>
      <link>https://huoxj.github.io/posts/%E6%9C%89%E6%84%8F%E6%80%9D%E7%9A%84%E6%8A%98%E8%85%BE/linux%E6%A0%B9%E7%9B%AE%E5%BD%95%E6%89%A9%E5%AE%B9/</link>
      <pubDate>Fri, 06 Sep 2024 00:00:00 +0000</pubDate>
      <guid>https://huoxj.github.io/posts/%E6%9C%89%E6%84%8F%E6%80%9D%E7%9A%84%E6%8A%98%E8%85%BE/linux%E6%A0%B9%E7%9B%AE%E5%BD%95%E6%89%A9%E5%AE%B9/</guid>
      <description>&lt;p&gt;&lt;a href=&#34;https://zhuanlan.zhihu.com/p/602888861&#34;&gt;linux新增磁盘或增加磁盘容量后，如何进行扩容 - 知乎 (zhihu.com)&lt;/a&gt;&lt;/p&gt;&#xA;&lt;p&gt;有时间补一下我是怎么操作的。&lt;/p&gt;</description>
    </item>
    <item>
      <title>实模式到保护模式</title>
      <link>https://huoxj.github.io/posts/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0/%E5%AE%9E%E6%A8%A1%E5%BC%8F%E5%88%B0%E4%BF%9D%E6%8A%A4%E6%A8%A1%E5%BC%8F/</link>
      <pubDate>Wed, 04 Sep 2024 00:00:00 +0000</pubDate>
      <guid>https://huoxj.github.io/posts/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0/%E5%AE%9E%E6%A8%A1%E5%BC%8F%E5%88%B0%E4%BF%9D%E6%8A%A4%E6%A8%A1%E5%BC%8F/</guid>
      <description>&lt;h1 id=&#34;开机-实模式到保护模式&#34;&gt;开机-实模式到保护模式&lt;/h1&gt;&#xA;&lt;p&gt;实模式到保护模式这个过程已经接触过很多次了。最早从软院OS实验的例行检查里背过相关内容，然后便不无意外地忘掉了。这次在OSDI课上又涉及到了这部分内容，趁此机会重温一下并写一个通俗易懂的笔记，以便以后查阅(可能并不会)。&lt;/p&gt;&#xA;&lt;h2 id=&#34;实模式&#34;&gt;实模式&lt;/h2&gt;&#xA;&lt;h3 id=&#34;摆龙门阵&#34;&gt;摆龙门阵&lt;/h3&gt;&#xA;&lt;p&gt;Intel为了兼容8086搞出来的玩意，在8、90年代很有用，但是对于现在来说还是太old-school了，所以新的&lt;a href=&#34;https://learn.microsoft.com/zh-cn/windows-hardware/drivers/bringup/boot-and-uefi&#34;&gt;UEFI启动&lt;/a&gt;方式已经渐渐取代了原来的BIOS，尽管我的装机U盘上的PE系统还保留了&lt;code&gt;Legacy&lt;/code&gt;启动。&lt;/p&gt;&#xA;&lt;p&gt;这里还有个&lt;a href=&#34;https://zhuanlan.zhihu.com/p/436122944&#34;&gt;UEFI和BIOS的区别 - 知乎&lt;/a&gt;专栏，有时间再看。&lt;/p&gt;&#xA;&lt;p&gt;我想，实模式作为入门OS的很大原因在于UEFI比较复杂，大学计算机课程只能以BIOS为框架进行教学，所以绕不开这个实模式到保护模式的转换。并且这个转换的过程能体现操作系统内存虚拟化的很多芝士，比如段页式内存管理。所以这一部分内容的理解还是有助于成为操作系统领域大神的www。&lt;/p&gt;&#xA;&lt;h3 id=&#34;实模式小介绍&#34;&gt;实模式小介绍&lt;/h3&gt;&#xA;&lt;blockquote&gt;&#xA;&lt;p&gt;摘自课程助教编写的实验文档&lt;/p&gt;&#xA;&lt;/blockquote&gt;&#xA;&lt;p&gt;在QEMU中，&lt;code&gt;i386&lt;/code&gt;为了保持向后兼容性，一开机并不是我们熟悉的&lt;code&gt;保护模式&lt;/code&gt;，而是&lt;code&gt;实模式&lt;/code&gt;。&lt;/p&gt;&#xA;&lt;p&gt;实模式简单来说就是一个16位的CPU，和保护模式相比，最主要有三点区别：&lt;/p&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;&#xA;&lt;p&gt;一是&lt;strong&gt;寄存器&lt;/strong&gt;&lt;/p&gt;&#xA;&lt;p&gt;不一样，实模式里只会用我们熟悉的寄存器的低16位，所以名字就少了前缀“E”，具体地有：&lt;/p&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;通用寄存器（16 位）：AX，BX，CX，DX，SP，BP，DI，SI&lt;/li&gt;&#xA;&lt;li&gt;段寄存器（16 位）：CS，DS，SS，ES&lt;/li&gt;&#xA;&lt;li&gt;状态和控制寄存器（16 位）： FLAGS，IP&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;&#xA;&lt;p&gt;二是&lt;strong&gt;寻址方式&lt;/strong&gt;不一样，在实模式里，虽然有段寄存器，但没有保护模式里的段表，更没有页表，物理地址就是 &lt;strong&gt;(段寄存器&amp;laquo;4) + 偏移地址&lt;/strong&gt; 。段寄存器16位，偏移地址也是16位，所以寻址空间就是2^20=1MiB。&lt;/p&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;&#xA;&lt;p&gt;三是&lt;strong&gt;中断处理&lt;/strong&gt;不一样，不过我们现在也不关心这个东西，有兴趣的话可以去搜索一下实模式的中断向量表，现在只需要大概知道中断都是由BIOS代办的就行了。&lt;/p&gt;&#xA;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;h2 id=&#34;bios执行过程以及两个模式&#34;&gt;BIOS执行过程以及两个模式&lt;/h2&gt;&#xA;&lt;p&gt;启动的第一条指令地址是&lt;code&gt;0xffff0&lt;/code&gt;。这个地址是BIOS ROM地址的最后，指令跳到ROM稍微靠前的地址&lt;code&gt;[CS:IP] 0f000:E05Bh&lt;/code&gt;。这个地址开始执行BIOS POST。&lt;/p&gt;&#xA;&lt;p&gt;这里会立马发生很重要的一个&lt;strong&gt;转换&lt;/strong&gt;，就是从实模式转成保护模式。&lt;/p&gt;&#xA;&lt;p&gt;原因是POST需要在保护下执行，否则实模式那点空间不够。&lt;/p&gt;&#xA;&lt;p&gt;自检完后通过&lt;code&gt;INT 19h&lt;/code&gt;开始自举。&lt;/p&gt;&#xA;&lt;p&gt;自举就是依次把每个磁盘的0扇区加载到&lt;code&gt;0x7c00&lt;/code&gt;然后看是不是MBR，即看扇区尾巴是不是&lt;code&gt;0x55&lt;/code&gt;和&lt;code&gt;0xaa&lt;/code&gt;，是的话自举滴任务就完成辣！&lt;/p&gt;&#xA;&lt;p&gt;其实还没有，自举谢幕前还要进行重要的一步，就是&lt;strong&gt;转换&lt;/strong&gt;回实模式。&lt;/p&gt;&#xA;&lt;p&gt;原因是要向后提供兼容。不是i386之前的架构的请自觉转到保护模式。&lt;/p&gt;&#xA;&lt;p&gt;总结为如下图：&lt;/p&gt;&#xA;&lt;p&gt;&lt;img src=&#34;https://runzblog.oss-cn-hangzhou.aliyuncs.com/postimg/202409271713413.png&#34; alt=&#34;image-20240904112540022&#34;&gt;&lt;/p&gt;&#xA;&lt;h2 id=&#34;实模式到保护模式&#34;&gt;实模式到保护模式&lt;/h2&gt;&#xA;&lt;p&gt;这部分是写本文最主要的目的，所以单独拉一个标题来写。&lt;/p&gt;&#xA;&lt;p&gt;实模式到保护模式主要是两步：设置段表GDT，再将CR0寄存器最低位置1。&lt;/p&gt;&#xA;&lt;p&gt;现在先只涉及GDT，LDT不管。&lt;/p&gt;&#xA;&lt;h3 id=&#34;保护模式的寻址怎么实现&#34;&gt;保护模式的寻址怎么实现&lt;/h3&gt;&#xA;&lt;p&gt;保护模式比实模式牛的地方之一就是实现了段式内存管理。我们都知道段式内存管理本质就是个二维寻址。&lt;/p&gt;&#xA;&lt;p&gt;保护模式下的&lt;strong&gt;寻址方式&lt;/strong&gt;如下：&lt;/p&gt;&#xA;&lt;p&gt;$$逻辑地址 = 段选择子_{16bits} \implies 段基址_{32bits} + 段内偏移_{32bits}$$&lt;/p&gt;&#xA;&lt;p&gt;&lt;code&gt;段选择子&lt;/code&gt;，可以根据字面意思理解记忆，就是记录选择了哪个段的东西。它存放在&lt;code&gt;段寄存器&lt;/code&gt;中。&lt;/p&gt;&#xA;&lt;p&gt;所以怎么从&lt;code&gt;段选择子&lt;/code&gt;拿到&lt;code&gt;段基址&lt;/code&gt;呢？这就要靠**&lt;code&gt;段表&lt;/code&gt;**了。&lt;/p&gt;&#xA;&lt;p&gt;段表细节见后面小标题，这里只需要知道通过&lt;code&gt;段选择子&lt;/code&gt;能找到段表中正确的项，而这个项(有名字，叫&lt;code&gt;段描述符&lt;/code&gt;)含有我们想要的很多信息，主要就是&lt;code&gt;段基址&lt;/code&gt;。&lt;/p&gt;&#xA;&lt;blockquote&gt;&#xA;&lt;p&gt;实验中提到了&amp;quot;扁平模式&amp;quot;，即将段基址全置0，这样偏移量就直接是逻辑地址了。&lt;/p&gt;&#xA;&lt;/blockquote&gt;&#xA;&lt;p&gt;这样就实现了保护模式的寻址。&lt;/p&gt;&#xA;&lt;h3 id=&#34;段表&#34;&gt;段表&lt;/h3&gt;&#xA;&lt;p&gt;&lt;code&gt;段表&lt;/code&gt;是个一位线性表。表项是前面说的&lt;code&gt;段描述符&lt;/code&gt;，一个&lt;code&gt;段描述符&lt;/code&gt;有64位，下面粗略说一下段描述符有哪些信息。&lt;/p&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;段基址：最主要的信息之一。占32位。&lt;/li&gt;&#xA;&lt;li&gt;段限长：段的长度，保证内存访问不会越界。也比较重要，占20位。&lt;/li&gt;&#xA;&lt;li&gt;其他控制位。包括段限长粒度、特权位等。&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;p&gt;详细来说，如下&lt;/p&gt;&#xA;&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;DESCRIPTORS USED FOR APPLICATIONS CODE AND DATA SEGMENTS&#xD;&#xA;&#xD;&#xA;  31                23                15                7               0&#xD;&#xA; +-----------------+-+-+-+-+---------+-+-----+-+-----+-+-----------------+&#xD;&#xA; |                 | | | |A|         | |     | |     | |                 |&#xD;&#xA; |   BASE 31..24   |G|X|O|V| LIMIT   |P| DPL |S| TYPE|A|  BASE 23..16    | 4&#xD;&#xA; |                 | | | |L| 19..16  | |     | |     | |                 |&#xD;&#xA; |-----------------+-+-+-+-+---------+-+-----+-+-----+-+-----------------|&#xD;&#xA; |                                   |                                   |&#xD;&#xA; |        SEGMENT BASE 15..0         |       SEGMENT LIMIT 15..0         | 0&#xD;&#xA; |                                   |                                   |&#xD;&#xA; +-----------------------------------+-----------------------------------+&#xD;&#xA;&#xD;&#xA;           A      - ACCESSED&#xD;&#xA;           AVL    - AVAILABLE FOR USE BY SYSTEMS PROGRAMMERS&#xD;&#xA;           DPL    - DESCRIPTOR PRIVILEGE LEVEL&#xD;&#xA;           G      - GRANULARITY&#xD;&#xA;           P      - SEGMENT PRESENT&#xA;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;具体大致看一下就行了，毕竟真要用到也不会有人记得清的。&lt;/p&gt;</description>
    </item>
    <item>
      <title>NPS折腾记录</title>
      <link>https://huoxj.github.io/posts/%E6%9C%89%E6%84%8F%E6%80%9D%E7%9A%84%E6%8A%98%E8%85%BE/nps%E6%8A%98%E8%85%BE%E8%AE%B0%E5%BD%95/</link>
      <pubDate>Sun, 01 Sep 2024 00:00:00 +0000</pubDate>
      <guid>https://huoxj.github.io/posts/%E6%9C%89%E6%84%8F%E6%80%9D%E7%9A%84%E6%8A%98%E8%85%BE/nps%E6%8A%98%E8%85%BE%E8%AE%B0%E5%BD%95/</guid>
      <description>&lt;h1 id=&#34;内网穿透折腾记录&#34;&gt;内网穿透折腾记录&lt;/h1&gt;&#xA;&lt;blockquote&gt;&#xA;&lt;p&gt;还是草稿，以后有时间写&lt;/p&gt;&#xA;&lt;/blockquote&gt;&#xA;&lt;p&gt;在宿舍里搞了一台ubuntu server折腾用。想在校园网的特殊环境下实现外网访问内网的需求，从而能随时使用个人博客与code server等服务。&lt;/p&gt;&#xA;&lt;p&gt;以下为我在大二开学诞生这个需求，直到大三开学才基本实现的一整年的折腾过程的记录。由于计算机网络方面的知识十分浅薄（日常吐槽计网），文章中可能会出现十分多不专业的内容，欢迎各位大佬勘误与科普。同时也给正在折腾的朋友们一些十分不严谨的参考。&lt;/p&gt;&#xA;&lt;h2 id=&#34;first-try&#34;&gt;First try&lt;/h2&gt;&#xA;&lt;p&gt;使用第三方frp/ngrok方案。&lt;/p&gt;&#xA;&lt;p&gt;这个方案源自于和朋友联机minecraft的经历。Minecraft服务器架设在内网端口，但可以通过一些frp服务来暴露到一个域名上，从而通过这个域名就能访问到mc服务器。&lt;/p&gt;&#xA;&lt;p&gt;对于其他的内网服务，这个方案基本也是可行的。好了问题解决了，这篇文章可以结束了。&lt;/p&gt;&#xA;&lt;p&gt;并不能。这种方案太不优雅了。临时使用的话现成frp或ngrok很不错。&lt;/p&gt;&#xA;&lt;p&gt;但是，使用现成frp缺点很多无法忍受：&lt;/p&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;极小的带宽。一般免费隧道带宽只有3M以内，付费也就10M封顶。如果是好几个人一起玩mc或者传个文件啥基本就爆了。&lt;/li&gt;&#xA;&lt;li&gt;限流量。之前用的好几个frp的流量都有每日签到领取，这个太难绷了。&lt;/li&gt;&#xA;&lt;li&gt;随机域名/定死的顶级域名。没法用自己的域名，这个接受程度因人而异。&lt;/li&gt;&#xA;&lt;li&gt;安全问题。数据都要走服务商那里转发，如果服务商被hack了就相当于裸奔了，不安全。&lt;/li&gt;&#xA;&lt;li&gt;隧道数限制、校园网拦截等等&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;p&gt;frp用了一两天后我直接关隧道跑路了，还是寻求其他方案吧。&lt;/p&gt;&#xA;&lt;h2 id=&#34;second-try&#34;&gt;Second try:&lt;/h2&gt;&#xA;&lt;p&gt;这次的方案转向了一个更加普遍的方案，就是直接通过某种方法拿到本机的公网IP。&lt;/p&gt;&#xA;&lt;p&gt;这种方案对于家里宽带有公网IPv4的十分方便且自由。但现在运营商基本不给公网ip了，所以IPv4基本走不通。&lt;/p&gt;&#xA;&lt;p&gt;但是，号称每一粒沙子都能分到地址的IPv6似乎就宽松很多了。如果能拿到服务器的IPv6地址，再绑个ddns，似乎基本就能实现我们的需求。&lt;/p&gt;&#xA;&lt;p&gt;开干。但是经历了九九八十一难，最终还是没能成功。&lt;/p&gt;&#xA;&lt;p&gt;第一难是路由器。我的路由器型号是Redmi 4A，官方的固件虽说能拿到IPv6的IP，但是没法关闭防火墙放行IPv6的出站流量。所以我给路由器刷了一个openwrt。&lt;/p&gt;&#xA;&lt;p&gt;第二难是openwrt。由于之前没接触过刷机，所以在找刷机包和编译上花了很多时间。最后还是用了大佬做好的刷机包。还好这个过程有breed防砖，不然路由器已经死了一百遍了。&lt;/p&gt;&#xA;&lt;p&gt;第三难是校园网IPv6分配。openwrt中获取到IPv6地址了，但是校园网的v6地址是/128的，也就是说真的只分配了一个地址，没法组子网。这个地址直接分给路由器了，路由器下的内网设备如果要以IPv&lt;/p&gt;&#xA;&lt;p&gt;6向外提供服务，就只能通过NAT6。这个NAT6难搞得一比，主要原因是路由器存储空间太小了，没法安装直接配置NAT6的插件。&lt;/p&gt;&#xA;&lt;p&gt;最后在这一步放弃了，因为在一次测试中突然发现了校园网是个大内网，你的路由器能上行不代表校园网中层层墙能让你上行……&lt;/p&gt;&#xA;&lt;p&gt;还有一个大问题。IPv6的站点只能由支持IPv6的设备访问，而就目前IPv6的普及情况……估计半数以上的情况都访问不了。&lt;/p&gt;&#xA;&lt;h2 id=&#34;third-try&#34;&gt;Third try&lt;/h2&gt;&#xA;&lt;p&gt;第二次尝试失败后，由于学业繁忙，折腾的进程陷入停滞……&lt;/p&gt;&#xA;&lt;p&gt;转机在软工II课上，我为课程项目的后端购买了一个阿里云ECS。使用ecs一段时间后，我突然想到，能不能将ecs的公网IP，用在我的内网服务上呢？&lt;/p&gt;&#xA;&lt;p&gt;答案是肯定的。这种利用云服务器实现内网穿透的方案就是代理。&lt;/p&gt;&#xA;&lt;h2 id=&#34;出问题辣&#34;&gt;出问题辣&lt;/h2&gt;&#xA;&lt;p&gt;通过公网服务器端口访问内网服务时，如果内网服务是像wordpress这种比较复杂的网页，就会发生一系列错误的重定向。&lt;/p&gt;&#xA;&lt;p&gt;以我的wordpress博客举例，访问&lt;code&gt;websiteIP:port&lt;/code&gt;的链接后，wp会返回301重定向，这个重定向会转到一系列链接&lt;/p&gt;&#xA;&lt;h2 id=&#34;reference&#34;&gt;Reference&lt;/h2&gt;&#xA;&lt;p&gt;&lt;a href=&#34;https://developer.aliyun.com/article/878758&#34;&gt;如何用阿里云实现内网穿透？如何在外网访问家里内网设备？-阿里云开发者社区 (aliyun.com)&lt;/a&gt;&lt;/p&gt;&#xA;&lt;p&gt;&lt;a href=&#34;https://hub.docker.com/r/ffdfgdfg/nps&#34;&gt;ffdfgdfg/nps - Docker Image | Docker Hub&lt;/a&gt;&lt;/p&gt;</description>
    </item>
    <item>
      <title>SE-ML01-概要</title>
      <link>https://huoxj.github.io/posts/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/se-ml01-%E6%A6%82%E8%A6%81/</link>
      <pubDate>Fri, 16 Aug 2024 00:00:00 +0000</pubDate>
      <guid>https://huoxj.github.io/posts/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/se-ml01-%E6%A6%82%E8%A6%81/</guid>
      <description>&lt;h2 id=&#34;定义&#34;&gt;定义&lt;/h2&gt;&#xA;&lt;h3 id=&#34;经典机器学习&#34;&gt;经典机器学习&lt;/h3&gt;&#xA;&lt;p&gt;学习是一个蕴含特定目的的知识获取过程。&lt;/p&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;内部表现为新知识的不断建立与修正&lt;/li&gt;&#xA;&lt;li&gt;外部表现为性能改善&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;h3 id=&#34;现代机器学习&#34;&gt;现代机器学习&lt;/h3&gt;&#xA;&lt;p&gt;任何通过&lt;strong&gt;数据训练&lt;/strong&gt;的&lt;strong&gt;学习算法&lt;/strong&gt;都属于机器学习&lt;/p&gt;&#xA;&lt;h2 id=&#34;基本术语&#34;&gt;基本术语&lt;/h2&gt;&#xA;&lt;h3 id=&#34;归纳偏好&#34;&gt;归纳偏好&lt;/h3&gt;&#xA;&lt;p&gt;ML 算法在学习过程中对某种类型假设的偏好。这种偏好一定存在。&lt;/p&gt;&#xA;&lt;p&gt;偏好最好与问题本身匹配，不然要用&lt;strong&gt;奥卡姆剃刀&lt;/strong&gt;删掉。&lt;/p&gt;&#xA;&lt;h3 id=&#34;nfl-定理&#34;&gt;NFL 定理&lt;/h3&gt;&#xA;&lt;p&gt;No Free Lunch 定理。一个算法 A 如果在某些问题上比另一个算法 B 好，必然存在另一些问题，B 比 A 好。&lt;/p&gt;&#xA;&lt;h3 id=&#34;分类和回归区别&#34;&gt;分类和回归区别&lt;/h3&gt;&#xA;&lt;p&gt;分类的输出是&lt;strong&gt;离散&lt;/strong&gt;值，回归的输出是&lt;strong&gt;连续&lt;/strong&gt;值。&lt;/p&gt;&#xA;&lt;h2 id=&#34;评价指标&#34;&gt;评价指标&lt;/h2&gt;&#xA;&lt;h3 id=&#34;混淆矩阵精度矩阵&#34;&gt;混淆矩阵、精度矩阵&lt;/h3&gt;&#xA;&lt;p&gt;精度矩阵是二分类下的混淆矩阵&lt;/p&gt;&#xA;&lt;h3 id=&#34;精度矩阵下的名词&#34;&gt;精度矩阵下的名词&lt;/h3&gt;&#xA;&lt;p&gt;&lt;code&gt;TRUE&lt;/code&gt;/&lt;code&gt;FALSE&lt;/code&gt;: 预测结果与实际相符/不符&lt;/p&gt;&#xA;&lt;p&gt;&lt;code&gt;POSITIVE&lt;/code&gt;/&lt;code&gt;NEGATIVE&lt;/code&gt;: 预测为真(阳性)/假(阴性)&lt;/p&gt;&#xA;&lt;h3 id=&#34;算术指标&#34;&gt;算术指标&lt;/h3&gt;&#xA;&lt;p&gt;&lt;img src=&#34;https://runzblog.oss-cn-hangzhou.aliyuncs.com/postimg/202409271712083.png&#34; alt=&#34;image-20240816164523881&#34;&gt;&lt;/p&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;&#xA;&lt;p&gt;Accuracy 精度&lt;/p&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;预测正确的比例&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;&#xA;&lt;p&gt;Sensitivity 敏感率&lt;/p&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;同查全率&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;&#xA;&lt;p&gt;Specificity 特异率&lt;/p&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;阴性里预测正确的比例&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;&#xA;&lt;p&gt;Precision 查准率&lt;/p&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;预测为阳性中真的阳了的比例&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;&#xA;&lt;p&gt;Recall 查全率&lt;/p&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;所有阳性中预测出来的比例&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;h2 id=&#34;统计学基本概念&#34;&gt;统计学基本概念&lt;/h2&gt;&#xA;&lt;h3 id=&#34;距离度量函数&#34;&gt;距离度量函数&lt;/h3&gt;&#xA;&lt;p&gt;对于两个样本 $x_i,x_j\in R^d$&lt;/p&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;欧式距离                $d(x_i, x_j)= \sqrt{(x_i-x_j)^T(x_i-x_j)}=||x_i-x_j||_2$&lt;/li&gt;&#xA;&lt;li&gt;曼哈顿距离            $d(x_i, x_j)=||x_i-x_j||_1$&lt;/li&gt;&#xA;&lt;li&gt;切比雪夫距离        $d(x_i, x_j)=||x_i-x_j||_\infty$&lt;/li&gt;&#xA;&lt;li&gt;余弦距离               $d(x_i, x_j)=\frac{x_i^Tx_j}{||x_i||\ ||x_j||}$&lt;/li&gt;&#xA;&lt;li&gt;马式距离               $d(x_i, x_j)=\sqrt{(x_i-x_j)^TM(x_i-x_j)}$&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;p&gt;&lt;img src=&#34;https://runzblog.oss-cn-hangzhou.aliyuncs.com/postimg/202410252021162.png&#34; alt=&#34;&#34;&gt;&lt;/p&gt;</description>
    </item>
    <item>
      <title>随记</title>
      <link>https://huoxj.github.io/posts/%E9%9A%8F%E8%AE%B0/%E9%9A%8F%E8%AE%B0/</link>
      <pubDate>Wed, 14 Aug 2024 00:00:00 +0000</pubDate>
      <guid>https://huoxj.github.io/posts/%E9%9A%8F%E8%AE%B0/%E9%9A%8F%E8%AE%B0/</guid>
      <description>&lt;h2 id=&#34;mock和test注解&#34;&gt;Mock和@Test注解&lt;/h2&gt;&#xA;&lt;p&gt;@Test注解一定要是&lt;code&gt;import org.junit.Test&lt;/code&gt;！如果是&lt;code&gt;org.junit.jupiter.api.Test&lt;/code&gt;会导致Mock的对象全部为&lt;code&gt;null&lt;/code&gt;&lt;/p&gt;</description>
    </item>
    <item>
      <title>毛概</title>
      <link>https://huoxj.github.io/posts/%E6%AF%9B%E6%A6%82/%E6%AF%9B%E6%A6%82/</link>
      <pubDate>Sun, 23 Jun 2024 00:00:00 +0000</pubDate>
      <guid>https://huoxj.github.io/posts/%E6%AF%9B%E6%A6%82/%E6%AF%9B%E6%A6%82/</guid>
      <description>&lt;h1 id=&#34;毛概复习-甘季国&#34;&gt;毛概复习-甘季国&lt;/h1&gt;&#xA;&lt;h2 id=&#34;导论&#34;&gt;导论&lt;/h2&gt;&#xA;&lt;h3 id=&#34;马克思主义中国化时代化的内涵&#34;&gt;马克思主义中国化时代化的内涵&lt;/h3&gt;&#xA;&lt;p&gt;马克思主义中国化时代化，就是&lt;/p&gt;&#xA;&lt;ol&gt;&#xA;&lt;li&gt;立足中国国情和时代特点，坚持把马克思主义基本原理同中国具体实际相结合、同中华优秀传统文化相结合，深入研究和解决中国不同历史时期的实际问题，真正搞懂面临的时代课题，不断吸收新的时代内容，科学回答时代提出的重大理论和实践课题，创造新的理论成果。&lt;/li&gt;&#xA;&lt;/ol&gt;&#xA;&lt;h3 id=&#34;马克思主义中国化时代化理论成果及其关系&#34;&gt;马克思主义中国化时代化理论成果及其关系&lt;/h3&gt;&#xA;&lt;h4 id=&#34;成果&#34;&gt;成果&lt;/h4&gt;&#xA;&lt;p&gt;在马克思主义中国化时代化的历史进程中，产生了毛泽东思想、邓小平理论、“三个代表”重要思想、科学发展观、习近平新时代中国特色社会主义思想&lt;/p&gt;&#xA;&lt;h4 id=&#34;关系&#34;&gt;关系&lt;/h4&gt;&#xA;&lt;p&gt;马克思主义中国化时代化的理论成果是&lt;strong&gt;一脉相承&lt;/strong&gt;又&lt;strong&gt;与时俱进&lt;/strong&gt;的关系。&lt;/p&gt;&#xA;&lt;p&gt;一方面，毛泽东思想所&lt;strong&gt;蕴含&lt;/strong&gt;的马克思主义的立场、观点和方法，为&lt;strong&gt;中国特色社会主义理论体系&lt;/strong&gt;提供了&lt;strong&gt;基本遵循&lt;/strong&gt;。&lt;/p&gt;&#xA;&lt;p&gt;另一方面，中国特色社会主义理论体系在&lt;strong&gt;新的历史条件&lt;/strong&gt;下进一步&lt;strong&gt;丰富和发展&lt;/strong&gt;了毛泽东思想。&lt;/p&gt;&#xA;&lt;p&gt;毛泽东思想和中国特色社会主义理论体系，都是马克思列宁主义&lt;strong&gt;在中国的运用和发展&lt;/strong&gt;，都以&lt;strong&gt;独创性的理论成果&lt;/strong&gt;丰富和发展了马克思主义的理论宝库。&lt;/p&gt;&#xA;&lt;p&gt;毛泽东思想、邓小平理论、“三个代表”重要思想、科学发展观、习近平新时代中国色社会主义思想同马克思列宁主义一起，都是党和国家必须长期坚持的&lt;strong&gt;指导思想&lt;/strong&gt;，是全国各族人民团结奋斗的共同&lt;strong&gt;思想基础&lt;/strong&gt;。&lt;/p&gt;&#xA;&lt;h2 id=&#34;第二章-新民主主义革命理论&#34;&gt;第二章 新民主主义革命理论&lt;/h2&gt;&#xA;&lt;h3 id=&#34;新民主主义革命的总路线&#34;&gt;新民主主义革命的总路线&lt;/h3&gt;&#xA;&lt;p&gt;新民主主义革命总路线：无产阶级领导的、人民大众的、反对帝国主义、封建主义和官僚资本主义的革命。&lt;/p&gt;&#xA;&lt;p&gt;反映了中国革命的基本规律，指明了中国革命的对象、动力、领导力量、性质和前途，是新民主主义革命的指导路线。&lt;/p&gt;&#xA;&lt;h3 id=&#34;新民主主义的基本纲领&#34;&gt;新民主主义的基本纲领&lt;/h3&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;政治纲领：推翻帝国主义和封建主义的统治，建立一个无产阶级领导的、以工农联盟为基础的、各革命阶级联合专政的新民主主义的共和国。&lt;/li&gt;&#xA;&lt;li&gt;经济纲领：没收封建地主阶级的土地归农民所有，没收官僚资产阶级的垄断资本归新民主主义的国家所有，保护民族工商业。&lt;/li&gt;&#xA;&lt;li&gt;文化纲领：新民主主义文化，就是无产阶级领导的人民大众的反帝反封建的文化，即民族的科学的大众的文化。&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;h3 id=&#34;新民主主义革命的道路&#34;&gt;新民主主义革命的道路&lt;/h3&gt;&#xA;&lt;p&gt;农村包围城市、武装夺取政权的革命道路&lt;/p&gt;&#xA;&lt;p&gt;内容：&lt;/p&gt;&#xA;&lt;ol&gt;&#xA;&lt;li&gt;土地革命是中国革命的基本内容；&lt;/li&gt;&#xA;&lt;li&gt;武装斗争是中国革命的主要形式，是农村根据地建设和土地革命的强有力保证；&lt;/li&gt;&#xA;&lt;li&gt;农村革命根据地是中国革命的战略阵地，是进行武装斗争和开展土地革命的依托&lt;/li&gt;&#xA;&lt;/ol&gt;&#xA;&lt;h3 id=&#34;新民主主义革命的三大法宝&#34;&gt;新民主主义革命的三大法宝&lt;/h3&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;统一战线&lt;/li&gt;&#xA;&lt;li&gt;武装斗争&lt;/li&gt;&#xA;&lt;li&gt;党的建设&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;p&gt;关系：&lt;/p&gt;&#xA;&lt;ol&gt;&#xA;&lt;li&gt;统一战线和武装斗争是中国革命的两个基本特点，是战胜敌人的两个基本武器。&lt;/li&gt;&#xA;&lt;li&gt;统一战线是实行武装斗争的统一战线，武装斗争是统一战线的中心支柱&lt;/li&gt;&#xA;&lt;li&gt;党的建设则是掌握统一战线和武装斗争这两个武器的基本保障。&lt;/li&gt;&#xA;&lt;/ol&gt;&#xA;&lt;h3 id=&#34;新民主主义革命理论的意义&#34;&gt;新民主主义革命理论的意义&lt;/h3&gt;&#xA;&lt;ol&gt;&#xA;&lt;li&gt;新民主主义革命理论，揭示了近代中国革命发展的客观规律，解决了中国革命的一系列理论问题，科学地回答了中国革命向何处去的问题，以及中国革命的发展阶段问题，极大地丰富了马克思主义的理论宝库。&lt;/li&gt;&#xA;&lt;li&gt;在新民主主义革命理论的指导下，党团结带领人民经过浴血奋战，完成了新民主主义革命，于1949年建立了中华人民共和国，实现了民族独立、人民解放。&lt;/li&gt;&#xA;&lt;li&gt;中国新民主主义革命的伟大胜利，是20世纪继俄国十月革命以后改变世界面貌的伟大历史事件，也极大改变了世界政治格局，鼓舞了全世界被压迫民族和被压迫人民争取解放的斗争，极大地增强了他们反对帝国主义斗争的信心，增强了世界人民争取和平的力量。&lt;/li&gt;&#xA;&lt;/ol&gt;&#xA;&lt;h2 id=&#34;第三章-社会主义改造理论&#34;&gt;第三章 社会主义改造理论&lt;/h2&gt;&#xA;&lt;h3 id=&#34;新民主主义社会是一个过渡性的社会&#34;&gt;新民主主义社会是一个过渡性的社会&lt;/h3&gt;&#xA;&lt;p&gt;从中华人民共和国成立到社会主义改造基本完成，是我国从新民主主义到社会主义的过渡时期。这一时期，我国社会的性质是新民主主义社会。新民主主义社会不是一个独立的社会形态，而是由新民主主义向社会主义转变的过渡性社会形态。&lt;/p&gt;&#xA;&lt;h3 id=&#34;党在过渡时期的总路线及其依据&#34;&gt;党在过渡时期的总路线及其依据&lt;/h3&gt;&#xA;&lt;p&gt;从中华人民共和国成立，到社会主义改造基本完成，这是一个过渡时期。党在这个过渡时期的总路线和总任务，是要在一个相当长的时期内，逐步实现国家的社会主义工业化，并逐步实现国家对农业、对手工业和对资本主义工商业的社会主义改造。&lt;/p&gt;&#xA;&lt;p&gt;&lt;strong&gt;现实依据&lt;/strong&gt;&lt;/p&gt;&#xA;&lt;ol&gt;&#xA;&lt;li&gt;&#xA;&lt;p&gt;经过1949年到1952年三年的努力，我国已经有了相对强大和迅速发展的社会主义国营经济，为党提出向社会主义过渡的总路线提供了物质基础。&lt;/p&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;&#xA;&lt;p&gt;土地改革完成后，为发展生产、抵御自然灾害，广大农民具有走互助合作道路的要求。&lt;/p&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;&#xA;&lt;p&gt;新中国成立初期，党和国家在合理调整工商业的过程中，出现了加工订货、经销代销、统购包销、公私合营等一系列从低级到高级的国家资本主义形式。&lt;/p&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;&#xA;&lt;p&gt;当时的国际形式有利于中国向社会主义过渡。&lt;/p&gt;&#xA;&lt;/li&gt;&#xA;&lt;/ol&gt;&#xA;&lt;h3 id=&#34;社会主义基本制度的确立及其理论根据&#34;&gt;社会主义基本制度的确立及其理论根据&lt;/h3&gt;&#xA;&lt;p&gt;&lt;strong&gt;确立&lt;/strong&gt;&lt;/p&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;1956年底，我国对农业、手工业和资本主义工商业的社会主义改造基本完成，农业、手工业个体所有制基本上转变成为公有制。&lt;/li&gt;&#xA;&lt;li&gt;随着社会主义改造的进行，我国的人民民主政治建设也在有步骤地向前推进。&lt;/li&gt;&#xA;&lt;li&gt;伴随着社会经济制度和社会经济结构的根本变化，我国社会的阶级关系也发生了根本的变化。&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;p&gt;&lt;strong&gt;理论&lt;/strong&gt;&lt;/p&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;一方面，中国可以在没有实现工业化的情况下进入社会主义，社会主义基本制度的确立正是为了推进中国的工业化、现代化建设;&lt;/li&gt;&#xA;&lt;li&gt;另一方面，由于经济文化还比较落后，中国的社会主义还只能是初级阶段的社会主义。不经过社会生产力的极大发展,是不可能超越这个阶段的&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;h3 id=&#34;确立社会主义基本制度的重大意义&#34;&gt;确立社会主义基本制度的重大意义&lt;/h3&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;社会主义基本制度的确立，为当代中国一切发展进步奠定了制度基础。社会主义制度的建立极大地提高了工人阶级和广大劳动人民的积极性、创造性，极大地促进了我国社会生产力的发展&lt;/li&gt;&#xA;&lt;li&gt;我国社会生产力的发展，初步显示了社会主义的优越性&lt;/li&gt;&#xA;&lt;li&gt;实现中华民族伟大复兴，必须建立符合我国实际的先进社会制度&lt;/li&gt;&#xA;&lt;li&gt;中国社会主义基本制度的确立，使占世界人口 1/5的东方大国进入了社会主义社会，这是世界社会主义发展史上又一个历史性的伟大胜利&lt;/li&gt;&#xA;&lt;li&gt;社会主义基本制度的确立，是以毛泽东同志为主要代表的中国共产党人对一个脱胎于半殖民地半封建的东方大国如何进行社会主义革命问题的系统回答和正确解决，是马克思列宁主义关于社会主义革命理论在中国的正确运用和创造性发展的结果&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;h2 id=&#34;第四章-社会主义建设道路初步探索的理论成果&#34;&gt;第四章 社会主义建设道路初步探索的理论成果&lt;/h2&gt;&#xA;&lt;h3 id=&#34;初步探索的重要理论成果&#34;&gt;初步探索的重要理论成果&lt;/h3&gt;&#xA;&lt;ol&gt;&#xA;&lt;li&gt;&#xA;&lt;p&gt;调动一切积极因素为社会主义事业服务&lt;/p&gt;</description>
    </item>
    <item>
      <title>Ex6 信号量与PV操作习题</title>
      <link>https://huoxj.github.io/posts/se%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/ex6-%E4%BF%A1%E5%8F%B7%E9%87%8F%E4%B8%8Epv%E6%93%8D%E4%BD%9C%E4%B9%A0%E9%A2%98/</link>
      <pubDate>Fri, 24 May 2024 00:00:00 +0000</pubDate>
      <guid>https://huoxj.github.io/posts/se%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/ex6-%E4%BF%A1%E5%8F%B7%E9%87%8F%E4%B8%8Epv%E6%93%8D%E4%BD%9C%E4%B9%A0%E9%A2%98/</guid>
      <description>&lt;h1 id=&#34;信号量与pv操作习题&#34;&gt;信号量与PV操作习题&lt;/h1&gt;&#xA;&lt;h2 id=&#34;读者写者问题&#34;&gt;读者写者问题&lt;/h2&gt;&#xA;&lt;h3 id=&#34;v1-读者优先策略&#34;&gt;v1-读者优先策略&lt;/h3&gt;&#xA;&lt;p&gt;&lt;img src=&#34;https://runzblog.oss-cn-hangzhou.aliyuncs.com/postimg/202409271721124.png&#34; alt=&#34;image-20240524100405216&#34;&gt;&lt;/p&gt;&#xA;&lt;p&gt;rmutex的理解&lt;/p&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;可以理解为更新临界资源readcount的坑位，同一时间只允许一个reader蹲在那里更新readcount&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;h2 id=&#34;理发师问题&#34;&gt;理发师问题&lt;/h2&gt;&#xA;&lt;blockquote&gt;&#xA;&lt;p&gt;一个理发师、一把理发椅、等候区容量N&lt;/p&gt;&#xA;&lt;p&gt;理发师：等候区有顾客就理发，没顾客睡觉&lt;/p&gt;&#xA;&lt;p&gt;顾客：等候区不满就进等候区，在等候区如果理发师睡觉就叫醒；等候区满就不理发了&lt;/p&gt;&#xA;&lt;/blockquote&gt;&#xA;&lt;p&gt;&lt;img src=&#34;https://runzblog.oss-cn-hangzhou.aliyuncs.com/postimg/202409271721753.png&#34; alt=&#34;&#34;&gt;&lt;/p&gt;&#xA;&lt;h3 id=&#34;重要思想&#34;&gt;重要思想&lt;/h3&gt;&#xA;&lt;p&gt;&lt;strong&gt;协同信号量&lt;/strong&gt;: waiting &amp;lt;-&amp;gt; customers&lt;/p&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;waiting变量和customers信号量是一对协同量，二者意义相同，数值也相同(除了customer可能为-1)。&lt;/li&gt;&#xA;&lt;li&gt;所以要用mutex信号量去保证二者在&lt;strong&gt;有顾客的时候&lt;/strong&gt;是同步变化的，这样去理解mutex就容易的多了&lt;/li&gt;&#xA;&lt;li&gt;&lt;strong&gt;为什么&lt;/strong&gt;？因为我们要判断if(waiting&amp;lt;CHAIRS)，假如没有waiting，我们就得判断if(customers&amp;lt;CHAIRS)，但是用户代码直接访问信号量的操作是不被允许的&lt;/li&gt;&#xA;&lt;/ul&gt;</description>
    </item>
    <item>
      <title>Lab3</title>
      <link>https://huoxj.github.io/posts/se%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/lab3/</link>
      <pubDate>Wed, 22 May 2024 00:00:00 +0000</pubDate>
      <guid>https://huoxj.github.io/posts/se%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/lab3/</guid>
      <description>&lt;blockquote&gt;&#xA;&lt;ol&gt;&#xA;&lt;li&gt;解释中断向量&lt;/li&gt;&#xA;&lt;/ol&gt;&#xA;&lt;/blockquote&gt;&#xA;&lt;p&gt;中断向量是确定中断服务程序的位置。包含段基址和偏移量。&lt;/p&gt;&#xA;&lt;blockquote&gt;&#xA;&lt;ol start=&#34;2&#34;&gt;&#xA;&lt;li&gt;解释中断类型码&lt;/li&gt;&#xA;&lt;/ol&gt;&#xA;&lt;/blockquote&gt;&#xA;&lt;p&gt;把每个中断服务程序进行编号，一个号代表一个中断服务程序，就是中断类型码，是计算机用来查找中断向量用的。(0-255)&lt;/p&gt;&#xA;&lt;blockquote&gt;&#xA;&lt;ol start=&#34;3&#34;&gt;&#xA;&lt;li&gt;解释中断向量表&lt;/li&gt;&#xA;&lt;/ol&gt;&#xA;&lt;/blockquote&gt;&#xA;&lt;p&gt;一片专门用来存放所有的中断向量的内存空间。&lt;/p&gt;&#xA;&lt;p&gt;在内存单元的最低处，地址空间为 00000H-003FFH (0-1024B)&lt;/p&gt;&#xA;&lt;p&gt;中断类型码 * 4 = 中断向量的首地址&lt;/p&gt;&#xA;&lt;p&gt;中断向量表提供了中断类型码与中断处理代码段入口地址的映射。&lt;/p&gt;&#xA;&lt;blockquote&gt;&#xA;&lt;ol start=&#34;4&#34;&gt;&#xA;&lt;li&gt;实模式下中断程序地址如何得到?&lt;/li&gt;&#xA;&lt;/ol&gt;&#xA;&lt;/blockquote&gt;&#xA;&lt;p&gt;根据中断类型码 n, 从中断向量表 n*4，取得中断处理程序的地址，段地址存入 CS，偏移量存入 IP，使得 CPU 转入中断程序运行。&lt;/p&gt;&#xA;&lt;blockquote&gt;&#xA;&lt;ol start=&#34;5&#34;&gt;&#xA;&lt;li&gt;保护模式下中断程序地址如何得到?&lt;/li&gt;&#xA;&lt;/ol&gt;&#xA;&lt;/blockquote&gt;&#xA;&lt;ol&gt;&#xA;&lt;li&gt;&#xA;&lt;p&gt;以 IDTR 中中断向量表的基址为起始地址 + 调用号 N*8 = 中断门描述符首地址，取出中断门的 8 个字节&lt;/p&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;&#xA;&lt;p&gt;根据中断门的选择子和偏移量得到中断处理程序入口&lt;/p&gt;&#xA;&lt;/li&gt;&#xA;&lt;/ol&gt;&#xA;&lt;blockquote&gt;&#xA;&lt;ol start=&#34;6&#34;&gt;&#xA;&lt;li&gt;中断向量的地址如何得到?&lt;/li&gt;&#xA;&lt;/ol&gt;&#xA;&lt;/blockquote&gt;&#xA;&lt;p&gt;中断类型码 * 4&lt;/p&gt;&#xA;&lt;blockquote&gt;&#xA;&lt;ol start=&#34;7&#34;&gt;&#xA;&lt;li&gt;实模式下如何根据中断向量的地址得到中断程序地址?&lt;/li&gt;&#xA;&lt;/ol&gt;&#xA;&lt;/blockquote&gt;&#xA;&lt;p&gt;低二字节为偏移量，高二字节为段地址&lt;/p&gt;&#xA;&lt;blockquote&gt;&#xA;&lt;ol start=&#34;8&#34;&gt;&#xA;&lt;li&gt;解释中断描述符&lt;/li&gt;&#xA;&lt;/ol&gt;&#xA;&lt;/blockquote&gt;&#xA;&lt;p&gt;中断描述符含有中断处理程序地址信息，还包括许多属性和类型位&lt;/p&gt;&#xA;&lt;p&gt;每个中断描述符占用连续的8个字节，中断描述符分为三类：任务门、中断门和自陷门，CPU对不同的门有不同的处理方式&lt;/p&gt;&#xA;&lt;p&gt;低1，2字节和高7，8字节存偏移量&lt;/p&gt;&#xA;&lt;p&gt;2，3字节是段选择符&lt;/p&gt;&#xA;&lt;p&gt;4，5字节是访问权限字节&lt;/p&gt;&#xA;&lt;blockquote&gt;&#xA;&lt;ol start=&#34;9&#34;&gt;&#xA;&lt;li&gt;保护模式下中断描述符表如何得到?&lt;/li&gt;&#xA;&lt;/ol&gt;&#xA;&lt;/blockquote&gt;&#xA;&lt;p&gt;通过IDTR读取IDT的基地址。&lt;/p&gt;&#xA;&lt;blockquote&gt;&#xA;&lt;ol start=&#34;10&#34;&gt;&#xA;&lt;li&gt;保护模式下中断门如何得到?&lt;/li&gt;&#xA;&lt;/ol&gt;&#xA;&lt;/blockquote&gt;&#xA;&lt;p&gt;IDT基地址+中断类型码*8&lt;/p&gt;&#xA;&lt;blockquote&gt;&#xA;&lt;ol start=&#34;11&#34;&gt;&#xA;&lt;li&gt;保护模式下如何根据中断门得到中断处理程序地址?&lt;/li&gt;&#xA;&lt;/ol&gt;&#xA;&lt;/blockquote&gt;&#xA;&lt;p&gt;中断门中的段选择符-&amp;gt;段基址 + 偏移量&lt;/p&gt;&#xA;&lt;blockquote&gt;&#xA;&lt;ol start=&#34;12&#34;&gt;&#xA;&lt;li&gt;中断的分类，举例不同类型的中断?&lt;/li&gt;&#xA;&lt;/ol&gt;&#xA;&lt;/blockquote&gt;&#xA;&lt;ol&gt;&#xA;&lt;li&gt;从&lt;strong&gt;中断源&lt;/strong&gt;的角度：&lt;/li&gt;&#xA;&lt;/ol&gt;&#xA;&lt;p&gt;&lt;strong&gt;内部异常中断&lt;/strong&gt;：由硬件异常或故障引起的&lt;/p&gt;&#xA;&lt;p&gt;&lt;strong&gt;软中断&lt;/strong&gt;：程序执行了中断指令引起的中断，由程序员通过 INT 或 INT3 指令触发，通常当做 trap 处理，实现系统调用&lt;/p&gt;&#xA;&lt;p&gt;&lt;strong&gt;外部中断&lt;/strong&gt; / IO 中断：外部设备请求引起的中断（又可分为可屏蔽中断（INTR 引脚）和不可屏蔽中断（NMI 引脚）：重启、电源故障、内存出错等影响整个系统工作的中断时不能被屏蔽的）&lt;/p&gt;</description>
    </item>
    <item>
      <title>推荐算法初探</title>
      <link>https://huoxj.github.io/posts/%E8%BD%AF%E5%B7%A5ii%E5%A4%A7%E4%BD%9C%E4%B8%9A-%E8%93%9D%E9%B2%B8%E5%95%86%E5%9F%8E/%E6%8E%A8%E8%8D%90%E7%AE%97%E6%B3%95%E5%88%9D%E6%8E%A2/</link>
      <pubDate>Tue, 21 May 2024 00:00:00 +0000</pubDate>
      <guid>https://huoxj.github.io/posts/%E8%BD%AF%E5%B7%A5ii%E5%A4%A7%E4%BD%9C%E4%B8%9A-%E8%93%9D%E9%B2%B8%E5%95%86%E5%9F%8E/%E6%8E%A8%E8%8D%90%E7%AE%97%E6%B3%95%E5%88%9D%E6%8E%A2/</guid>
      <description>&lt;h1 id=&#34;商品推荐算法初探&#34;&gt;商品推荐算法初探&lt;/h1&gt;&#xA;&lt;h2 id=&#34;分析&#34;&gt;分析&lt;/h2&gt;&#xA;&lt;h3 id=&#34;项目情况&#34;&gt;项目情况&lt;/h3&gt;&#xA;&lt;p&gt;蓝鲸网购商城，这个问题域下涉及的对象只有&lt;strong&gt;商品&lt;/strong&gt;和&lt;strong&gt;用户&lt;/strong&gt;。这两个对象和推荐算法相关的属性有如下：&lt;/p&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;商品&#xA;&lt;ul&gt;&#xA;&lt;li&gt;名称&lt;/li&gt;&#xA;&lt;li&gt;分类&lt;/li&gt;&#xA;&lt;li&gt;价格&lt;/li&gt;&#xA;&lt;li&gt;图片等复杂信息&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;用户&#xA;&lt;ul&gt;&#xA;&lt;li&gt;商品访问记录&#xA;&lt;ul&gt;&#xA;&lt;li&gt;访问次数&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;商品购买记录(订单)&#xA;&lt;ul&gt;&#xA;&lt;li&gt;订单价格&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;商品评分记录&#xA;&lt;ul&gt;&#xA;&lt;li&gt;评分&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;h3 id=&#34;需求&#34;&gt;需求&lt;/h3&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;能应对相对大量用户和商品的系统&lt;/li&gt;&#xA;&lt;li&gt;算法必须能在2核2g的服务器上正常运行&lt;/li&gt;&#xA;&lt;li&gt;使用在线算法&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;h3 id=&#34;约束&#34;&gt;约束&lt;/h3&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;开发时间紧张&lt;/li&gt;&#xA;&lt;li&gt;用户量和商品量十分小&#xA;&lt;ul&gt;&#xA;&lt;li&gt;可能有方法会改善这个情况，比如自动化生成工具&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;用户行为数据有限&#xA;&lt;ul&gt;&#xA;&lt;li&gt;因为要人工操作。但是同上。&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;h2 id=&#34;算法的选择&#34;&gt;算法的选择&lt;/h2&gt;&#xA;&lt;h3 id=&#34;基于用户的协同过滤-user-cf&#34;&gt;基于用户的协同过滤-User CF&lt;/h3&gt;&#xA;&lt;blockquote&gt;&#xA;&lt;p&gt;核心思想：人以群分，推荐和你最&lt;strong&gt;相似&lt;/strong&gt;的&lt;strong&gt;用户&lt;/strong&gt;喜欢的商品&lt;/p&gt;&#xA;&lt;/blockquote&gt;&#xA;&lt;h4 id=&#34;优点&#34;&gt;优点&lt;/h4&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;在线算法&lt;/li&gt;&#xA;&lt;li&gt;实现简单&lt;/li&gt;&#xA;&lt;li&gt;效率高&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;h4 id=&#34;缺点&#34;&gt;缺点&lt;/h4&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;十分依赖于其他用户和商品的交互数据。交互越多推荐效果越好。&lt;/li&gt;&#xA;&lt;li&gt;基于交互，会同时涉及用户和商品两个模块&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;h3 id=&#34;基于商品的协同过滤-item-cf&#34;&gt;基于商品的协同过滤-Item CF&lt;/h3&gt;&#xA;&lt;blockquote&gt;&#xA;&lt;p&gt;核心思想：物以类聚，推荐和&lt;strong&gt;你喜欢的商品&lt;/strong&gt;最&lt;strong&gt;相似&lt;/strong&gt;的商品，相似度基于交互&lt;/p&gt;&#xA;&lt;/blockquote&gt;&#xA;&lt;h4 id=&#34;优点-1&#34;&gt;优点&lt;/h4&gt;&#xA;&lt;p&gt;没怎么细看，我姑且认为这个更加准确吧&lt;/p&gt;&#xA;&lt;h4 id=&#34;缺点-1&#34;&gt;缺点&lt;/h4&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;算法要求先离线处理所有商品的相似度&lt;/li&gt;&#xA;&lt;li&gt;效率较慢&lt;/li&gt;&#xA;&lt;li&gt;基于交互，会同时涉及用户和商品两个模块&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;h3 id=&#34;基于内容的推荐算法&#34;&gt;基于内容的推荐算法&lt;/h3&gt;&#xA;&lt;blockquote&gt;&#xA;&lt;p&gt;核心思想：物以类聚，推荐和&lt;strong&gt;你喜欢的商品&lt;/strong&gt;最&lt;strong&gt;相似&lt;/strong&gt;的商品，相似度基于商品属性&lt;/p&gt;&#xA;&lt;/blockquote&gt;&#xA;&lt;h4 id=&#34;优点-2&#34;&gt;优点&lt;/h4&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;&#xA;&lt;p&gt;自然。推荐商品最直接、朴素的想法就是推荐内容相似的物品啦。&lt;/p&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;&#xA;&lt;p&gt;静态。基于商品稳定的属性。不用依赖于不稳定的用户与商品的交互。&lt;/p&gt;&#xA;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;h4 id=&#34;缺点-2&#34;&gt;缺点&lt;/h4&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;实现上不如前两种算法那么规范，主观性比较大。&lt;/li&gt;&#xA;&lt;/ul&gt;</description>
    </item>
    <item>
      <title>C5 文件管理</title>
      <link>https://huoxj.github.io/posts/se%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/c5-%E6%96%87%E4%BB%B6%E7%AE%A1%E7%90%86/</link>
      <pubDate>Thu, 16 May 2024 00:00:00 +0000</pubDate>
      <guid>https://huoxj.github.io/posts/se%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/c5-%E6%96%87%E4%BB%B6%E7%AE%A1%E7%90%86/</guid>
      <description>&lt;h1 id=&#34;第五章-文件管理&#34;&gt;第五章-文件管理&lt;/h1&gt;&#xA;&lt;h2 id=&#34;51-文件系统概述&#34;&gt;5.1-文件系统概述&lt;/h2&gt;&#xA;&lt;h3 id=&#34;引入文件的优点&#34;&gt;引入文件的优点&lt;/h3&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;用户使用方便，&lt;strong&gt;按名存取&lt;/strong&gt;&lt;/li&gt;&#xA;&lt;li&gt;文件安全可靠&lt;/li&gt;&#xA;&lt;li&gt;文件可备份&lt;/li&gt;&#xA;&lt;li&gt;文件可共享&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;h3 id=&#34;文件系统的功能&#34;&gt;文件系统的功能&lt;/h3&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;面向用户&#xA;&lt;ul&gt;&#xA;&lt;li&gt;按名存取&lt;/li&gt;&#xA;&lt;li&gt;共享和保护&lt;/li&gt;&#xA;&lt;li&gt;操作和使用&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;OS要实现&#xA;&lt;ul&gt;&#xA;&lt;li&gt;文件目录的建立与维护&lt;/li&gt;&#xA;&lt;li&gt;存储空间的分配和回收&lt;/li&gt;&#xA;&lt;li&gt;数据安全&lt;/li&gt;&#xA;&lt;li&gt;用户权限&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;h2 id=&#34;52-文件的存储&#34;&gt;5.2-文件的存储&lt;/h2&gt;&#xA;&lt;h3 id=&#34;物理文件&#34;&gt;物理文件&lt;/h3&gt;&#xA;&lt;p&gt;卷：介质的物理单位&lt;/p&gt;&#xA;&lt;p&gt;块：主存储器和辅助存储器进行信息交换的物理单位，也叫&lt;strong&gt;物理记录&lt;/strong&gt;&lt;/p&gt;&#xA;&lt;h3 id=&#34;逻辑文件&#34;&gt;逻辑文件&lt;/h3&gt;&#xA;&lt;h4 id=&#34;流式文件&#34;&gt;流式文件&lt;/h4&gt;&#xA;&lt;p&gt;文件中的数据是一串没有结构的字符流，比如一串字符串组成的文件&lt;/p&gt;&#xA;&lt;h4 id=&#34;记录式文件&#34;&gt;记录式文件&lt;/h4&gt;&#xA;&lt;p&gt;若干逻辑记录信息所组成的记录流文件。&lt;strong&gt;逻辑记录&lt;/strong&gt;是逻辑上的一坨信息的单位&lt;/p&gt;&#xA;&lt;h3 id=&#34;逻辑记录的成组与分解&#34;&gt;逻辑记录的成组与分解&lt;/h3&gt;&#xA;&lt;p&gt;这个条目解决了从&lt;strong&gt;逻辑记录大小&lt;/strong&gt;和&lt;strong&gt;物理记录大小&lt;/strong&gt;的&lt;strong&gt;不匹配&lt;/strong&gt;的问题&lt;/p&gt;&#xA;&lt;h4 id=&#34;优点&#34;&gt;优点&lt;/h4&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;节省存储空间&lt;/li&gt;&#xA;&lt;li&gt;减少IO次数&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;h4 id=&#34;特点&#34;&gt;特点&lt;/h4&gt;&#xA;&lt;p&gt;提前读：因为一次读了多个逻辑记录&lt;/p&gt;&#xA;&lt;p&gt;推迟写：要缓冲区逻辑记录满了才写&lt;/p&gt;&#xA;&lt;h4 id=&#34;长记录&#34;&gt;长记录&lt;/h4&gt;&#xA;&lt;!-- raw HTML omitted --&gt;&#xA;&lt;h4 id=&#34;变长记录&#34;&gt;变长记录&lt;/h4&gt;&#xA;&lt;!-- raw HTML omitted --&gt;&#xA;&lt;h4 id=&#34;跨块记录&#34;&gt;跨块记录&lt;/h4&gt;&#xA;&lt;!-- raw HTML omitted --&gt;&#xA;&lt;h3 id=&#34;文件的物理结构&#34;&gt;文件的物理结构&lt;/h3&gt;&#xA;&lt;p&gt;这个条目解决了从逻辑记录存到物理记录的&lt;strong&gt;组织&lt;/strong&gt;&lt;/p&gt;&#xA;&lt;h4 id=&#34;顺序文件&#34;&gt;顺序文件&lt;/h4&gt;&#xA;&lt;p&gt;逻辑记录——&lt;!-- raw HTML omitted --&gt;线性排列&lt;!-- raw HTML omitted --&gt;——&amp;gt;物理记录&lt;/p&gt;&#xA;&lt;p&gt;优点：顺序读取快&lt;/p&gt;&#xA;&lt;p&gt;缺点：无法动态分配、修改&lt;/p&gt;&#xA;&lt;h4 id=&#34;连接文件&#34;&gt;连接文件&lt;/h4&gt;&#xA;&lt;p&gt;逻辑记录——&lt;!-- raw HTML omitted --&gt;链表&lt;!-- raw HTML omitted --&gt;——&amp;gt;物理记录&lt;/p&gt;</description>
    </item>
    <item>
      <title>课堂知识点索引</title>
      <link>https://huoxj.github.io/posts/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86/%E8%AF%BE%E5%A0%82%E7%9F%A5%E8%AF%86%E7%82%B9%E7%B4%A2%E5%BC%95/</link>
      <pubDate>Sat, 11 May 2024 00:00:00 +0000</pubDate>
      <guid>https://huoxj.github.io/posts/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86/%E8%AF%BE%E5%A0%82%E7%9F%A5%E8%AF%86%E7%82%B9%E7%B4%A2%E5%BC%95/</guid>
      <description>&lt;h1 id=&#34;编译原理知识点索引&#34;&gt;编译原理知识点索引&lt;/h1&gt;&#xA;&lt;h2 id=&#34;声明&#34;&gt;声明&lt;/h2&gt;&#xA;&lt;p&gt;本文档只包含一些关键的知识点&lt;/p&gt;&#xA;&lt;h2 id=&#34;词法分析-正则表达式和自动机理论&#34;&gt;词法分析-正则表达式和自动机理论&lt;/h2&gt;&#xA;&lt;p&gt;对应Lecture-3&lt;/p&gt;&#xA;&lt;h3 id=&#34;定义&#34;&gt;定义&lt;/h3&gt;&#xA;&lt;h4 id=&#34;字母表&#34;&gt;字母表&lt;/h4&gt;&#xA;&lt;blockquote&gt;&#xA;&lt;p&gt;$$字母表\Sigma是一个有限的符号集合$$&lt;/p&gt;&#xA;&lt;/blockquote&gt;&#xA;&lt;h4 id=&#34;串&#34;&gt;串&lt;/h4&gt;&#xA;&lt;blockquote&gt;&#xA;&lt;p&gt;$$字母表\Sigma上的串s是由\Sigma中符号构成的一个有穷序列$$&lt;/p&gt;&#xA;&lt;p&gt;$空串:\epsilon$&lt;/p&gt;&#xA;&lt;/blockquote&gt;&#xA;&lt;h4 id=&#34;语言&#34;&gt;语言&lt;/h4&gt;&#xA;&lt;blockquote&gt;&#xA;&lt;p&gt;$语言是给定字母表\Sigma上一个任意的可数的串的集合$&lt;/p&gt;&#xA;&lt;/blockquote&gt;&#xA;&lt;h4 id=&#34;正则表达式&#34;&gt;正则表达式&lt;/h4&gt;&#xA;&lt;blockquote&gt;&#xA;&lt;p&gt;$给定字母表\Sigma, \Sigma上的正则表达式由且仅由以下规则定义:$&lt;/p&gt;&#xA;&lt;p&gt;(1) $\epsilon是正则表达式$&lt;/p&gt;&#xA;&lt;p&gt;(2) $\forall a\in\Sigma, a是正则表达式$&lt;/p&gt;&#xA;&lt;p&gt;(3) $如果r是正则表达式, 则(r)是正则表达式$&lt;/p&gt;&#xA;&lt;p&gt;(4) $如果r, s都是正则表达式, 则 r|s, rs, r^*也是正则表达式$&lt;/p&gt;&#xA;&lt;/blockquote&gt;&#xA;&lt;h4 id=&#34;nfanondeterministic-finite-automaton&#34;&gt;NFA(Nondeterministic Finite Automaton)&lt;/h4&gt;&#xA;&lt;blockquote&gt;&#xA;&lt;p&gt;$非确定性有穷自动机\mathcal{A}是一个五元组\mathcal{A}=(\Sigma,S,s_0,\delta,F)$&lt;/p&gt;&#xA;&lt;/blockquote&gt;&#xA;&lt;blockquote&gt;&#xA;&lt;p&gt;见课件-3-26&lt;/p&gt;&#xA;&lt;/blockquote&gt;&#xA;&lt;h4 id=&#34;dfadeterministic-finite-automaton&#34;&gt;DFA(Deterministic Finite Automaton)&lt;/h4&gt;&#xA;&lt;blockquote&gt;&#xA;&lt;p&gt;见课件-3-34&lt;/p&gt;&#xA;&lt;/blockquote&gt;&#xA;&lt;h3 id=&#34;re-nfa-dfa等价转化&#34;&gt;RE, NFA, DFA等价转化&lt;/h3&gt;&#xA;&lt;h4 id=&#34;re-nfa---thompson构造法&#34;&gt;RE-&amp;gt;NFA - Thompson构造法&lt;/h4&gt;&#xA;&lt;blockquote&gt;&#xA;&lt;p&gt;见课件-3-40:45&lt;/p&gt;&#xA;&lt;/blockquote&gt;&#xA;&lt;h4 id=&#34;nfa-dfa---子集构造法&#34;&gt;NFA-&amp;gt;DFA - 子集构造法&lt;/h4&gt;&#xA;&lt;blockquote&gt;&#xA;&lt;p&gt;原理见课件-3-54&lt;/p&gt;&#xA;&lt;/blockquote&gt;&#xA;&lt;p&gt;为什么叫子集构造法:&lt;/p&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;构造出的DFA的每一个状态$s_D\in S_D$, 对应原来NFA的状态的一个子集$s_D\subseteq 2^{S_N}$&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;p&gt;总结:&lt;/p&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;对NFA的每个状态求其对应**$\epsilon$闭包**, 即只通过$\epsilon$转移可达的状态集合. 这个集合中的状态可以被视作DFA中的&lt;strong&gt;一个&lt;/strong&gt;状态&lt;/li&gt;&#xA;&lt;li&gt;新的DFA中的状态的&lt;strong&gt;转移函数&lt;/strong&gt;是其对应NFA状态集合中每个状态的转移函数构成的. 这一条课件讲的更清楚&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;h4 id=&#34;dfa-dfa---dfa最小化&#34;&gt;DFA-&amp;gt;DFA - DFA最小化&lt;/h4&gt;&#xA;&lt;h2 id=&#34;ir-llvm&#34;&gt;IR-LLVM&lt;/h2&gt;&#xA;&lt;h4 id=&#34;llvm&#34;&gt;LLVM&lt;/h4&gt;&#xA;&lt;blockquote&gt;&#xA;&lt;p&gt;Low Level Virtual Machine&lt;/p&gt;</description>
    </item>
    <item>
      <title>Jenkins部署Maven项目到Docker</title>
      <link>https://huoxj.github.io/posts/%E8%BD%AF%E5%B7%A5ii%E5%A4%A7%E4%BD%9C%E4%B8%9A-%E8%93%9D%E9%B2%B8%E5%95%86%E5%9F%8E/jenkins%E9%83%A8%E7%BD%B2maven%E9%A1%B9%E7%9B%AE%E5%88%B0docker/</link>
      <pubDate>Fri, 10 May 2024 00:00:00 +0000</pubDate>
      <guid>https://huoxj.github.io/posts/%E8%BD%AF%E5%B7%A5ii%E5%A4%A7%E4%BD%9C%E4%B8%9A-%E8%93%9D%E9%B2%B8%E5%95%86%E5%9F%8E/jenkins%E9%83%A8%E7%BD%B2maven%E9%A1%B9%E7%9B%AE%E5%88%B0docker/</guid>
      <description>&lt;h1 id=&#34;使用jenkins部署maven项目到docker&#34;&gt;使用Jenkins部署Maven项目到Docker&lt;/h1&gt;&#xA;&lt;blockquote&gt;&#xA;&lt;p&gt;Jenkins：能够自动配置、自动部署项目。通过Webhook可以实现项目一旦被Push就会自动重新配置项目并且部署，以实现更新&lt;/p&gt;&#xA;&lt;/blockquote&gt;&#xA;&lt;h2 id=&#34;1-准备步骤&#34;&gt;1 准备步骤&lt;/h2&gt;&#xA;&lt;h3 id=&#34;11-安装docker&#34;&gt;1.1 安装Docker&lt;/h3&gt;&#xA;&lt;p&gt;这步比较简单，网上教程也很多，故省略&lt;/p&gt;&#xA;&lt;h3 id=&#34;12-拉取jenkins镜像&#34;&gt;1.2 拉取jenkins镜像&lt;/h3&gt;&#xA;&lt;p&gt;执行拉取镜像的命令&lt;/p&gt;&#xA;&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#d8dee9;background-color:#2e3440;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-bash&#34; data-lang=&#34;bash&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;docker pull jenkins/jenkins:lts&#xA;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;查看当前的镜像，可以发现jenkins已经在列表里了&lt;/p&gt;&#xA;&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#d8dee9;background-color:#2e3440;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-bash&#34; data-lang=&#34;bash&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;docker images&#xA;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;REPOSITORY          TAG       IMAGE ID       CREATED         SIZE&#xD;&#xA;bluewhale-backend   master    044e4cb8919f   16 hours ago    318MB&#xD;&#xA;mysql               latest    f3df03e3cfc9   8 days ago      585MB&#xD;&#xA;jenkins/jenkins     lts       4e586344183a   3 weeks ago     469MB&#xD;&#xA;openjdk             8-jre     0c14a0e20aa3   21 months ago   274MB&#xA;&lt;/code&gt;&lt;/pre&gt;&lt;h3 id=&#34;13-创建容器&#34;&gt;1.3 创建容器&lt;/h3&gt;&#xA;&lt;p&gt;使用&lt;strong&gt;run&lt;/strong&gt;命令从镜像创建容器&lt;/p&gt;&#xA;&lt;p&gt;&lt;strong&gt;镜像和容器&lt;/strong&gt;的关系就像&lt;strong&gt;类和对象的&lt;/strong&gt;关系&lt;/p&gt;&#xA;&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#d8dee9;background-color:#2e3440;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-bash&#34; data-lang=&#34;bash&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;docker run -d --restart&lt;span style=&#34;color:#81a1c1&#34;&gt;=&lt;/span&gt;always -uroot &lt;span style=&#34;color:#ebcb8b&#34;&gt;\&#xA;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#ebcb8b&#34;&gt;&lt;/span&gt;--name jenkins &lt;span style=&#34;color:#ebcb8b&#34;&gt;\&#xA;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#ebcb8b&#34;&gt;&lt;/span&gt;-p 8080:8080 &lt;span style=&#34;color:#ebcb8b&#34;&gt;\&#xA;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#ebcb8b&#34;&gt;&lt;/span&gt;-v /home/jenkins:/var/jenkins_home &lt;span style=&#34;color:#ebcb8b&#34;&gt;\&#xA;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#ebcb8b&#34;&gt;&lt;/span&gt;-v /var/run/docker.sock:/var/run/docker.sock &lt;span style=&#34;color:#ebcb8b&#34;&gt;\&#xA;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#ebcb8b&#34;&gt;&lt;/span&gt;-v /usr/bin/docker:/usr/bin/docker &lt;span style=&#34;color:#ebcb8b&#34;&gt;\&#xA;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#ebcb8b&#34;&gt;&lt;/span&gt;-v ~/.ssh/:/root/.ssh &lt;span style=&#34;color:#ebcb8b&#34;&gt;\&#xA;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#ebcb8b&#34;&gt;&lt;/span&gt;jenkins/jenkins:lts&#xA;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;&lt;strong&gt;参数说明&lt;/strong&gt;&lt;/p&gt;</description>
    </item>
    <item>
      <title>随记</title>
      <link>https://huoxj.github.io/posts/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86/%E9%9A%8F%E8%AE%B0/</link>
      <pubDate>Thu, 09 May 2024 00:00:00 +0000</pubDate>
      <guid>https://huoxj.github.io/posts/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86/%E9%9A%8F%E8%AE%B0/</guid>
      <description>&lt;h1 id=&#34;随记&#34;&gt;随记&lt;/h1&gt;&#xA;&lt;h2 id=&#34;pumping-theorem的理解&#34;&gt;Pumping Theorem的理解&lt;/h2&gt;&#xA;&lt;p&gt;&lt;img src=&#34;https://runzblog.oss-cn-hangzhou.aliyuncs.com/postimg/202409271714016.png&#34; alt=&#34;image-20240509220414719&#34;&gt;&lt;/p&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;&#xA;&lt;p&gt;一个&lt;strong&gt;足够长&lt;/strong&gt;的，能被正则表达式$r$接受的&lt;strong&gt;字符串&lt;/strong&gt;，一定能分成$xyz$三个部分。因为$r$对应DFA的状态数$p$是有限的，而串的长度大于$p$时，一定有&lt;strong&gt;一个&lt;/strong&gt;状态被经历了&lt;strong&gt;两次及以上&lt;/strong&gt;&lt;/p&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;&#xA;&lt;p&gt;其中$y$对应$r$的DFA中起始状态和结束状态是同一个状态&lt;/p&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;&#xA;&lt;p&gt;由于是同一个状态，我就可以接受任意多个$y$，所以$xy^iz\in L$肯定成立&lt;/p&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;&#xA;&lt;p&gt;扩展：上下文无关法的Pumping Theorem，具体可见课件里面&lt;/p&gt;&#xA;&lt;/li&gt;&#xA;&lt;/ul&gt;</description>
    </item>
    <item>
      <title>知识点随记</title>
      <link>https://huoxj.github.io/posts/%E8%BD%AF%E5%B7%A5ii%E5%A4%A7%E4%BD%9C%E4%B8%9A-%E8%93%9D%E9%B2%B8%E5%95%86%E5%9F%8E/%E7%9F%A5%E8%AF%86%E7%82%B9%E9%9A%8F%E8%AE%B0/</link>
      <pubDate>Wed, 08 May 2024 00:00:00 +0000</pubDate>
      <guid>https://huoxj.github.io/posts/%E8%BD%AF%E5%B7%A5ii%E5%A4%A7%E4%BD%9C%E4%B8%9A-%E8%93%9D%E9%B2%B8%E5%95%86%E5%9F%8E/%E7%9F%A5%E8%AF%86%E7%82%B9%E9%9A%8F%E8%AE%B0/</guid>
      <description>&lt;h2 id=&#34;jpa使用specification动态查询&#34;&gt;JPA使用Specification动态查询&lt;/h2&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;解决动态多条件查询的问题。我们可能会设置许多查询条件，但实际查询时只会用到其中的某一些条件，动态查询能保证只查询这一部分条件。&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;h3 id=&#34;实现&#34;&gt;实现&lt;/h3&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;Repository接口继承&lt;code&gt;JpaSpecificationExecuter&amp;lt;T&amp;gt;&lt;/code&gt;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#d8dee9;background-color:#2e3440;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-java&#34; data-lang=&#34;java&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#81a1c1;font-weight:bold&#34;&gt;public&lt;/span&gt; &lt;span style=&#34;color:#81a1c1;font-weight:bold&#34;&gt;interface&lt;/span&gt; &lt;span style=&#34;color:#8fbcbb&#34;&gt;ItemRepository&lt;/span&gt; &lt;span style=&#34;color:#81a1c1;font-weight:bold&#34;&gt;extends&lt;/span&gt; &#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    JpaRepository&lt;span style=&#34;color:#81a1c1&#34;&gt;&amp;lt;&lt;/span&gt;Item&lt;span style=&#34;color:#eceff4&#34;&gt;,&lt;/span&gt;Integer&lt;span style=&#34;color:#81a1c1&#34;&gt;&amp;gt;&lt;/span&gt;&lt;span style=&#34;color:#eceff4&#34;&gt;,&lt;/span&gt; JpaSpecificationExecutor&lt;span style=&#34;color:#81a1c1&#34;&gt;&amp;lt;&lt;/span&gt;Item&lt;span style=&#34;color:#81a1c1&#34;&gt;&amp;gt;&lt;/span&gt;&lt;span style=&#34;color:#eceff4&#34;&gt;{}&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;ul&gt;&#xA;&lt;li&gt;新建处理Specification的类，便于构造筛选条件&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#d8dee9;background-color:#2e3440;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-java&#34; data-lang=&#34;java&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#81a1c1;font-weight:bold&#34;&gt;public&lt;/span&gt; &lt;span style=&#34;color:#81a1c1;font-weight:bold&#34;&gt;class&lt;/span&gt; &lt;span style=&#34;color:#8fbcbb&#34;&gt;itemSpecification&lt;/span&gt; &lt;span style=&#34;color:#eceff4&#34;&gt;{&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#81a1c1;font-weight:bold&#34;&gt;public&lt;/span&gt; &lt;span style=&#34;color:#81a1c1;font-weight:bold&#34;&gt;static&lt;/span&gt; Specification&lt;span style=&#34;color:#81a1c1&#34;&gt;&amp;lt;&lt;/span&gt;Item&lt;span style=&#34;color:#81a1c1&#34;&gt;&amp;gt;&lt;/span&gt; &lt;span style=&#34;color:#88c0d0&#34;&gt;whereItem&lt;/span&gt;&lt;span style=&#34;color:#eceff4&#34;&gt;(&lt;/span&gt;Map&lt;span style=&#34;color:#81a1c1&#34;&gt;&amp;lt;&lt;/span&gt;String&lt;span style=&#34;color:#eceff4&#34;&gt;,&lt;/span&gt; Object&lt;span style=&#34;color:#81a1c1&#34;&gt;&amp;gt;&lt;/span&gt; params&lt;span style=&#34;color:#eceff4&#34;&gt;)&lt;/span&gt; &lt;span style=&#34;color:#eceff4&#34;&gt;{&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        &lt;span style=&#34;color:#616e87;font-style:italic&#34;&gt;// 通过匿名内部类实现Specification接口&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        &lt;span style=&#34;color:#616e87;font-style:italic&#34;&gt;// 摘自 https://blog.csdn.net/weixin_46005530/article/details/132626158&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        &lt;span style=&#34;color:#81a1c1;font-weight:bold&#34;&gt;return&lt;/span&gt; &lt;span style=&#34;color:#eceff4&#34;&gt;(&lt;/span&gt;Root&lt;span style=&#34;color:#81a1c1&#34;&gt;&amp;lt;&lt;/span&gt;Item&lt;span style=&#34;color:#81a1c1&#34;&gt;&amp;gt;&lt;/span&gt; root&lt;span style=&#34;color:#eceff4&#34;&gt;,&lt;/span&gt; CriteriaQuery&lt;span style=&#34;color:#81a1c1&#34;&gt;&amp;lt;?&amp;gt;&lt;/span&gt; query&lt;span style=&#34;color:#eceff4&#34;&gt;,&lt;/span&gt; CriteriaBuilder cb&lt;span style=&#34;color:#eceff4&#34;&gt;)&lt;/span&gt; &lt;span style=&#34;color:#81a1c1&#34;&gt;-&amp;gt;&lt;/span&gt; &lt;span style=&#34;color:#eceff4&#34;&gt;{&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;            List&lt;span style=&#34;color:#81a1c1&#34;&gt;&amp;lt;&lt;/span&gt;Predicate&lt;span style=&#34;color:#81a1c1&#34;&gt;&amp;gt;&lt;/span&gt; predicates &lt;span style=&#34;color:#81a1c1&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#81a1c1;font-weight:bold&#34;&gt;new&lt;/span&gt; ArrayList&lt;span style=&#34;color:#81a1c1&#34;&gt;&amp;lt;&amp;gt;&lt;/span&gt;&lt;span style=&#34;color:#eceff4&#34;&gt;();&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;            &lt;span style=&#34;color:#616e87;font-style:italic&#34;&gt;// 处理name参数&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;            String name &lt;span style=&#34;color:#81a1c1&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#eceff4&#34;&gt;(&lt;/span&gt;String&lt;span style=&#34;color:#eceff4&#34;&gt;)&lt;/span&gt; params&lt;span style=&#34;color:#eceff4&#34;&gt;.&lt;/span&gt;&lt;span style=&#34;color:#8fbcbb&#34;&gt;get&lt;/span&gt;&lt;span style=&#34;color:#eceff4&#34;&gt;(&lt;/span&gt;&lt;span style=&#34;color:#a3be8c&#34;&gt;&amp;#34;name&amp;#34;&lt;/span&gt;&lt;span style=&#34;color:#eceff4&#34;&gt;);&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;            &lt;span style=&#34;color:#81a1c1;font-weight:bold&#34;&gt;if&lt;/span&gt; &lt;span style=&#34;color:#eceff4&#34;&gt;(&lt;/span&gt;name &lt;span style=&#34;color:#81a1c1&#34;&gt;!=&lt;/span&gt; &lt;span style=&#34;color:#81a1c1;font-weight:bold&#34;&gt;null&lt;/span&gt;&lt;span style=&#34;color:#eceff4&#34;&gt;)&lt;/span&gt; &lt;span style=&#34;color:#eceff4&#34;&gt;{&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;                &lt;span style=&#34;color:#616e87;font-style:italic&#34;&gt;// 模糊查询的实现: cb.like&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;                predicates&lt;span style=&#34;color:#eceff4&#34;&gt;.&lt;/span&gt;&lt;span style=&#34;color:#8fbcbb&#34;&gt;add&lt;/span&gt;&lt;span style=&#34;color:#eceff4&#34;&gt;(&lt;/span&gt;cb&lt;span style=&#34;color:#eceff4&#34;&gt;.&lt;/span&gt;&lt;span style=&#34;color:#8fbcbb&#34;&gt;like&lt;/span&gt;&lt;span style=&#34;color:#eceff4&#34;&gt;(&lt;/span&gt;root&lt;span style=&#34;color:#eceff4&#34;&gt;.&lt;/span&gt;&lt;span style=&#34;color:#8fbcbb&#34;&gt;get&lt;/span&gt;&lt;span style=&#34;color:#eceff4&#34;&gt;(&lt;/span&gt;&lt;span style=&#34;color:#a3be8c&#34;&gt;&amp;#34;name&amp;#34;&lt;/span&gt;&lt;span style=&#34;color:#eceff4&#34;&gt;),&lt;/span&gt; &lt;span style=&#34;color:#a3be8c&#34;&gt;&amp;#34;%&amp;#34;&lt;/span&gt; &lt;span style=&#34;color:#81a1c1&#34;&gt;+&lt;/span&gt; name &lt;span style=&#34;color:#81a1c1&#34;&gt;+&lt;/span&gt; &lt;span style=&#34;color:#a3be8c&#34;&gt;&amp;#34;%&amp;#34;&lt;/span&gt;&lt;span style=&#34;color:#eceff4&#34;&gt;));&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;            &lt;span style=&#34;color:#eceff4&#34;&gt;}&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;            &lt;span style=&#34;color:#eceff4&#34;&gt;...&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;            &lt;span style=&#34;color:#616e87;font-style:italic&#34;&gt;// 处理category参数&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;            String catName &lt;span style=&#34;color:#81a1c1&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#eceff4&#34;&gt;(&lt;/span&gt;String&lt;span style=&#34;color:#eceff4&#34;&gt;)&lt;/span&gt; params&lt;span style=&#34;color:#eceff4&#34;&gt;.&lt;/span&gt;&lt;span style=&#34;color:#8fbcbb&#34;&gt;get&lt;/span&gt;&lt;span style=&#34;color:#eceff4&#34;&gt;(&lt;/span&gt;&lt;span style=&#34;color:#a3be8c&#34;&gt;&amp;#34;category&amp;#34;&lt;/span&gt;&lt;span style=&#34;color:#eceff4&#34;&gt;);&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;            CategoryEnum category &lt;span style=&#34;color:#81a1c1&#34;&gt;=&lt;/span&gt; CategoryEnum&lt;span style=&#34;color:#eceff4&#34;&gt;.&lt;/span&gt;&lt;span style=&#34;color:#8fbcbb&#34;&gt;valueOf&lt;/span&gt;&lt;span style=&#34;color:#eceff4&#34;&gt;(&lt;/span&gt;catName&lt;span style=&#34;color:#eceff4&#34;&gt;);&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;            &lt;span style=&#34;color:#81a1c1;font-weight:bold&#34;&gt;if&lt;/span&gt;&lt;span style=&#34;color:#eceff4&#34;&gt;(&lt;/span&gt;catName &lt;span style=&#34;color:#81a1c1&#34;&gt;!=&lt;/span&gt; &lt;span style=&#34;color:#81a1c1;font-weight:bold&#34;&gt;null&lt;/span&gt;&lt;span style=&#34;color:#eceff4&#34;&gt;){&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;                predicates&lt;span style=&#34;color:#eceff4&#34;&gt;.&lt;/span&gt;&lt;span style=&#34;color:#8fbcbb&#34;&gt;add&lt;/span&gt;&lt;span style=&#34;color:#eceff4&#34;&gt;(&lt;/span&gt;cb&lt;span style=&#34;color:#eceff4&#34;&gt;.&lt;/span&gt;&lt;span style=&#34;color:#8fbcbb&#34;&gt;equal&lt;/span&gt;&lt;span style=&#34;color:#eceff4&#34;&gt;(&lt;/span&gt;root&lt;span style=&#34;color:#eceff4&#34;&gt;.&lt;/span&gt;&lt;span style=&#34;color:#8fbcbb&#34;&gt;get&lt;/span&gt;&lt;span style=&#34;color:#eceff4&#34;&gt;(&lt;/span&gt;&lt;span style=&#34;color:#a3be8c&#34;&gt;&amp;#34;category&amp;#34;&lt;/span&gt;&lt;span style=&#34;color:#eceff4&#34;&gt;),&lt;/span&gt; category&lt;span style=&#34;color:#eceff4&#34;&gt;));&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;            &lt;span style=&#34;color:#eceff4&#34;&gt;}&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;            &lt;span style=&#34;color:#616e87;font-style:italic&#34;&gt;// 返回封装好的查询条件&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;            &lt;span style=&#34;color:#81a1c1;font-weight:bold&#34;&gt;return&lt;/span&gt; query&lt;span style=&#34;color:#eceff4&#34;&gt;.&lt;/span&gt;&lt;span style=&#34;color:#8fbcbb&#34;&gt;where&lt;/span&gt;&lt;span style=&#34;color:#eceff4&#34;&gt;(&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;                predicates&lt;span style=&#34;color:#eceff4&#34;&gt;.&lt;/span&gt;&lt;span style=&#34;color:#8fbcbb&#34;&gt;toArray&lt;/span&gt;&lt;span style=&#34;color:#eceff4&#34;&gt;(&lt;/span&gt;&lt;span style=&#34;color:#81a1c1;font-weight:bold&#34;&gt;new&lt;/span&gt; Predicate&lt;span style=&#34;color:#81a1c1&#34;&gt;[&lt;/span&gt;predicates&lt;span style=&#34;color:#eceff4&#34;&gt;.&lt;/span&gt;&lt;span style=&#34;color:#8fbcbb&#34;&gt;size&lt;/span&gt;&lt;span style=&#34;color:#eceff4&#34;&gt;()&lt;/span&gt;&lt;span style=&#34;color:#81a1c1&#34;&gt;]&lt;/span&gt;&lt;span style=&#34;color:#eceff4&#34;&gt;)&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;            &lt;span style=&#34;color:#eceff4&#34;&gt;).&lt;/span&gt;&lt;span style=&#34;color:#8fbcbb&#34;&gt;getRestriction&lt;/span&gt;&lt;span style=&#34;color:#eceff4&#34;&gt;();&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        &lt;span style=&#34;color:#eceff4&#34;&gt;}&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#eceff4&#34;&gt;}&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#eceff4&#34;&gt;}&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;ul&gt;&#xA;&lt;li&gt;在&lt;code&gt;ServiceImpl&lt;/code&gt;层直接&lt;code&gt;findAll&lt;/code&gt;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#d8dee9;background-color:#2e3440;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-java&#34; data-lang=&#34;java&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#d08770&#34;&gt;@Override&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#81a1c1;font-weight:bold&#34;&gt;public&lt;/span&gt; List&lt;span style=&#34;color:#81a1c1&#34;&gt;&amp;lt;&lt;/span&gt;Item&lt;span style=&#34;color:#81a1c1&#34;&gt;&amp;gt;&lt;/span&gt; &lt;span style=&#34;color:#88c0d0&#34;&gt;getItemByConditions&lt;/span&gt;&lt;span style=&#34;color:#eceff4&#34;&gt;(&lt;/span&gt;Map&lt;span style=&#34;color:#81a1c1&#34;&gt;&amp;lt;&lt;/span&gt;String&lt;span style=&#34;color:#eceff4&#34;&gt;,&lt;/span&gt; Object&lt;span style=&#34;color:#81a1c1&#34;&gt;&amp;gt;&lt;/span&gt; params&lt;span style=&#34;color:#eceff4&#34;&gt;){&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        &lt;span style=&#34;color:#81a1c1;font-weight:bold&#34;&gt;return&lt;/span&gt; itemRepository&lt;span style=&#34;color:#eceff4&#34;&gt;.&lt;/span&gt;&lt;span style=&#34;color:#8fbcbb&#34;&gt;findAll&lt;/span&gt;&lt;span style=&#34;color:#eceff4&#34;&gt;(&lt;/span&gt;itemSpecification&lt;span style=&#34;color:#eceff4&#34;&gt;.&lt;/span&gt;&lt;span style=&#34;color:#8fbcbb&#34;&gt;whereItem&lt;/span&gt;&lt;span style=&#34;color:#eceff4&#34;&gt;(&lt;/span&gt;params&lt;span style=&#34;color:#eceff4&#34;&gt;));&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#eceff4&#34;&gt;}&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;h3 id=&#34;细节&#34;&gt;细节&lt;/h3&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;用Map&amp;lt;String, Object&amp;gt;存不确定的筛选条件，模拟了一个不确定格式的JSON&#xA;&lt;ul&gt;&#xA;&lt;li&gt;在Controller层可以用&lt;code&gt;@RequestBody&lt;/code&gt;传也可以用&lt;code&gt;@RequestParams&lt;/code&gt;传&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#d8dee9;background-color:#2e3440;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-java&#34; data-lang=&#34;java&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#d08770&#34;&gt;@RequestBody&lt;/span&gt; Map&lt;span style=&#34;color:#81a1c1&#34;&gt;&amp;lt;&lt;/span&gt;String&lt;span style=&#34;color:#eceff4&#34;&gt;,&lt;/span&gt; Object&lt;span style=&#34;color:#81a1c1&#34;&gt;&amp;gt;&lt;/span&gt; map&#xA;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;ul&gt;&#xA;&lt;li&gt;从Enum名字(String)到Enum类(和Integer等价)的转换，用&lt;code&gt;xxxEnum.valueOf(str)&lt;/code&gt;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#d8dee9;background-color:#2e3440;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-java&#34; data-lang=&#34;java&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;String catName &lt;span style=&#34;color:#81a1c1&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#eceff4&#34;&gt;(&lt;/span&gt;String&lt;span style=&#34;color:#eceff4&#34;&gt;)&lt;/span&gt; params&lt;span style=&#34;color:#eceff4&#34;&gt;.&lt;/span&gt;&lt;span style=&#34;color:#8fbcbb&#34;&gt;get&lt;/span&gt;&lt;span style=&#34;color:#eceff4&#34;&gt;(&lt;/span&gt;&lt;span style=&#34;color:#a3be8c&#34;&gt;&amp;#34;category&amp;#34;&lt;/span&gt;&lt;span style=&#34;color:#eceff4&#34;&gt;);&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;CategoryEnum category &lt;span style=&#34;color:#81a1c1&#34;&gt;=&lt;/span&gt; CategoryEnum&lt;span style=&#34;color:#eceff4&#34;&gt;.&lt;/span&gt;&lt;span style=&#34;color:#8fbcbb&#34;&gt;valueOf&lt;/span&gt;&lt;span style=&#34;color:#eceff4&#34;&gt;(&lt;/span&gt;catName&lt;span style=&#34;color:#eceff4&#34;&gt;);&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;h2 id=&#34;data注解&#34;&gt;@data注解&lt;/h2&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;@data注解可以自动生成无参构造函数、Getter、Setter和toString等方法&lt;/li&gt;&#xA;&lt;li&gt;可以用于VO和PO(DAO)的注解，替代@Getter、@Setter、@NoArgsConstructor一系列注解&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;h2 id=&#34;docker上部署mysql-server的持久化&#34;&gt;Docker上部署Mysql Server的持久化&lt;/h2&gt;&#xA;&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#d8dee9;background-color:#2e3440;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-bash&#34; data-lang=&#34;bash&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;docker run -p 3306:3306 --name mysql &lt;span style=&#34;color:#ebcb8b&#34;&gt;\&#xA;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#ebcb8b&#34;&gt;&lt;/span&gt;-v /home/docker/mysql/log:/var/log/mysql &lt;span style=&#34;color:#ebcb8b&#34;&gt;\&#xA;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#ebcb8b&#34;&gt;&lt;/span&gt;-v /home/docker/mysql/data:/var/lib/mysql &lt;span style=&#34;color:#ebcb8b&#34;&gt;\&#xA;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#ebcb8b&#34;&gt;&lt;/span&gt;-v /home/docker/mysql/conf:/etc/mysql/conf.d &lt;span style=&#34;color:#ebcb8b&#34;&gt;\&#xA;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#ebcb8b&#34;&gt;&lt;/span&gt;-e MYSQL_ROOT_PASSWORD&lt;span style=&#34;color:#81a1c1&#34;&gt;=&lt;/span&gt;root  &lt;span style=&#34;color:#ebcb8b&#34;&gt;\&#xA;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#ebcb8b&#34;&gt;&lt;/span&gt;-d mysql&#xA;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;h2 id=&#34;javadoc&#34;&gt;JavaDoc&lt;/h2&gt;&#xA;&lt;p&gt;项目可以直接自动生成文档&lt;/p&gt;</description>
    </item>
    <item>
      <title>问题收集</title>
      <link>https://huoxj.github.io/posts/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86/%E9%97%AE%E9%A2%98%E6%94%B6%E9%9B%86/</link>
      <pubDate>Wed, 08 May 2024 00:00:00 +0000</pubDate>
      <guid>https://huoxj.github.io/posts/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86/%E9%97%AE%E9%A2%98%E6%94%B6%E9%9B%86/</guid>
      <description>&lt;h1 id=&#34;待解决问题&#34;&gt;待解决问题&lt;/h1&gt;&#xA;&lt;h2 id=&#34;lexer&#34;&gt;Lexer&lt;/h2&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;&#xA;&lt;p&gt;DFA最小化为什么是正确的&lt;/p&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;&#xA;&lt;p&gt;DFA最小化的结果唯一吗&lt;/p&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;&#xA;&lt;p&gt;有关自动机的书：《计算理论导引》、J.E.H R.M J.D.U《Automata Theory, Languages, and Computation 第三版》&lt;/p&gt;&#xA;&lt;/li&gt;&#xA;&lt;/ul&gt;</description>
    </item>
    <item>
      <title>C4 设备管理</title>
      <link>https://huoxj.github.io/posts/se%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/c4-%E8%AE%BE%E5%A4%87%E7%AE%A1%E7%90%86/</link>
      <pubDate>Tue, 07 May 2024 00:00:00 +0000</pubDate>
      <guid>https://huoxj.github.io/posts/se%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/c4-%E8%AE%BE%E5%A4%87%E7%AE%A1%E7%90%86/</guid>
      <description>&lt;h1 id=&#34;第四章-设备管理&#34;&gt;第四章-设备管理&lt;/h1&gt;&#xA;&lt;h2 id=&#34;41-设备管理概述&#34;&gt;4.1-设备管理概述&lt;/h2&gt;&#xA;&lt;h3 id=&#34;设备管理的目标&#34;&gt;⭐设备管理的目标&lt;/h3&gt;&#xA;&lt;ol&gt;&#xA;&lt;li&gt;解决设备和CPU&lt;strong&gt;速度&lt;/strong&gt;的不匹配，使两者充分&lt;strong&gt;并行&lt;/strong&gt;工作&lt;/li&gt;&#xA;&lt;li&gt;&lt;strong&gt;屏蔽&lt;/strong&gt;设备的具体操作细节，配置驱动程序，提供&lt;strong&gt;统一接口&lt;/strong&gt;&lt;/li&gt;&#xA;&lt;/ol&gt;&#xA;&lt;h3 id=&#34;设备控制器&#34;&gt;设备控制器&lt;/h3&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;&#xA;&lt;p&gt;CPU和物理设备之间的接口&lt;/p&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;&#xA;&lt;p&gt;组成&lt;/p&gt;&#xA;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;!-- raw HTML omitted --&gt;&#xA;&lt;h3 id=&#34;io控制方式&#34;&gt;⭐IO控制方式&lt;/h3&gt;&#xA;&lt;h4 id=&#34;轮询&#34;&gt;轮询&lt;/h4&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;CPU向控制器发送I/O命令，轮询I/O结果。&lt;/li&gt;&#xA;&lt;li&gt;若设备未就绪，则&lt;strong&gt;重复&lt;/strong&gt;，直至设备就绪。&lt;/li&gt;&#xA;&lt;li&gt;设备就绪，CPU执行&lt;strong&gt;内存交换&lt;/strong&gt;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;h4 id=&#34;中断&#34;&gt;中断&lt;/h4&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;CPU向控制器发出I/O命令，然后&lt;strong&gt;干其他事情&lt;/strong&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;如果进程支持异步IO，就不用换进程&lt;/li&gt;&#xA;&lt;li&gt;否则进程挂起，换进程&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;控制器在设备就绪后向CPU发出中断&lt;/li&gt;&#xA;&lt;li&gt;CPU响应中断，进行&lt;strong&gt;内存交换&lt;/strong&gt;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;h4 id=&#34;dma&#34;&gt;DMA&lt;/h4&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;&#xA;&lt;p&gt;CPU向DMA模块发出I/O命令&lt;/p&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;&#xA;&lt;p&gt;处理器&lt;strong&gt;干其他事&lt;/strong&gt;，DMA负责等设备就绪和&lt;strong&gt;传送数据&lt;/strong&gt;&lt;/p&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;&#xA;&lt;p&gt;DMA数据传完之后中断CPU&lt;/p&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;&#xA;&lt;p&gt;DMA一般用周期窃取的方式访问内存。因为CPU大部分情况下用Cache，这时空闲的主存就能被DMA高效利用&lt;/p&gt;&#xA;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;h3 id=&#34;io通道&#34;&gt;I/O通道&lt;/h3&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;没看懂是啥&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;h3 id=&#34;总线&#34;&gt;总线&lt;/h3&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;解决I/O&lt;strong&gt;速度不匹配&lt;/strong&gt;的问题&lt;/li&gt;&#xA;&lt;li&gt;不同总线结构的本质是让&lt;strong&gt;速率相近&lt;/strong&gt;的设备在一条总线上&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;h4 id=&#34;单总线&#34;&gt;单总线&lt;/h4&gt;&#xA;&lt;!-- raw HTML omitted --&gt;&#xA;&lt;h4 id=&#34;三级总线&#34;&gt;三级总线&lt;/h4&gt;&#xA;&lt;!-- raw HTML omitted --&gt;&#xA;&lt;h4 id=&#34;南北桥&#34;&gt;南北桥&lt;/h4&gt;&#xA;&lt;!-- raw HTML omitted --&gt;&#xA;&lt;h2 id=&#34;42-io软件的实现&#34;&gt;4.2-I/O软件的实现&lt;/h2&gt;&#xA;&lt;h3 id=&#34;设计目标&#34;&gt;设计目标&lt;/h3&gt;&#xA;&lt;p&gt;&lt;strong&gt;效率&lt;/strong&gt;：改善设备效率，尤其是磁盘&lt;/p&gt;&#xA;&lt;p&gt;&lt;strong&gt;通用&lt;/strong&gt;：用统一标准来管理所有设备&lt;/p&gt;&#xA;&lt;h3 id=&#34;io软件的层次结构&#34;&gt;⭐I/O软件的层次结构&lt;/h3&gt;&#xA;&lt;p&gt;从低到高为&lt;/p&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;I/O中断处理程序&lt;/li&gt;&#xA;&lt;li&gt;I/O设备驱动程序&lt;/li&gt;&#xA;&lt;li&gt;独立于设备的I/O软件&lt;/li&gt;&#xA;&lt;li&gt;用户空间的I/O软件&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;h4 id=&#34;io中断处理程序&#34;&gt;I/O中断处理程序&lt;/h4&gt;&#xA;&lt;p&gt;位于OS底层，和设备联系紧密&lt;/p&gt;&#xA;&lt;p&gt;数据传输&lt;strong&gt;结束&lt;/strong&gt;后产生I/O中断，CPU响应请求并转入中断处理程序&lt;/p&gt;&#xA;&lt;p&gt;功能：检查&lt;strong&gt;设备状态寄存器&lt;/strong&gt;，根据状态进行相关操作&lt;/p&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;报错&lt;/li&gt;&#xA;&lt;li&gt;正常结束，唤醒请求这个I/O的进程&lt;/li&gt;&#xA;&lt;li&gt;其他&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;h4 id=&#34;io设备驱动程序&#34;&gt;I/O设备驱动程序&lt;/h4&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;&#xA;&lt;p&gt;&lt;strong&gt;初始化&lt;/strong&gt;设备&lt;/p&gt;</description>
    </item>
    <item>
      <title>C3 存储管理</title>
      <link>https://huoxj.github.io/posts/se%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/c3-%E5%AD%98%E5%82%A8%E7%AE%A1%E7%90%86/</link>
      <pubDate>Thu, 25 Apr 2024 00:00:00 +0000</pubDate>
      <guid>https://huoxj.github.io/posts/se%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/c3-%E5%AD%98%E5%82%A8%E7%AE%A1%E7%90%86/</guid>
      <description>&lt;h1 id=&#34;第三章-存储管理&#34;&gt;第三章-存储管理&lt;/h1&gt;&#xA;&lt;h2 id=&#34;31-存储管理基础&#34;&gt;3.1-存储管理基础&lt;/h2&gt;&#xA;&lt;h3 id=&#34;有哪些地址&#34;&gt;有哪些地址&lt;/h3&gt;&#xA;&lt;h4 id=&#34;逻辑地址&#34;&gt;逻辑地址&lt;/h4&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;又叫&lt;strong&gt;相对地址&lt;/strong&gt;。是用户编程所使用的地址空间。&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;h4 id=&#34;物理地址&#34;&gt;物理地址&lt;/h4&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;&lt;strong&gt;处理器执行&lt;/strong&gt;指令时所使用的地址空间&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;h4 id=&#34;虚拟地址&#34;&gt;虚拟地址&lt;/h4&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;辅存的地址空间&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;h3 id=&#34;为啥要存储管理&#34;&gt;为啥要存储管理&lt;/h3&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;&lt;strong&gt;转换地址&lt;/strong&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;OS有两种转换地址的模式&lt;/li&gt;&#xA;&lt;li&gt;静态重定位：&lt;strong&gt;程序装入&lt;/strong&gt;内存时转换地址(由装入程序支持)&lt;/li&gt;&#xA;&lt;li&gt;动态重定位：&lt;strong&gt;解析命令&lt;/strong&gt;才转换地址(现在都用这个，考虑效率的话必须由硬件支持)&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;&lt;strong&gt;分配&lt;/strong&gt;和&lt;strong&gt;去配&lt;/strong&gt;主存空间&lt;/li&gt;&#xA;&lt;li&gt;管理进程对&lt;strong&gt;主存的共享&lt;/strong&gt;&lt;/li&gt;&#xA;&lt;li&gt;&lt;strong&gt;保护进程&lt;/strong&gt;，避免越界访问&lt;/li&gt;&#xA;&lt;li&gt;扩充主存空间&#xA;&lt;ul&gt;&#xA;&lt;li&gt;把磁盘作为主存的扩充&lt;/li&gt;&#xA;&lt;li&gt;对换技术：调出一部分进程&lt;/li&gt;&#xA;&lt;li&gt;虚拟技术：调入进程的一部分&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;h3 id=&#34;存储管理的模式&#34;&gt;存储管理的模式&lt;/h3&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;单连续存储管理：1D逻辑地址 占用 一个 主存固定或可变分区&lt;/li&gt;&#xA;&lt;li&gt;段式存储管理：2D逻辑地址 占用 多个 主存可变分区&lt;/li&gt;&#xA;&lt;li&gt;页式存储管理：1D逻辑地址 占用 多个 页框&lt;/li&gt;&#xA;&lt;li&gt;段页式存储管理：2D逻辑地址 占用 多个 页框&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;h3 id=&#34;虚拟存储器&#34;&gt;虚拟存储器&lt;/h3&gt;&#xA;&lt;h4 id=&#34;基本思想&#34;&gt;基本思想&lt;/h4&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;为了让程序员不必考虑主存容量的限制，夸夸用地址，就把辅存的一部分当成主存，&lt;strong&gt;随用随调入&lt;/strong&gt;&lt;/li&gt;&#xA;&lt;li&gt;&lt;strong&gt;主存不够&lt;/strong&gt;了，就把部分数据&lt;strong&gt;调出到辅存&lt;/strong&gt;上去&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;h2 id=&#34;32-单连续分区存储管理&#34;&gt;3.2-单连续分区存储管理&lt;/h2&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;每个进程占用一个物理上完全连续的存储空间&lt;/li&gt;&#xA;&lt;li&gt;主存：系统区+用户区&lt;/li&gt;&#xA;&lt;li&gt;&lt;strong&gt;栅栏寄存器&lt;/strong&gt;存两个区的分界，在访存时提供保护&lt;/li&gt;&#xA;&lt;li&gt;一般采用&lt;strong&gt;静态重定位&lt;/strong&gt;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;h3 id=&#34;内存分配&#34;&gt;内存分配&lt;/h3&gt;&#xA;&lt;h4 id=&#34;固定分区存储&#34;&gt;固定分区存储&lt;/h4&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;&#xA;&lt;p&gt;主存按递增大小的块来分区，加载任务的时候大小合适就丢进去。&lt;/p&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;&#xA;&lt;p&gt;e.g.&lt;/p&gt;&#xA;&lt;table&gt;&#xA;  &lt;thead&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;th style=&#34;text-align: left&#34;&gt;0&lt;/th&gt;&#xA;          &lt;th style=&#34;text-align: left&#34;&gt;4k&lt;/th&gt;&#xA;          &lt;th style=&#34;text-align: left&#34;&gt;12k&lt;/th&gt;&#xA;          &lt;th style=&#34;text-align: left&#34;&gt;28k&lt;/th&gt;&#xA;          &lt;th style=&#34;text-align: left&#34;&gt;44k&lt;/th&gt;&#xA;          &lt;th style=&#34;text-align: left&#34;&gt;92k&lt;/th&gt;&#xA;          &lt;th style=&#34;text-align: left&#34;&gt;&amp;hellip;&lt;/th&gt;&#xA;      &lt;/tr&gt;&#xA;  &lt;/thead&gt;&#xA;  &lt;tbody&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;td style=&#34;text-align: left&#34;&gt;OS区(4k)&lt;/td&gt;&#xA;          &lt;td style=&#34;text-align: left&#34;&gt;分区1(8k)&lt;/td&gt;&#xA;          &lt;td style=&#34;text-align: left&#34;&gt;分区2(16k)&lt;/td&gt;&#xA;          &lt;td style=&#34;text-align: left&#34;&gt;分区3(16k)&lt;/td&gt;&#xA;          &lt;td style=&#34;text-align: left&#34;&gt;分区4(24k)&lt;/td&gt;&#xA;          &lt;td style=&#34;text-align: left&#34;&gt;分区5(24k)&lt;/td&gt;&#xA;          &lt;td style=&#34;text-align: left&#34;&gt;&amp;hellip;&lt;/td&gt;&#xA;      &lt;/tr&gt;&#xA;  &lt;/tbody&gt;&#xA;&lt;/table&gt;&#xA;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;h4 id=&#34;可变分区存储&#34;&gt;可变分区存储&lt;/h4&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;&#xA;&lt;p&gt;按实际分配需求来确定内存分区&lt;/p&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;&#xA;&lt;p&gt;存储用&lt;strong&gt;已分配区表&lt;/strong&gt;和&lt;strong&gt;未分配区表&lt;/strong&gt;记录。包含：分区基址、分区长度、分区标志(未分配还是任务1还是任务2还是&amp;hellip;)&lt;/p&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;&#xA;&lt;p&gt;分配算法&lt;/p&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;最先适应分配算法 First fit&#xA;&lt;ul&gt;&#xA;&lt;li&gt;从头找第一个大小够的分区&lt;/li&gt;&#xA;&lt;li&gt;最容易产生碎片&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;邻近适应分配算法 Next fit&#xA;&lt;ul&gt;&#xA;&lt;li&gt;从上一次的空闲分区开始找，第一个大小够的分区&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;最优适应分配算法 Best fit&#xA;&lt;ul&gt;&#xA;&lt;li&gt;找大小最接近的分区&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;最坏适应分配算法 Worst fit&#xA;&lt;ul&gt;&#xA;&lt;li&gt;找最大的分区&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;&#xA;&lt;p&gt;移动技术&lt;/p&gt;</description>
    </item>
    <item>
      <title>C0 绪论</title>
      <link>https://huoxj.github.io/posts/se%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/c0-%E7%BB%AA%E8%AE%BA/</link>
      <pubDate>Mon, 22 Apr 2024 00:00:00 +0000</pubDate>
      <guid>https://huoxj.github.io/posts/se%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/c0-%E7%BB%AA%E8%AE%BA/</guid>
      <description>&lt;h1 id=&#34;lec-0-绪论&#34;&gt;Lec-0 绪论&lt;/h1&gt;&#xA;&lt;h2 id=&#34;观察os的视角&#34;&gt;观察OS的视角&lt;/h2&gt;&#xA;&lt;h3 id=&#34;用户角度&#34;&gt;用户角度&lt;/h3&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;OS是&lt;strong&gt;服务提供者&lt;/strong&gt; - 接口和服务&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;h3 id=&#34;系统角度&#34;&gt;系统角度&lt;/h3&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;OS是&lt;strong&gt;资源管理者&lt;/strong&gt; - 处理器管理、存储管理、设备管理、文件管理&lt;/li&gt;&#xA;&lt;li&gt;OS是&lt;strong&gt;虚拟机&lt;/strong&gt; - 虚拟机、os结构、os运行模型、网络环境下的操作系统&lt;/li&gt;&#xA;&lt;li&gt;OS是&lt;strong&gt;程序执行的控制者&lt;/strong&gt; - 进程交互、调度、同步、通信、死锁&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;h2 id=&#34;最基础的抽象&#34;&gt;最基础的抽象🤓☝️&lt;/h2&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;进程抽象-是对已进入主存正在运行的程序在处理器上操作的状态集的抽象 。&lt;/li&gt;&#xA;&lt;li&gt;虚存抽象-是对物理主存的抽象，进程可获得一个硕大的连续地址空间来存放可执行程序和数据，可使用虚拟地址来引用物理主存单元。&lt;/li&gt;&#xA;&lt;li&gt;文件抽象-是对设备(磁盘)的抽象 。&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;h2 id=&#34;复习roadmap&#34;&gt;复习Roadmap&lt;/h2&gt;&#xA;&lt;p&gt;&lt;img src=&#34;https://runzblog.oss-cn-hangzhou.aliyuncs.com/postimg/202409271716735.png&#34; alt=&#34;image-20240422141419166&#34;&gt;&lt;/p&gt;</description>
    </item>
    <item>
      <title>C1 计算机操作系统概述</title>
      <link>https://huoxj.github.io/posts/se%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/c1-%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E6%A6%82%E8%BF%B0/</link>
      <pubDate>Mon, 22 Apr 2024 00:00:00 +0000</pubDate>
      <guid>https://huoxj.github.io/posts/se%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/c1-%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E6%A6%82%E8%BF%B0/</guid>
      <description>&lt;h1 id=&#34;第一章-计算机操作系统概述&#34;&gt;第一章-计算机操作系统概述&lt;/h1&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;本章结构&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;p&gt;&lt;img src=&#34;https://runzblog.oss-cn-hangzhou.aliyuncs.com/postimg/202409271717415.png&#34; alt=&#34;image-20240422141854716&#34;&gt;&lt;/p&gt;&#xA;&lt;h2 id=&#34;122-操作系统及其分类&#34;&gt;1.2.2-操作系统及其分类&lt;/h2&gt;&#xA;&lt;h3 id=&#34;理论&#34;&gt;理论&lt;/h3&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;&#xA;&lt;p&gt;OS的&lt;strong&gt;概念&lt;/strong&gt;：OS是计算机系统最基础的系统软件，管理软硬件资源、控制程序执行、改善人机界面、合理组织计算机工作流程，为用户使用计算机提供良好运行环境&lt;/p&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;&#xA;&lt;p&gt;OS的&lt;strong&gt;组成&lt;/strong&gt;：进程调度、进程通信、内存管理、设备管理、文件管理、网络通信、作业控制&lt;/p&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;&#xA;&lt;p&gt;OS的&lt;strong&gt;类型&lt;/strong&gt;：&lt;/p&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;多道批处理系统（脱机）&lt;/li&gt;&#xA;&lt;li&gt;分时操作系统&lt;/li&gt;&#xA;&lt;li&gt;实时操作系统&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;h2 id=&#34;135-程序接口的视角&#34;&gt;1.3.5-程序接口的视角&lt;/h2&gt;&#xA;&lt;h3 id=&#34;系统调用&#34;&gt;系统调用&lt;/h3&gt;&#xA;&lt;p&gt;&lt;img src=&#34;https://runzblog.oss-cn-hangzhou.aliyuncs.com/postimg/202409272308402.png&#34; alt=&#34;image-20240927230851266&#34;&gt;&lt;/p&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;实现的基础是陷阱机制：从用户态陷入内核态&lt;/li&gt;&#xA;&lt;li&gt;调用系统调用时(int **h)，操作系统从用户态转入内核态执行系统调用&lt;/li&gt;&#xA;&lt;li&gt;系统调用返回时转入用户态&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;h2 id=&#34;136-系统结构的视角&#34;&gt;1.3.6-系统结构的视角&lt;/h2&gt;&#xA;&lt;h3 id=&#34;操作系统内核设计&#34;&gt;操作系统内核设计&lt;/h3&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;设计概念：模块化、层次化、虚拟化&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;h4 id=&#34;内核设计分类&#34;&gt;内核设计分类&lt;/h4&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;单内核&#xA;&lt;ul&gt;&#xA;&lt;li&gt;在一大坨代码中实际包含了所有操作系统功能，并作为一个单一进程运行，具有唯一地址空间。&lt;/li&gt;&#xA;&lt;li&gt;大部分UNIX(包括Linxu)系统都采用的单体内核。&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;微内核&#xA;&lt;ul&gt;&#xA;&lt;li&gt;&lt;a href=&#34;blog.csdn.net/silentpebble/article/details/7941025&#34;&gt;大部分OS功能作为单独的进程在内核态外运行，他们通过消息传递进行通讯&lt;/a&gt;。&lt;/li&gt;&#xA;&lt;li&gt;内核态只有最基本、最核心的功能模块。比如IPC、虚存、调度&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;混合内核&lt;/li&gt;&#xA;&lt;li&gt;外内核&#xA;&lt;ul&gt;&#xA;&lt;li&gt;OS本身值提供很低级的硬件操作，没有很完整的硬件抽象。&lt;/li&gt;&#xA;&lt;li&gt;用在嵌入式上&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;/ul&gt;</description>
    </item>
    <item>
      <title>C2 处理器管理</title>
      <link>https://huoxj.github.io/posts/se%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/c2-%E5%A4%84%E7%90%86%E5%99%A8%E7%AE%A1%E7%90%86/</link>
      <pubDate>Mon, 22 Apr 2024 00:00:00 +0000</pubDate>
      <guid>https://huoxj.github.io/posts/se%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/c2-%E5%A4%84%E7%90%86%E5%99%A8%E7%AE%A1%E7%90%86/</guid>
      <description>&lt;h1 id=&#34;第二章-处理器管理&#34;&gt;第二章-处理器管理&lt;/h1&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;本章结构&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;p&gt;&lt;img src=&#34;https://runzblog.oss-cn-hangzhou.aliyuncs.com/postimg/202409271717642.png&#34; alt=&#34;image-20240422145053555&#34;&gt;&lt;/p&gt;&#xA;&lt;h2 id=&#34;21-处理器&#34;&gt;2.1-处理器&lt;/h2&gt;&#xA;&lt;h3 id=&#34;特权指令&#34;&gt;特权指令&lt;/h3&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;特权指令：只能被操作系统内核使用的指令&lt;/li&gt;&#xA;&lt;li&gt;比如启动IO指令、置PC指令等&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;h3 id=&#34;处理器模式&#34;&gt;处理器模式&lt;/h3&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;0=OS内核；1=系统调用；2=共享库程序；3=用户程序&lt;/li&gt;&#xA;&lt;li&gt;现代操作系统：内核模式(特权指令ok)，用户模式(非特权指令)&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;h2 id=&#34;22-中断&#34;&gt;2.2-中断&lt;/h2&gt;&#xA;&lt;h3 id=&#34;中断概念&#34;&gt;中断概念&lt;/h3&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;&lt;strong&gt;广义中断&lt;/strong&gt;：程序执行过程中，遇到急需处理的事件时，暂时中止当前程序的运行，转去执行相应的事件处理程序。等中断处理完成后再返回原程序中断的地方或调度其他程序执行的过程叫中断。&lt;/li&gt;&#xA;&lt;li&gt;&lt;strong&gt;狭义中断&lt;/strong&gt;：事件来源于处理器外的广义中断。如IO中断、时钟中断、外部信号中断&lt;/li&gt;&#xA;&lt;li&gt;&lt;strong&gt;广义中断 minus 狭义中断&lt;/strong&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;异常：事件来源于处理器运行指令引起的广义中断。如地址异常、算术异常、处理器硬件故障&lt;/li&gt;&#xA;&lt;li&gt;系统异常：执行陷入(trap)指令而触发系统调用引起的终端事件。如请求设备、请求IO、创建进程&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;h3 id=&#34;中断驱动下的进程状态机&#34;&gt;中断驱动下的进程状态机&lt;/h3&gt;&#xA;&lt;p&gt;&lt;img src=&#34;https://runzblog.oss-cn-hangzhou.aliyuncs.com/postimg/202409271717238.png&#34; alt=&#34;&#34;&gt;&lt;/p&gt;&#xA;&lt;h3 id=&#34;中断源&#34;&gt;中断源&lt;/h3&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;处理器硬件故障中断&lt;/li&gt;&#xA;&lt;li&gt;程序性中断&lt;/li&gt;&#xA;&lt;li&gt;自愿性中断-系统调用&lt;/li&gt;&#xA;&lt;li&gt;IO中断&lt;/li&gt;&#xA;&lt;li&gt;外部中断&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;h2 id=&#34;23-进程&#34;&gt;2.3-进程&lt;/h2&gt;&#xA;&lt;h3 id=&#34;进程的概念&#34;&gt;⭐⭐⭐进程的概念&lt;/h3&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;进程是一个具有一定独立功能的&lt;strong&gt;程序&lt;/strong&gt;关于某个&lt;strong&gt;数据集合&lt;/strong&gt;的一次运行活动&lt;/li&gt;&#xA;&lt;li&gt;进程是操作系统进行&lt;strong&gt;资源分配&lt;/strong&gt;和&lt;strong&gt;调度&lt;/strong&gt;的一个独立单位&#xA;&lt;ul&gt;&#xA;&lt;li&gt;对于多线程系统来说，进程是&lt;strong&gt;资源分配&lt;/strong&gt;的独立单位&lt;/li&gt;&#xA;&lt;li&gt;线程是资源调度的独立单位&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;h3 id=&#34;进程的形式化定义&#34;&gt;进程的形式化定义&lt;/h3&gt;&#xA;&lt;p&gt;&lt;img src=&#34;https://runzblog.oss-cn-hangzhou.aliyuncs.com/postimg/202409271718917.png&#34; alt=&#34;&#34;&gt;&lt;/p&gt;&#xA;&lt;h3 id=&#34;进程的三态模型&#34;&gt;⭐⭐⭐&lt;strong&gt;进程的三态模型&lt;/strong&gt;&lt;/h3&gt;&#xA;&lt;p&gt;&lt;img src=&#34;https://runzblog.oss-cn-hangzhou.aliyuncs.com/postimg/202409271718439.png&#34; alt=&#34;&#34;&gt;&lt;/p&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;&#xA;&lt;p&gt;&lt;strong&gt;运行态&lt;/strong&gt;指进程占有处理器运行&lt;/p&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;&#xA;&lt;p&gt;&lt;strong&gt;就绪态&lt;/strong&gt;指进程具备运行条件等待处理器运行&lt;/p&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;&#xA;&lt;p&gt;&lt;strong&gt;等待态&lt;/strong&gt;指进程由于等待资源、输入输出、信号等而不具备运行条件&lt;/p&gt;&#xA;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;h3 id=&#34;进程挂起&#34;&gt;进程挂起&lt;/h3&gt;&#xA;&lt;p&gt;&lt;img src=&#34;https://runzblog.oss-cn-hangzhou.aliyuncs.com/postimg/202409271719195.png&#34; alt=&#34;&#34;&gt;&lt;/p&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;计算机资源不足，会剥夺某些进程的资源，调入OS管理的堆换区。这些进程就被挂起了。&lt;/li&gt;&#xA;&lt;li&gt;挂起的进程&lt;strong&gt;不参加进程调度&lt;/strong&gt;。在适当的时候被调回内存。&lt;/li&gt;&#xA;&lt;li&gt;挂起和非运行态的本质区别是有没有&lt;strong&gt;占用系统资源&lt;/strong&gt;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;p&gt;&lt;img src=&#34;https://runzblog.oss-cn-hangzhou.aliyuncs.com/postimg/202409271719451.png&#34; alt=&#34;&#34;&gt;&lt;/p&gt;&#xA;&lt;h3 id=&#34;进程控制块-pcb&#34;&gt;⭐⭐⭐进程控制块 PCB&lt;/h3&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;&#xA;&lt;p&gt;OS用于记录和刻画进程状态及环境信息的数据结构。说白了就是面向OS的&lt;strong&gt;进程的花名册&lt;/strong&gt;&lt;/p&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;&#xA;&lt;p&gt;包含&lt;strong&gt;标识信息&lt;/strong&gt;、&lt;strong&gt;现场信息&lt;/strong&gt;、&lt;strong&gt;控制信息&lt;/strong&gt;。&lt;/p&gt;&#xA;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;h3 id=&#34;进程映像-process-image&#34;&gt;⭐⭐⭐进程映像 Process Image&lt;/h3&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;进程的&lt;strong&gt;内存级&lt;/strong&gt;实体&lt;/li&gt;&#xA;&lt;li&gt;包括：PCB、进程程序空间、进程数据空间、核心栈&#xA;&lt;ul&gt;&#xA;&lt;li&gt;核心栈就是在内核态执行指令时用的栈&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;h3 id=&#34;进程上下文-process-context&#34;&gt;进程上下文 Process Context&lt;/h3&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;进程执行所需要的环境信息&lt;/li&gt;&#xA;&lt;li&gt;包括：用户级上下文、寄存器上下文、系统级上下文&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;h3 id=&#34;原语-primitive&#34;&gt;原语 Primitive&lt;/h3&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;若干条指令构成的程序，执行上具有原子性。意思是原语不可能被中断。&lt;/li&gt;&#xA;&lt;li&gt;用于执行一些涉及修改OS核心数据结构的操作。为了防止并发和中断等时间上的错误，原语必须整块执行。&lt;/li&gt;&#xA;&lt;li&gt;常用原语：进程控制原语、进程通信原语&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;h2 id=&#34;24-多线程技术&#34;&gt;2.4-多线程技术&lt;/h2&gt;&#xA;&lt;h3 id=&#34;为什么要多线程&#34;&gt;为什么要多线程&lt;/h3&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;单线程能一定程度上实现并发了，但我们还想更进一步。&lt;/li&gt;&#xA;&lt;li&gt;限制单线程并发程度的要素：&#xA;&lt;ul&gt;&#xA;&lt;li&gt;进程切换开销大。想切换执行路径就必须换进程，开销很大。&lt;/li&gt;&#xA;&lt;li&gt;进程通信开销大。进程通信要陷入系统调用，涉及模式转换，开销大。&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;解决：&#xA;&lt;ul&gt;&#xA;&lt;li&gt;分离&lt;strong&gt;资源分配&lt;/strong&gt;和&lt;strong&gt;调度&lt;/strong&gt;。因为资源分配比较静态，不会很频繁。相对而言，(如果想更加并发的话)调度比资源分配频繁多了。&lt;/li&gt;&#xA;&lt;li&gt;两者分离的结果就是&lt;strong&gt;进程&lt;/strong&gt;和&lt;strong&gt;线程&lt;/strong&gt;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;h3 id=&#34;进程和线程&#34;&gt;进程和线程&lt;/h3&gt;&#xA;&lt;h4 id=&#34;进程&#34;&gt;进程&lt;/h4&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;&#xA;&lt;p&gt;操作系统的视角：是OS进行保护和&lt;strong&gt;资源分配&lt;/strong&gt;的独立单位。&lt;/p&gt;</description>
    </item>
    <item>
      <title>C3-SQL</title>
      <link>https://huoxj.github.io/posts/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%AE%A1%E7%90%86%E5%9F%BA%E7%A1%80/c3-sql/</link>
      <pubDate>Mon, 22 Apr 2024 00:00:00 +0000</pubDate>
      <guid>https://huoxj.github.io/posts/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%AE%A1%E7%90%86%E5%9F%BA%E7%A1%80/c3-sql/</guid>
      <description>&lt;h1 id=&#34;第三章-关系数据库标准语言sql&#34;&gt;第三章-关系数据库标准语言SQL&lt;/h1&gt;&#xA;&lt;h2 id=&#34;数据定义&#34;&gt;数据定义&lt;/h2&gt;&#xA;&lt;h3 id=&#34;创建模式&#34;&gt;创建模式&lt;/h3&gt;&#xA;&lt;p&gt;&lt;code&gt;CREATE SCHEMA &amp;lt;模式名&amp;gt; AUTHORIZATION &amp;lt;用户名&amp;gt;&lt;/code&gt;&lt;/p&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;&#xA;&lt;p&gt;命令后可接受&lt;/p&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;&lt;code&gt;CREATE TABLE&lt;/code&gt;&lt;/li&gt;&#xA;&lt;li&gt;&lt;code&gt;CREATE VIEW&lt;/code&gt;&lt;/li&gt;&#xA;&lt;li&gt;&lt;code&gt;GRANT&lt;/code&gt;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;&#xA;&lt;p&gt;执行创建模式语句必须有DBA权限&lt;/p&gt;&#xA;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;h3 id=&#34;删除模式&#34;&gt;删除模式&lt;/h3&gt;&#xA;&lt;p&gt;&lt;code&gt;DROP SCHEMA &amp;lt;模式名&amp;gt; &amp;lt;CASCADE|RESTRICT&amp;gt;&lt;/code&gt;&lt;/p&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;CASCADE 级联：删除模式同时删除模式内所有数据库对象&lt;/li&gt;&#xA;&lt;li&gt;RESTRICT 限制：只在模式下无任何下属对象才删除，否则拒绝执行&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;h3 id=&#34;创建基本表&#34;&gt;创建基本表&lt;/h3&gt;&#xA;&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#d8dee9;background-color:#2e3440;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-sql&#34; data-lang=&#34;sql&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#81a1c1;font-weight:bold&#34;&gt;CREATE&lt;/span&gt; &lt;span style=&#34;color:#81a1c1;font-weight:bold&#34;&gt;TABLE&lt;/span&gt; &lt;span style=&#34;color:#81a1c1&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span style=&#34;color:#bf616a&#34;&gt;表名&lt;/span&gt;&lt;span style=&#34;color:#81a1c1&#34;&gt;&amp;gt;&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#eceff4&#34;&gt;(&lt;/span&gt;&lt;span style=&#34;color:#81a1c1&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span style=&#34;color:#bf616a&#34;&gt;列名&lt;/span&gt;&lt;span style=&#34;color:#81a1c1&#34;&gt;&amp;gt;&lt;/span&gt; &lt;span style=&#34;color:#81a1c1&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span style=&#34;color:#bf616a&#34;&gt;数据类型&lt;/span&gt;&lt;span style=&#34;color:#81a1c1&#34;&gt;&amp;gt;&lt;/span&gt; &lt;span style=&#34;color:#eceff4&#34;&gt;[&lt;/span&gt;&lt;span style=&#34;color:#81a1c1&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span style=&#34;color:#bf616a&#34;&gt;列级完整性约束条件&lt;/span&gt;&lt;span style=&#34;color:#81a1c1&#34;&gt;&amp;gt;&lt;/span&gt;&lt;span style=&#34;color:#eceff4&#34;&gt;]&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#eceff4&#34;&gt;[,&lt;/span&gt;&lt;span style=&#34;color:#bf616a&#34;&gt;同上&lt;/span&gt;&lt;span style=&#34;color:#eceff4&#34;&gt;]&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#eceff4&#34;&gt;[,&lt;/span&gt;&lt;span style=&#34;color:#81a1c1&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span style=&#34;color:#bf616a&#34;&gt;表级完整性约束条件&lt;/span&gt;&lt;span style=&#34;color:#81a1c1&#34;&gt;&amp;gt;&lt;/span&gt;&lt;span style=&#34;color:#eceff4&#34;&gt;])&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#d8dee9;background-color:#2e3440;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-sql&#34; data-lang=&#34;sql&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;e&lt;span style=&#34;color:#eceff4&#34;&gt;.&lt;/span&gt;&lt;span style=&#34;color:#81a1c1;font-weight:bold&#34;&gt;g&lt;/span&gt;&lt;span style=&#34;color:#eceff4&#34;&gt;.&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#81a1c1;font-weight:bold&#34;&gt;CREATE&lt;/span&gt; &lt;span style=&#34;color:#81a1c1;font-weight:bold&#34;&gt;TABLE&lt;/span&gt; Course&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#eceff4&#34;&gt;(&lt;/span&gt;Cno &lt;span style=&#34;color:#81a1c1&#34;&gt;CHAR&lt;/span&gt;&lt;span style=&#34;color:#eceff4&#34;&gt;(&lt;/span&gt;&lt;span style=&#34;color:#b48ead&#34;&gt;4&lt;/span&gt;&lt;span style=&#34;color:#eceff4&#34;&gt;)&lt;/span&gt; &lt;span style=&#34;color:#81a1c1;font-weight:bold&#34;&gt;PRIMARY&lt;/span&gt; &lt;span style=&#34;color:#81a1c1;font-weight:bold&#34;&gt;KEY&lt;/span&gt;&lt;span style=&#34;color:#eceff4&#34;&gt;,&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt; Cname &lt;span style=&#34;color:#81a1c1&#34;&gt;CHAR&lt;/span&gt;&lt;span style=&#34;color:#eceff4&#34;&gt;(&lt;/span&gt;&lt;span style=&#34;color:#b48ead&#34;&gt;40&lt;/span&gt;&lt;span style=&#34;color:#eceff4&#34;&gt;)&lt;/span&gt; &lt;span style=&#34;color:#81a1c1;font-weight:bold&#34;&gt;UNIQUE&lt;/span&gt;&lt;span style=&#34;color:#eceff4&#34;&gt;,&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt; Cpno &lt;span style=&#34;color:#81a1c1&#34;&gt;CHAR&lt;/span&gt;&lt;span style=&#34;color:#eceff4&#34;&gt;(&lt;/span&gt;&lt;span style=&#34;color:#b48ead&#34;&gt;4&lt;/span&gt;&lt;span style=&#34;color:#eceff4&#34;&gt;),&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt; &lt;span style=&#34;color:#81a1c1;font-weight:bold&#34;&gt;FOREIGN&lt;/span&gt; &lt;span style=&#34;color:#81a1c1;font-weight:bold&#34;&gt;KEY&lt;/span&gt;&lt;span style=&#34;color:#eceff4&#34;&gt;(&lt;/span&gt;Cpno&lt;span style=&#34;color:#eceff4&#34;&gt;)&lt;/span&gt; &lt;span style=&#34;color:#81a1c1;font-weight:bold&#34;&gt;REFERENCES&lt;/span&gt; Course&lt;span style=&#34;color:#eceff4&#34;&gt;(&lt;/span&gt;Cno&lt;span style=&#34;color:#eceff4&#34;&gt;)&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#eceff4&#34;&gt;);&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;h3 id=&#34;修改基本表&#34;&gt;修改基本表&lt;/h3&gt;&#xA;&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#d8dee9;background-color:#2e3440;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-sql&#34; data-lang=&#34;sql&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#81a1c1;font-weight:bold&#34;&gt;ALTER&lt;/span&gt; &lt;span style=&#34;color:#81a1c1;font-weight:bold&#34;&gt;TABLE&lt;/span&gt; &lt;span style=&#34;color:#81a1c1&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span style=&#34;color:#bf616a&#34;&gt;表名&lt;/span&gt;&lt;span style=&#34;color:#81a1c1&#34;&gt;&amp;gt;&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#eceff4&#34;&gt;[&lt;/span&gt;&lt;span style=&#34;color:#81a1c1;font-weight:bold&#34;&gt;ADD&lt;/span&gt;&lt;span style=&#34;color:#eceff4&#34;&gt;[&lt;/span&gt;&lt;span style=&#34;color:#81a1c1;font-weight:bold&#34;&gt;COLUMN&lt;/span&gt;&lt;span style=&#34;color:#eceff4&#34;&gt;]&lt;/span&gt; &lt;span style=&#34;color:#81a1c1&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span style=&#34;color:#bf616a&#34;&gt;列名&lt;/span&gt;&lt;span style=&#34;color:#81a1c1&#34;&gt;&amp;gt;&lt;/span&gt; &lt;span style=&#34;color:#81a1c1&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span style=&#34;color:#bf616a&#34;&gt;数据类型&lt;/span&gt;&lt;span style=&#34;color:#81a1c1&#34;&gt;&amp;gt;&lt;/span&gt; &lt;span style=&#34;color:#eceff4&#34;&gt;[&lt;/span&gt;&lt;span style=&#34;color:#bf616a&#34;&gt;完整性约束&lt;/span&gt;&lt;span style=&#34;color:#eceff4&#34;&gt;]]&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#eceff4&#34;&gt;[&lt;/span&gt;&lt;span style=&#34;color:#81a1c1;font-weight:bold&#34;&gt;ADD&lt;/span&gt; &lt;span style=&#34;color:#81a1c1&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span style=&#34;color:#bf616a&#34;&gt;表级完整性约束&lt;/span&gt;&lt;span style=&#34;color:#81a1c1&#34;&gt;&amp;gt;&lt;/span&gt;&lt;span style=&#34;color:#eceff4&#34;&gt;]&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#eceff4&#34;&gt;[&lt;/span&gt;&lt;span style=&#34;color:#81a1c1;font-weight:bold&#34;&gt;DROP&lt;/span&gt; &lt;span style=&#34;color:#eceff4&#34;&gt;[&lt;/span&gt;&lt;span style=&#34;color:#81a1c1;font-weight:bold&#34;&gt;COLUMN&lt;/span&gt;&lt;span style=&#34;color:#eceff4&#34;&gt;]&lt;/span&gt; &lt;span style=&#34;color:#81a1c1&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span style=&#34;color:#bf616a&#34;&gt;列名&lt;/span&gt;&lt;span style=&#34;color:#81a1c1&#34;&gt;&amp;gt;&lt;/span&gt; &lt;span style=&#34;color:#eceff4&#34;&gt;[&lt;/span&gt;&lt;span style=&#34;color:#81a1c1;font-weight:bold&#34;&gt;CASCADE&lt;/span&gt;&lt;span style=&#34;color:#81a1c1&#34;&gt;|&lt;/span&gt;&lt;span style=&#34;color:#81a1c1;font-weight:bold&#34;&gt;RESTRICT&lt;/span&gt;&lt;span style=&#34;color:#eceff4&#34;&gt;]]&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#eceff4&#34;&gt;[&lt;/span&gt;&lt;span style=&#34;color:#81a1c1;font-weight:bold&#34;&gt;DROP&lt;/span&gt; &lt;span style=&#34;color:#81a1c1;font-weight:bold&#34;&gt;CONSTRAINT&lt;/span&gt;&lt;span style=&#34;color:#81a1c1&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span style=&#34;color:#bf616a&#34;&gt;完整性约束名&lt;/span&gt;&lt;span style=&#34;color:#81a1c1&#34;&gt;&amp;gt;&lt;/span&gt;&lt;span style=&#34;color:#eceff4&#34;&gt;[&lt;/span&gt;&lt;span style=&#34;color:#81a1c1;font-weight:bold&#34;&gt;CASCADE&lt;/span&gt;&lt;span style=&#34;color:#81a1c1&#34;&gt;|&lt;/span&gt;&lt;span style=&#34;color:#81a1c1;font-weight:bold&#34;&gt;RESTRICT&lt;/span&gt;&lt;span style=&#34;color:#eceff4&#34;&gt;]]&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#eceff4&#34;&gt;[&lt;/span&gt;&lt;span style=&#34;color:#81a1c1;font-weight:bold&#34;&gt;ALTER&lt;/span&gt; &lt;span style=&#34;color:#81a1c1;font-weight:bold&#34;&gt;COLUMN&lt;/span&gt; &lt;span style=&#34;color:#81a1c1&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span style=&#34;color:#bf616a&#34;&gt;列名&lt;/span&gt;&lt;span style=&#34;color:#81a1c1&#34;&gt;&amp;gt;&amp;lt;&lt;/span&gt;&lt;span style=&#34;color:#bf616a&#34;&gt;数据类型&lt;/span&gt;&lt;span style=&#34;color:#81a1c1&#34;&gt;&amp;gt;&lt;/span&gt;&lt;span style=&#34;color:#eceff4&#34;&gt;];&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;h3 id=&#34;删除基本表&#34;&gt;删除基本表&lt;/h3&gt;&#xA;&lt;p&gt;&lt;code&gt;DROP TABLE &amp;lt;表名&amp;gt; [CASCADE|RESTRICT]&lt;/code&gt;&lt;/p&gt;&#xA;&lt;h3 id=&#34;建立索引&#34;&gt;建立索引&lt;/h3&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;DBMS一般会自动建立PRIMARY KEY和UNIQUE列上的索引&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;p&gt;&lt;code&gt;CREATE [UNIQUE] [CLUSTER] INDEX&amp;lt;索引名&amp;gt; ON &amp;lt;表名&amp;gt; (&amp;lt;列名&amp;gt;[&amp;lt;次序&amp;gt;],[同前]···) &lt;/code&gt;&lt;/p&gt;&#xA;&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#d8dee9;background-color:#2e3440;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-sql&#34; data-lang=&#34;sql&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;e&lt;span style=&#34;color:#eceff4&#34;&gt;.&lt;/span&gt;&lt;span style=&#34;color:#81a1c1;font-weight:bold&#34;&gt;g&lt;/span&gt;&lt;span style=&#34;color:#eceff4&#34;&gt;.&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#81a1c1;font-weight:bold&#34;&gt;CREATE&lt;/span&gt; &lt;span style=&#34;color:#81a1c1;font-weight:bold&#34;&gt;UNIQUE&lt;/span&gt; &lt;span style=&#34;color:#81a1c1;font-weight:bold&#34;&gt;INDEX&lt;/span&gt; SCno &lt;span style=&#34;color:#81a1c1;font-weight:bold&#34;&gt;ON&lt;/span&gt; SC&lt;span style=&#34;color:#eceff4&#34;&gt;(&lt;/span&gt;Sno &lt;span style=&#34;color:#81a1c1;font-weight:bold&#34;&gt;ASC&lt;/span&gt;&lt;span style=&#34;color:#eceff4&#34;&gt;,&lt;/span&gt; Cno &lt;span style=&#34;color:#81a1c1;font-weight:bold&#34;&gt;DESC&lt;/span&gt;&lt;span style=&#34;color:#eceff4&#34;&gt;);&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;ul&gt;&#xA;&lt;li&gt;&#xA;&lt;p&gt;ASC-升序&#x9;DESC-降序&lt;/p&gt;</description>
    </item>
  </channel>
</rss>
