
[{"content":"\r更新计划 #\r无 ","date":"10 November 2024","externalUrl":null,"permalink":"/","section":"","summary":"","title":"","type":"page"},{"content":"\r文章归档 #\r","date":"10 November 2024","externalUrl":null,"permalink":"/posts/","section":"","summary":"","title":"","type":"posts"},{"content":"\r分类 #\r","date":"8 November 2024","externalUrl":null,"permalink":"/categories/","section":"","summary":"","title":"","type":"categories"},{"content":"大创要做一个基于两个特征矩阵的信号分割与分类（不知道该不该这么描述），精确度要求不高，但对实时性要求比较高。我想到了借鉴 YOLO 来解决这个问题，所以顺便就来读一下 YOLO 初代的论文，太复杂了猪脑是理解不能的。\nSkimming #\r摘要 #\rYOLO 做的活是 object detection。有如下特点：\n单 CNN 实现图像分割与分类，而不是两个阶段两个网络 推理快，能做到实时 45 fps 以上 比传统的 DPM 和 R-CNN 泛化性更好，准确性也是其他模型的大约两倍 佬就是佬，不需要什么花里胡哨的背景介绍，上来就是我们的模型吊打其他模型。\n介绍 #\r首先，YOLO 的推理过程和人眼很像。这应该是在暗示模型的名字由来（\n然后三大点：\nYOLO 很快。 YOLO 视野更广。推理图片是依靠图像全局信息，而不是滑动窗口那种局部信息。 YOLO 泛化很强。 原理 #\r这里得好好看，所以先跳过。\n对比其他网络 #\r对比了 DPM 和 R-CNN 等模型。除了这两个模型稍微认识以外，其他的都认不得。\n反正很强。\n原理 #\rOne-stage 如何实现 #\rYOLO 将一张图像分成了 $S$ 行 $S$ 列块方格。\n每一块方格负责预测：\n物体类别 $B$ 个预测框 (Bounding box)，以及对应置信度 参考下方图片。\n参考 #\r目标检测入门论文YOLOV1精读以及pytorch源码复现(yolov1) - 小小猿笔记 - 博客园\n","date":"8 November 2024","externalUrl":null,"permalink":"/posts/%E8%8A%9D%E5%A3%AB%E6%94%B6%E5%AE%B9%E6%89%80/%E8%AF%BB%E8%AE%BA%E6%96%87-yolo-v1/","section":"","summary":"大创要做一个基于两个特征矩阵的信号分割与分类（不知道该不该这么描述），精确度要求不高，但对实时性要求比较高。我想到了借鉴 YOLO 来解决这个问题，所以顺便就来读一下 YOLO 初代的论文，太复杂了猪\u0026hellip;","title":"读论文-YOLO v1","type":"posts"},{"content":"","date":"8 November 2024","externalUrl":null,"permalink":"/categories/%E8%8A%9D%E5%A3%AB%E6%94%B6%E5%AE%B9%E6%89%80/","section":"","summary":"","title":"芝士收容所","type":"categories"},{"content":"\rProg1 #\r使用 std::thread 来绘制分形图像。\n默认策略 #\r默认策略是将图像分成高度相同的几块，每一块分给一个线程画。\n这样其实做不到负载均衡，因为每一块画的工作量是不同的。\n特别是 view1，很明显发现画中间部分的线程工作时间远高于两边的线程。 代码实现很朴实，均分然后画就好了。\n在 R7 5800x上（原生 8 核心 16 线程），画 view1：\n8 线程倍率：4.04x 16线程倍率：7.55x 都被 view1 中的画中间部分的线程拖后腿了。\nint startRow = args-\u0026gt;height / args-\u0026gt;numThreads * args-\u0026gt;threadId, numRows = args-\u0026gt;height / args-\u0026gt;numThreads; mandelbrotSerial( args-\u0026gt;x0, args-\u0026gt;y0, args-\u0026gt;x1, args-\u0026gt;y1, args-\u0026gt;width, args-\u0026gt;height, startRow, numRows, args-\u0026gt;maxIterations, args-\u0026gt;output ); 均衡策略 #\r让线程按行交错绘制图像。\n其实这个策略是在模拟随机分配任务。思想是将任务分成尽可能小的部分，然后让大家随机挑任务做。\n可以证明对长度为 $n$ 的数列 $a$（工作量），在其中随机取 $n/s$ 项（$s$就是线程数），其和的期望是相同的。\n代码实现是按行交错绘制，实现起来比较简单。\n对于 view1：\n8 线程：7.53x 16 线程： 11.48x 16线程反而缩水得很严重，主要原因应该是 8 线程时每个线程独享一个核心，基本做到了并行。但是 16 线程时就是两个线程争抢一个核心了，需要并发。\nint totHeight = args-\u0026gt;height; for(int line = args-\u0026gt;threadId; line \u0026lt; totHeight; line += args-\u0026gt;numThreads) { mandelbrotSerial( args-\u0026gt;x0, args-\u0026gt;y0, args-\u0026gt;x1, args-\u0026gt;y1, args-\u0026gt;width, args-\u0026gt;height, line, 1, args-\u0026gt;maxIterations, args-\u0026gt;output ); } 核心与线程 #\r问 ChatGPT 得知，CPU 中核心和线程大概是这样的：\n但也存在少量架构中线程有独立的 L1 cache。\n","date":"8 November 2024","externalUrl":null,"permalink":"/posts/cs149-%E5%B9%B6%E8%A1%8C%E8%AE%A1%E7%AE%97/asst1/","section":"","summary":"使用 \u003ccode\u003estd::thread\u003c/code\u003e 来绘制分形图像。 默认策略是将图像分成高度相同的几块，每一块分给一个线程画。 这样其实做不到负载均衡，因为每一块画的工作量是不同的。 特别是 view1，很明显发现画\u0026hellip;","title":"Asst1","type":"posts"},{"content":"","date":"8 November 2024","externalUrl":null,"permalink":"/categories/cs149-%E5%B9%B6%E8%A1%8C%E8%AE%A1%E7%AE%97/","section":"","summary":"","title":"CS149-并行计算","type":"categories"},{"content":"\r需求 #\r校园网 128 位前缀的 IPV6 地址做 NAT6 IPV6 访问 PT 站 其他功能，比如魔法 网络环境是南京大学鼓楼校区校园网。仙林应该是差不多的。\n设备是小米路由器 4A v2。这个设备导致我装 Openwrt 的过程相当坎坷 TAT，再也不贪便宜买低端设备了。\n刷 Openwrt #\rBreed #\rBreed 是一种 bootloader，路由器会先引导至 Breed 后再引导你刷的其他系统。这样就不怕系统刷坏变砖了。\n刷 Breed 的教程很多，这里不再赘述。（刷一次基本一劳永逸了，所以不太记得怎么刷）\n自编译 Openwrt #\r你也可以选择在线编译 Openwrt 的方案，比如 Github Action 和 openwrt.ai。\n我之前直接使用了别人编译好的系统，但存在许许多多的问题导致 IPV6 配不起来，故尝试了自己编译，也还算有趣。\n编译的环境最好选 Linux 或者 WSL。常用的包和依赖得备齐，并且最好全程有魔法，否则很难编译成功。\n首先拉取 openwrt 源码。\ngit clone https://github.com/openwrt/openwrt 这样拉取到的是最新版。写作本文时最新版为 23.05.5，下文以此为准。\n如果你想从其他版本构建，比如 LEDE 或者老版本 Openwrt，可以参考小米4A千兆版V2刷自己编译的OpenWRT以及IPV6设置（包括中继与NAT6） - 哔哩哔哩\n在拉取下来的目录中运行：\ngit clone https://github.com/kenzok8/small-package package/small-package 这条命令把一些常用的软件包拉了下来，便于我们编译时选择。\n然后在仓库目录中运行下面两条命令，可能会花一点时间，取决于你的网络：\n./scripts/feeds update -a ./scripts/feeds install -a 然后我们开始配置 config：\nmake menuconfig 会弹出以下界面：\n前三项选成图中选项。其他的就是自由发挥了，根据你的需求来。\n刷入路由器 #\r拔掉路由器电源，按住 reset 键插上电，等三秒以上再松，访问 192.168.1.1 就能进入 Breed 页面。\n我们在固件备份中把系统和 eeprom.bin 备份一下。\n（图片引用自小米路由R4A千兆版安装breed+OpenWRT教程以及救砖（全脚本无需硬改） - 哔哩哔哩） 然后就是刷入固件了。\n但这一步中，小米路由器 4A v2 有一个大坑。不能直接用 breed 的固件更新刷固件。因为这个路由器的闪存布局比较独特，要把系统写到 0x180000 地址才能正常启动。如果你用 breed 的固件更新里刷固件，并且闪存布局是 0x50000 的话，路由器会无限重启。\n参考小米路由器 4A千兆版 V2 新版硬件安装OpenWRT - 知乎就好。十分感谢这位仁兄。\n开启 NAT6 #\r参考 #\r小米路由R4A千兆版安装breed+OpenWRT教程以及救砖（全脚本无需硬改） - 哔哩哔哩\n小米4A千兆版V2刷自己编译的OpenWRT以及IPV6设置（包括中继与NAT6） - 哔哩哔哩\n小米路由器 4A千兆版 V2 新版硬件安装OpenWRT - 知乎\n","date":"3 November 2024","externalUrl":null,"permalink":"/posts/%E6%9C%89%E6%84%8F%E6%80%9D%E7%9A%84%E6%8A%98%E8%85%BE/%E5%B0%8F%E7%B1%B3%E8%B7%AF%E7%94%B1%E5%99%A8-4av2-%E5%88%B7-openwrt-%E5%B9%B6%E5%BC%80%E5%90%AF-nat6/","section":"","summary":"网络环境是\u003ccode\u003e南京大学鼓楼校区校园网\u003c/code\u003e。仙林应该是差不多的。 设备是\u003ccode\u003e小米路由器 4A v2\u003c/code\u003e。这个设备导致我装 Openwrt 的过程相当坎坷 TAT，再也不贪便宜买低端设备了。 Breed 是一种 \u0026hellip;","title":"小米路由器 4Av2 刷 Openwrt 并开启 NAT6","type":"posts"},{"content":"","date":"3 November 2024","externalUrl":null,"permalink":"/categories/%E6%9C%89%E6%84%8F%E6%80%9D%E7%9A%84%E6%8A%98%E8%85%BE/","section":"","summary":"","title":"有意思的折腾","type":"categories"},{"content":"\rk-NN #\r算法流程 #\r对测试样本，找训练样本中最近的 $k$ 个，这 $k$ 个样本中标签最多的就是测试样本的类。\nk 的取值 #\rk 一般取奇数值，避免平局 k 取不同的值，分类结果可能不同 k 值较小时，对噪声敏感，整体模型变得复杂，容易过拟合 k 值较大时，对噪声不敏感，整体模型变得简单，容易欠拟合 变种 #\r最邻近分类器 #\rk-NN 的 $k=1$ 的特殊情况。\n","date":"25 October 2024","externalUrl":null,"permalink":"/posts/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/k-%E9%82%BB%E8%BF%91%E5%88%86%E7%B1%BB%E5%99%A8/","section":"","summary":"对测试样本，找训练样本中最近的 $k$ 个，这 $k$ 个样本中标签最多的就是测试样本的类。 k-NN 的 $k=1$ 的特殊情况。","title":"K 邻近分类器","type":"posts"},{"content":"","date":"25 October 2024","externalUrl":null,"permalink":"/categories/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/","section":"","summary":"","title":"机器学习","type":"categories"},{"content":"","date":"20 October 2024","externalUrl":null,"permalink":"/categories/c++%E6%8B%BE%E9%81%97/","section":"","summary":"","title":"C++拾遗","type":"categories"},{"content":"\rtypedef #\r字面意思，给类型取别名。\n和 define 的区别 #\rdefine 可以替换任何东西，比如常量、编译开关等\ndefine 在编译之前的预处理阶段生效，typedef 在编译阶段生效。\ntypedef可以只在某个作用域内生效。\nint main() { typedef int size_t; size_t s = 3; fun(); } int fun() { size_t t = 2; // ERROR } 对指针的修饰不同 含 const 时，两者不等价 TODO\n类型别名 #\rtypedef unsigned int size_t 结构体别名 #\rtypedef struct person{ char name[128]; }Person; Person a; 函数指针别名 #\rtypedef void*(*Fun) ","date":"20 October 2024","externalUrl":null,"permalink":"/posts/c++%E6%8B%BE%E9%81%97/%E5%85%B3%E9%94%AE%E5%AD%97/","section":"","summary":"字面意思，给类型取别名。 ```cpp int main() { typedef int size_t; size_t s = 3; fun(); } int fun() { size_t t = 2\u0026hellip;","title":"关键字","type":"posts"},{"content":"\r写在前面 #\r写这部分是为了：\n读懂复杂且恶心的类型声明，比如 void (*signal(int, void (*fp)(int)))(int); 考试 记住要：\n不写这种不符合规范，并且恶心他人的声明 多用 using，适度用 typedef 对恶心的写法说 no 推荐这个网站，能帮你把 C 类型声明翻译成自然语言：\ncdecl: C gibberish ↔ English\n变量声明说明符 #\r本文中，我们只关心如下几种说明符，因为这几种说明符是最困难的部分：\n*: 指针 []: 数组 (): 括号（改变声明优先级）或者 函数指针 \u0026amp;: 引用 优先级 #\r括号括住的部分 \u0026gt; 后缀说明符 \u0026gt; 前缀说明符 读声明 #\r优先级规律总结出来其实就是 右左法则，或者叫 clockwise/spiral Rule。\n法则内容如下：\n从唯一的未定义的标识符开始 #\r声明语句中，有且仅有一个之前没定义过的标识符。我们就从这个标识符开始。\nint ((*fp)[MAXN])(int x, int y); 上例就是 fp。\n先看右边的声明符，再看左边 #\r因为后缀说明符优先级更高，所以先看右边。\n将看到的声明符转译为英文 #\r看到了哪个声明符，就将如下列出的翻译模板加到我们当前的翻译栈中。\n指针 / 引用：a pointer / reference to\n数组：an array of\n函数：a function passing (params) returning a\n遇到非函数指针的括号就换方向 #\r意思就是必须将当前括号里面的声明处理完毕才能跳出去。这是为了保证括号的优先级。\n参考资料 #\r如何解释复杂的 C/C++ 声明 - 知乎\nc 语言中的复杂声明_c++ 数组复杂声明 读法-CSDN博客\n复杂的指针_复杂的指针问题-CSDN博客\nClockwise/Spiral Rule\nparsing - C isn\u0026rsquo;t that hard: void ( *( *f[] ) () ) () - Stack Overflow\n📝笔记：使用Clockwise/Spiral Rule技巧轻松读懂变量/函数声明 | RealCat\ncdecl: C gibberish ↔ English\n","date":"13 October 2024","externalUrl":null,"permalink":"/posts/c++%E6%8B%BE%E9%81%97/%E7%B1%BB%E5%9E%8B%E8%A7%A3%E9%87%8A/","section":"","summary":"写这部分是为了： 记住要： 推荐这个网站，能帮你把 C 类型声明翻译成自然语言： 本文中，我们只关心如下几种说明符，因为这几种说明符是最困难的部分： ```text 括号括住的部分 \u0026gt; 后缀说明符 \u0026gt;\u0026hellip;","title":"类型解释","type":"posts"},{"content":"\r前言 #\r在以前打竞赛的时候，基本都是用字符数组配合string.h里的函数去处理字符串。现在开始系统地接触C++，所以来记录一下string类的知识。\n简介 #\rstring 是 C++ 风格的字符串类，也是一种STL容器(根据CppReference说法，string是唯一的伪容器)。相比于 C 风格的字符串 char[] ，string 支持自动内存管理，并且拥有很多方便的函数。\n头文件：string\n构造 #\r一般构造 #\rstd::string(const char* s) std::string(const string\u0026amp; s) 传入一个 C 字符串或者字符串类，变成 C++ string类。没什么好说的。\n特殊构造 #\r直接赋值string str = \u0026quot;...\u0026quot; 直接将 C 字符串赋值或者类型转换。\nstd::string(size_t n, char c) 构造一个 n 个 c 的字符串。也就是将 c 重复 n 次。\n属性 #\r长度 #\r优先 string.length()。\n其他诸如 string.size() 和 strlen(const \u0026amp;string)。\n是否空 #\r和其他 STL 容器一样，判断 string 是否为空：\nstring.empty()\n访问与遍历 #\r索引 #\rstr[i] 直接得到对应字符。\n迭代器 #\rstring.begin(), string.end() 得到头尾 iterator。\nForeach #\r和 Java 一毛一样。你乐意用 auto 也行，反正元素就是char。\nfor(char c : str) 常用 #\r修改 #\r修改元素 #\r修改元素用索引、迭代器这些都行，或者下面的 replace。\nstr.insert(pos, str2)\n在索引为pos的地方插入str2。\n就是说，插入的str2的第一个元素在修改后的str的pos处。\n修改子串 #\rstr.replace(pos, len, str2)\npos 索引(0开始)，长度为 len 的子串替换成 str2。\nstr.erase(pos, len)\n删除 pos 开始长度为 len 的子串。\n连接 #\r+\n直接+号运算就行。\nstr.append(str2)\n这个不用说了。\n查找 #\rstr.find(str2)\n找 str 中 str2 的索引。找不到返回 -1。\nstr.rfind(str2)\n反着找。\n截取子串 #\rstr.substr(pos, len)\n注意！！！和 Java 不一样！！！\n截取 pos 开始，长度为 len 的子串。\n转数字 #\rstoi(str)：int stof(str)：float stod(str)：double 还有很多，按需取用。 大小写 #\rtoupper(str) 和 tolower(str)。\n","date":"12 October 2024","externalUrl":null,"permalink":"/posts/c++%E6%8B%BE%E9%81%97/string/","section":"","summary":"在以前打竞赛的时候，基本都是用字符数组配合\u003ccode\u003estring.h\u003c/code\u003e里的函数去处理字符串。现在开始系统地接触C++，所以来记录一下\u003ccode\u003estring\u003c/code\u003e类的知识。 \u003ccode\u003estring\u003c/code\u003e 是 C+格的字符串类，也是一种\u0026hellip;","title":"String","type":"posts"},{"content":"\r引用 #\r引用和指针 #\r以我的粗浅且可能有很大错误的理解，引用就是有着一些限制、有一些封装的指针，这些限制在编译器层面解决，底层就是以指针形式实现。\n限制在如下几点：\n引用创建时需要初始化 引用在初始化后无法再改变指向 所以不存在 const int\u0026amp; 引用带来的方便：\n引用的元素可以直接按名访问，不需要解指针 指针 #\r指针是指向一块内存首地址的变量。指针的类型提供了对于这个首地址该如何解释的信息。\n智能指针 #\rTODO：目前是从 YDJSIR 笔记中复制粘贴的\n通过将一些需要的信息进行封装的方法，来保证不管出现什么异常，在退出相应操作部分时，自动调用对象的析构函数来保证不会出现内存泄漏的问题。\n同样的还有句柄类(C++ 异常中有)\ntemplate \u0026lt;class T\u0026gt; class auto_ptr{ public: auto_ptr(T *p=0):ptr(p) {} ~auto_ptr() { delete ptr; } T* operator-\u0026gt;() const { return ptr;} T\u0026amp; operator *() const { return *ptr; } private: T* ptr; }; //结合智慧指针使用 void processAdoptions(istream\u0026amp; dataSource){ while (dataSource){ auto_ptr\u0026lt;ALA\u0026gt; pa(readALA(dataSource)); pa-\u0026gt;processAdoption();//只要对象结束，就会自动delete } } 函数指针 #\r函数指针能够像传递参数一样传递函数。并且也便于我们实现多态。\n对于函数指针的简单使用，我还是持开放态度的。但是众所周知，函数指针是能够复杂到令人呕吐的程度的。这种情况还是尽可能不要用函数指针了，要不就用 typedef 定义得好看点。不要恶心自己的同时还恶心他人……\n定义函数指针 #\rint (*fp)(int); fp 就可以存放返回值为 int，参数为一个 int 的函数了。\n可以这样理解：fp 是标识符，*fp 中的 * 在说这个变量是个指针，最前面的 int 和后面括号中的 (int) 说明了这是函数指针，并指明了参数和返回值。\nint func(int a); // 写法1：直接赋值 fp = func; // 写法2：取地址再赋值 fp = \u0026amp;func; 对 fp 的赋值，两种写法均可。写法1 是写法2 的语法糖。\n调用 #\r// 写法1：直接调用 fp(1); // 写法2：解引用后再调用 (*fp)(1); 既可以直接调用，也可以解引用后再调用。\nChatGPT 说直接调用的写法实际上是个 Syntax sugar，编译器会将直接调用改成解引用后再调用的写法。也就是写法1 编译后和写法2 无异。这个说法令人信服，毕竟直接调用的行为本质上是对一个指针变量也就是一个地址进行调用，这是完全没有意义的。\n作为参数传递 #\rint foo(int arg1, int (*fp)(int)) { result = fp(arg1); } 写法和定义类似。这里函数指针作为参数传递的一大重要作用是可以实现多态。\n使用 typedef 简化函数指针 #\rtypedef int (*FP)(int) FP fp = func； fp(1); typedef 之后， FP 就是这类函数指针的类型别名了。\n这 typedef 的写法，评价为纯纯的答辩。但是这样简化之后，再使用这个函数指针类型就方便了。\n深入赤石 #\r以下内容相对复杂，建议浅尝辄止。实际生产中最好不要使用太多复杂的函数指针。\n函数指针数组 其实，函数指针数组还不错。初见函数指针数组还是操作系统实验中，使用函数指针存放信号处理函数。\nvoid (*sigaction[SIGNAL_NUM](int, struct proc *)); // typedef 防赤石 typedef void (*sigaction_ptr)(int, struct proc *); sigaction_ptr[SIGNAL_NUM]; 写法还是相对清晰的。可以类比指针数组的写法：\nchar *str_list[STR_NUM]; 函数指针作为返回值 void (*(*f(int)))(int, int) 数组 #\r只要时刻记住，数组是存放在连续空间上的一系列数据。我们想以几维访问都无所谓，只要保证不越界就行。\n一维数组 #\r没什么好说的，搬一些数组访问的等价式。说白了就是一些语法糖。\na[i] == *(a + i) \u0026amp;a[0] = a 二维数组 #\r同样搬等价：\nint b[MAXN][10]; int *q; b[i][j] == *(b + i * 10 + j) // 第二维大小在这起作用 == q[i * 10 + j] // 降维操作，按一维访问 升维降维 #\r我重新理解了这部分。升维降维，归根结底还是逃不出数组的本质：一块连续的内存。\n对一块长度为 LEN 字节的数组 a ：\n我们如何去解释这块内存中的每个元素，决定了我们遍历的总次数，也就是元素个数。\nbyte_t *a = malloc(LEN); // 解释为 char，就遍历 LEN 次 char *p_char = (char *) a; for(int i = 0; i \u0026lt; LEN; i++) char element = p_char[i]; // 解释为 int，就只要遍历 LEN / 4 次 int *p_int = (int *) a; for(int i = 0; i \u0026lt; LEN / 4; i++) int element = p_int[i]; // 解释为 char[10]，就要遍历 LEN / 10 次 char (*p_char10)[10] = (char (*)[10]) a; for(int i = 0; i \u0026lt; LEN / 10; i++) char *element = p_char5[i]; 我们决定好了元素解释方法后，总次数确定了。假设总次数为 t ，我们想以几维访问就以几维访问，只要和逻辑相符就行。\n同时，用 typedef 或者 using 将元素的类型抽象出来会简化很多工作。\n参考资料 #\rYDJSIR 的 C++ 笔记\nCPL-2023\n万字长文系统梳理一下C++函数指针 - 知乎\nC++ 函数指针 \u0026amp; 类成员函数指针 | 菜鸟教程\n","date":"12 October 2024","externalUrl":null,"permalink":"/posts/c++%E6%8B%BE%E9%81%97/%E6%8C%87%E9%92%88%E5%BC%95%E7%94%A8%E4%B8%8E%E6%95%B0%E7%BB%84/","section":"","summary":"以我的粗浅且可能有很大错误的理解，引用就是有着一些限制、有一些封装的指针，这些限制在编译器层面解决，底层就是以指针形式实现。 限制在如下几点： 引用带来的方便： 指针是指向一块内存首地址的变量。指针的\u0026hellip;","title":"指针、引用与数组","type":"posts"},{"content":"\r前言 #\rSTL 有五大组件：\n容器（Container），数据结构； 迭代器（Iterator），提供了一种顺序访问容器中对象的方法。 算法（Algorithm），是用来操作容器中的数据的模板函数。 仿函数（Functor），就是使一个类的使用看上去象一个函数，就是类中实现一个operator()。 适配器（Adaptor），对原有的容器进行包装，给换一套接口。 容器 #\r序列容器 #\r序列容器实现能按顺序访问的数据结构。\nvector #\r动态数组。\ndeque #\r双端队列。\nlist #\r双向链表。\narray #\rC++11\nC 风格的固定大小的数组。\nforward_list #\rC++11\n单向链表。性能比 list 略好，基本和 C 中的链表无异。\ninplace_vector #\rC++26\n可动态调整大小的固定容量原位连续数组。\n太新了，先不管。\n关联容器 #\r关联容器实现能快速查找（$O(log n)$ 复杂度）的有序数据结构。\nset #\rmultiset #\rmap #\rmultimap #\r参考 #\rC++ STL 教程 | 菜鸟教程\nCppReference\n","date":"12 October 2024","externalUrl":null,"permalink":"/posts/c++%E6%8B%BE%E9%81%97/stl/","section":"","summary":"STL 有五大组件： 序列容器实现能按顺序访问的数据结构。 动态数组。 双端队列。 双向链表。 C 风格的固定大小的数组。 单向链表。性能比 \u003ccode\u003elist\u003c/code\u003e 略好，基本和 C 中的链表无异。 可动态调整\u0026hellip;","title":"STL","type":"posts"},{"content":"","date":"8 October 2024","externalUrl":null,"permalink":"/categories/%E7%AE%97%E6%B3%95%E4%B8%8E%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/","section":"","summary":"","title":"算法与数据结构","type":"categories"},{"content":"本专题(算法与数据结构)主要用以复习与回忆，内容量少且相当不全面。\n写这个专题的主要原因是刷力扣的时候唤起了曾经竞赛的回忆，借博客给这些陈旧的知识重新打包装好，顺便应对以后保研或者应聘的机试。当然，能学些以前不会的知识自然是最好的。\n主要内容参考 OI Wiki，内容分类也是相同的方式。\n如果要从0开始学还是去看 Wiki 或者别的教程罢。这样一方面能减少写文章的压力，另一方面能学了不至于白学。\n已更新 #\r数据结构 #\r单调队列 单调栈 更新计划 #\r基本是力扣\n","date":"8 October 2024","externalUrl":null,"permalink":"/posts/%E7%AE%97%E6%B3%95%E4%B8%8E%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E4%B8%93%E9%A2%98%E5%AE%9A%E4%BD%8D/","section":"","summary":"本专题(算法与数据结构)主要用以复习与回忆，内容量少且相当不全面。 写这个专题的主要原因是刷力扣的时候唤起了曾经竞赛的回忆，借博客给这些陈旧的知识重新打包装好，顺便应对以后保研或者应聘的机试。当然，能\u0026hellip;","title":"专题定位","type":"posts"},{"content":" 数据结构篇\n省流 #\r单调队列：获得 区间(滑动窗口)的 最值\n单调栈：获得 某元素 周围 第一个 大于或者小于它 的元素\n实际运用多为以上两种情况，但仍需活学活用，不能被上面的两种情况限制。\n细说 #\r单调队列 #\r比喻 #\r之前在力扣评论区刷到过如下比喻：\n公司的所有员工按年龄排列成一个单调的队列。\n公司将不断招入年轻员工。如果年轻员工比某些老员工能力强，那就毫不犹豫踢掉这些老员工(补药啊)。\n同时，踢掉大于35岁的老员工，无论能力多强都踢掉。\n这个比喻就把单调队列的出入队概括完了，很好理解。\n为什么 #\r单调队列怎么做到通过维护一个队列，队头刚好是所求区间上的最大值呢（最小值同理，以下例子为最大值）？\n首先，很容易明白的一点，就是这个区间的最大值一定能留在队头。\n我们担心的是，这个最大值一旦离开区间了，谁来当二把手呢？\n我们想到可以搞个二把手候选人队列，有可能当二把手的元素都进来，从大到小排着，老大挂了就上老二。\n那为什么要让能力强的新人把比他弱的老东西踢掉呢？因为新人能活最久，并且当二把手的优先级也高于老东西，那这些老东西一定是不可能当二把手的，不符合我们队列的要求，所以直接踢掉。\n单调栈 #\r单调栈也完全可以通过上面的比喻来理解。但是不能踢35岁老员工了，单调栈是一个尊重老人的公司。\n获得 某元素 周围 第一个 大于或者小于它 的元素 是什么意思呢？\n当一个新人比一堆老员工强的时候，这些老员工全会被踢。所以，这个新人就是第一个比这些老员工强的人。换句话说，新入栈的元素是第一个比 因为这个元素而退栈的元素 大的元素。这句话很绕，慢点读别噎着了。\n但这样我们只能做一个方向。所以得维护两个单调栈，就能得到每个元素“周围”的满足要求的元素了。\n练练手 #\r单调队列 #\r力扣-滑动窗口最大值\nP2698 [USACO12MAR] Flowerpot S - 洛谷 | 计算机科学教育新生态 (luogu.com.cn) - 此题甚妙，有点难\n单调栈 #\rP5788 【模板】单调栈 - 洛谷 | 计算机科学教育新生态 (luogu.com.cn)\nP1901 发射站 - 洛谷 | 计算机科学教育新生态 (luogu.com.cn)\n","date":"7 October 2024","externalUrl":null,"permalink":"/posts/%E7%AE%97%E6%B3%95%E4%B8%8E%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E5%8D%95%E8%B0%83%E9%98%9F%E5%88%97--%E5%8D%95%E8%B0%83%E6%A0%88/","section":"","summary":"单调队列：获得 区间(滑动窗口)的 最值 单调栈：获得 某元素 周围 第一个 大于或者小于它 的元素 实际运用多为以上两种情况，但仍需活学活用，不能被上面的两种情况限制。 之前在力扣评论区刷到过如下比\u0026hellip;","title":"单调队列 \u0026 单调栈","type":"posts"},{"content":"\r基本思想 #\r决策树就是一颗 if-else 树。树的每一个结点代表一个决策（测试），同时也代表了这个决策所对应的一个样本空间。我们的目标就是通过多次产生 if-else 分支，尽可能地让决策树的叶子结点只包含相同标签的样本。\n既然是一棵树，我们就从递归建树的角度来理解决策树的基本思想。\n基础 #\r决策树的根节点代表了整个样本空间，没有任何划分或决策。\n下图的例子只有连续属性，将就看吧。\n递归 #\r假设我们在某一结点下。只考虑这个结点所代表的子样本空间。\n建树就是要加深树的深度，即产生 if-else 分支。具体来说就是在当前的样本空间中插入决策边界，划分出的多个新的样本空间就是儿子们的样本空间。\n我们每次递归只选择样本的某一个属性进行划分。\n离散属性 #\r将这个属性的每一个取值都划出一个空间。\n假如这个属性$a$取值集合是$D={x, y, z}$，我们就划出三个空间，对应这三个取值。这样这个结点下就生出了三棵子树。if-else如下：\nif(a == x) { SubTree1; }else if(a == y) { SubTree2; }else { SubTree3; } 连续属性 #\r基本方法就是将连续属性变成离散属性。常用的方法是二分法。\n对连续属性$A$，取合适的值$x$。通过如下函数，我们能得到一个离散属性$B=\\{X, Y\\}$。\n$$\rb=f(a)=\\left\\{\r\\begin{aligned}\rX, a\\le x \\\\\rY, a\\gt x\r\\end{aligned}\r\\right.\r$$取合适的值一般会取中位数。\n如上图，我们横着插了一条决策边界，这条边界代表如下决策：\nif(x \u0026lt;= 0.0596) { LeftSubTree; } else { RightSubTree; } 停止条件 #\r只要当前结点的样本空间只存在一类标签的样本，我们就停止递归此结点。 这样会导致十分严重的过拟合。解决方法看后面。\n当前属性集为空, 或是所有样本在所有属性上取值相同，无法划分 当前结点包含的样本集合为空，不能划分 取最优划分属性 #\r我能想到三种取决策边界的方法。\n随便取 #\r没错，随机永远是你大爷。我们随机取一个属性进行划分。\n只要递归次数够多，一定能到达停止条件。只是这样建出来的树可能够让大半个中国在树底下乘凉了。\n信息增益 #\rID3 决策树\n假定当前样本集合$D$中第$k$类样本所占的比例为$p_k$ 定义信息熵如下：\n$$Ent(D)=-\\sum_{k=1}^{|y|}p_klog_2p_k$$ 信息熵是度量样本集合“纯度”最常用的一种指标\n说人话，样本集合越杂，信息熵越大。\n假设离散属性$a$的取值集合为$\\{a^1,a^2,...,a^V\\}$，$D^v$是$D$中在$a$上取值等于$a^v$的样本集合。 由此定义以属性$a$对$D$进行划分的信息增益为：\n$$\rGain(D,a)=Ent(D)-\\sum_{v=1}^{V}\\frac{|D^v|}{|D|}Ent(D^v)\r$$可以看到，信息增益就是以属性$a$划分前后的信息熵差值来定义的。而划分后的信息熵是按样本数为权重求和来的。\n信息增益越大，说明以这个属性划分后信息熵减小得越多，划分后的子样本空间最纯。所以我们对所有属性中增益最大的进行划分就好了。\n增益率 #\rC4.5 决策树\n只有一页 PPT。\n增益率是对信息增益的补充。\n基尼指数 #\rCART 决策树\n基尼指数本质反映了从$D$中随机抽取两个样例，其类别标记不一致的概率。\n定义如下：\n$$\r\\begin{equation}\r\\begin{aligned}\rGini(D) \u0026= \\sum^{|y|}_{k=1}\\sum_{k^{'}\\neq k}p_kp_{k^{'}} \\\\\r\u0026= 1-\\sum^{|y|}_{k=1}p_k^2 \\\\\r\u0026= 1-\\sum^{|y|}_{k=1}(\\frac{|D^k|}{|D|})^2\r\\end{aligned}\r\\end{equation}\r$$其中，$p_k$是样本点属于第$k$类的概率，$D^k$是样本集合$D$中属于第$k$类的样本子集。\n而属性$a$划分下的基尼指数为：\n$$\rGini\\_index(D,a)=\\sum_{v=1}^{V}\\frac{|D^v|}{|D|}Gini(D^v)\r$$即按样本数对基尼指数加权平均求和。同样地，我们取$Gini\\_index$最小那个属性就行了。\n剪枝 #\r前面说了，决策树的停止条件之一是叶子只包含一类标签的样本，而这样会导致很强的过拟合，在训练集上也会达到 100%的正确率。所以我们需要剪枝来增强泛化性能。\n预剪枝 #\r及早停止树的生长\n限制树的高度 #\r这个很好理解。结点一旦长到一定高度了，就直接不让它继续往下长了。\n评估法 #\r我随便起的名字。\n思路是每次生长的时候，评估生长后的决策树在验证集上的表现。然后根据一定的策略决定是否继续生长下去。\n比如，如果生长后验证集准确率降低了，我就不让树继续长了；否则，树就可以继续长。\n其他 #\r剪枝这个东西，可操作空间相当大。根据实际任务去选择合适的剪枝方案才是可行之法。同时，不同的剪枝方法也可以相互融合，生成效果更好的剪枝。\n后剪枝 #\r随后删除或折叠信息量很少的结点\n评估法 #\r还是评估法，没想到吧！\n思路是将已经长好的结点收缩。\n详细一点：\n我们考虑要剪枝的结点$k$，以$k$为根节点的子树有叶子$\\{l_1, l_2, l_3...l_n\\}$\n从 1 到 n，将这棵子树坍缩成叶子，并根据验证集评估整颗决策树。\n选择评估结果最好的叶子，再决定是否剪枝即可。\n中间涉及的一些策略很含糊，因为这是根据实际去替换的部分。\n对比 #\r时间开销 预剪枝：测试时间开销降低，训练时间开销降低\n后剪枝：测试时间开销降低，训练时间开销增加\n过/欠拟合风险 预剪枝：过拟合风险降低，欠拟合风险增加\n后剪枝：过拟合风险降低，欠拟合风险基本不变\n泛化性能 后剪枝 通常优于 预剪枝\n其他 #\r连续值和离散值 #\r连续值 -\u0026gt; 离散值 一般而言，可以用二分法。\n即取属性值的中位数$med$，对于取值小于$med$的归为一号类，其他归为二号类。\n离散值 -\u0026gt; 连续值 离散值编号就行。\n代码实现 #\r我们来通过 Python 实现一个决策树。这个决策树是将所有属性视作连续值，并且使用二分法，所以建出来是二叉树。\n完全是我闭门造车实现的，只是借鉴了sklearn的api，具体实现应该十分不标准，请勿过度参考！\n结点类 #\r既然是一颗树，我们先来定义树的结点类。\nclass Node: def __init__(self, ind, splitter, label): self.ind = ind self.splitter = splitter self.lson = None self.rson = None self.label = label def test(self, x): if self.lson is None or self.rson is None: return self.label if x[self.ind] \u0026lt; self.splitter: return self.lson.test(x) else: return self.rson.test(x) 初始化函数中：\nind：结点负责的属性编号 splitter：结点对ind号属性做决策的决策边界。小于splitter到左子树，否则柚子树。 label：此结点的类别标记。表示决策做到这个结点时将样本认定为哪个类。 test函数：输入样本x，输出预测类编号。\n决策树类 #\r接下来，写一个决策树类。负责管理Node，并向外提供接口。\nclass MyDecisionTree: def __init__(self, criterion=\u0026#39;gini\u0026#39;, max_depth=255): # criterion self.criterion = Criterion() if criterion == \u0026#39;gini\u0026#39;: self.criterion = Gini() if criterion == \u0026#39;entropy\u0026#39;: self.criterion = Entropy() if criterion == \u0026#39;random\u0026#39;: self.criterion = Random() # depth self.max_depth = max_depth def fit(self, x, y): self.root = self.build(x, y, 0) def score(self, x, y): acc = 0 for i in range(len(y)): tar = self.root.test(x[i]) if tar == y[i]: acc += 1 print(f\u0026#34;Accuracy: {acc * 1.0 / len(y)}\u0026#34;) def build(self, x, y, depth): if depth \u0026gt;= self.max_depth: return None clazz_count = len(np.unique(y)) if clazz_count == 0: return None if clazz_count == 1: return Node(0, 0, np.unique(y)[0]) ind, splitter = self.criterion(x, y) node = Node(ind, splitter, np.argmax(np.bincount(y))) l_rows = np.where(x[:, ind] \u0026lt;= splitter)[0] r_rows = np.where(x[:, ind] \u0026gt; splitter)[0] node.lson = self.build(x[l_rows], y[l_rows], depth + 1) node.rson = self.build(x[r_rows], y[r_rows], depth + 1) return node 初始化函数可以选择取划分属性的标准、树的最大深度。 fit: 在输入的数据集上进行训练 score：在输入的数据集上进行测试 _build：递归建树。包含了停止条件的检查以及划分属性的选择。 选取属性策略 #\r基于Criterion父类实现了Gini、Entropy和Random的属性选取策略。\n使用了二分法，将样本属性的中位数作为分类边界。所以Gini和Entropy中的$\\frac{|D^v|}{|D|}$可以认为是$\\frac{1}{2}$。\nclass Criterion: def __call__(self, x, y) -\u0026gt; tuple[int, int]: pass class Gini(Criterion): def __call__(self, x, y) -\u0026gt; tuple[int, int]: median = np.median(x, axis=0) ind, gini_min = 0, 1 for i in range(x.shape[1]): l_rows = np.where(x[:, i] \u0026lt;= median[i])[0] r_rows = np.where(x[:, i] \u0026gt; median[i])[0] gini_i = 0.5 * (Gini.clac_gini(y[l_rows]) + Gini.clac_gini(y[r_rows])) if gini_i \u0026lt; gini_min: ind = i gini_min = gini_i return ind, median[ind] def clac_gini(y): uy, counts = np.unique(y, return_counts=True) probabilities = counts / counts.sum() gini = 1 - np.sum(probabilities ** 2) return gini class Entropy(Criterion): def __call__(self, x, y) -\u0026gt; tuple[int, int]: median = np.median(x, axis=0) ind, gain_max = 0, 0 for i in range(x.shape[1]): l_rows = np.where(x[:, i] \u0026lt;= median[i])[0] r_rows = np.where(x[:, i] \u0026gt; median[i])[0] gain_i = Entropy.clac_entropy(y) - 0.5 * (Entropy.clac_entropy(y[l_rows]) + Entropy.clac_entropy(y[r_rows])) if gain_i \u0026gt; gain_max: ind = i gain_max = gain_i return ind, median[ind] def clac_entropy(y): uy, counts = np.unique(y, return_counts=True) probabilities = counts / counts.sum() ent = - np.sum(probabilities * np.log2(probabilities)) return ent import random class Random(Criterion): def __call__(self, x, y) -\u0026gt; tuple[int, int]: ind = random.randint(0, x.shape[1] - 1) median = np.median(x[:, ind]) return ind, median 使用与测试 #\r在breast cancer数据集上做测试。\nds = datasets.load_breast_cancer() x = np.array(ds.data) y = np.array(ds.target) x_train, x_test, y_train, y_test = train_test_split(x, y, test_size=0.2, shuffle=True) 借鉴了sklearn的api，所以使用方法基本是一致的。\ntree = MyDecisionTree(criterion= \u0026#39;gini\u0026#39;, max_depth=20) tree.fit(x_train, y_train) tree.score(x_train, y_train) tree.score(x_test, y_test) Output:\nAccuracy: 0.978021978021978\rAccuracy: 0.9473684210526315 效果还不错。\n后记 #\r还有很多东西可以实现，比如剪枝、计算熵和基尼指数的矩阵加速、属性贡献率等等。但是我懒得在这里花太多时间了，毕竟就算用到也不需要知道原理，我也不是搞机器学习的是吧。\n","date":"30 September 2024","externalUrl":null,"permalink":"/posts/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/%E5%86%B3%E7%AD%96%E6%A0%91/","section":"","summary":"决策树就是一颗 \u003ccode\u003eif-else\u003c/code\u003e 树。树的每一个结点代表一个决策（测试），同时也代表了这个决策所对应的一个样本空间。我们的目标就是通过多次产生 \u003ccode\u003eif-else\u003c/code\u003e 分支，尽可能地让决策树的叶子结点只\u0026hellip;","title":"决策树","type":"posts"},{"content":"\r日益增长的博客需要 #\r写博客这件事，从初三开始打竞赛就已经提上日程了。当时很草率地创建了一个洛谷博客，然后一篇文章都没有www。后来又存在各种阻力，例如高中的学业压力、只有周末接触电子设备的机会。但对博客与日俱增的需求的动力也在对冲这些阻力。从一开始只是希望总结竞赛算法，到现在的记录学业、技术、生活等等方面的需求。于是在大三开学刚转完专业能够摸鱼之际，我真正开始着手于部署一个能暂且满足以上需要的博客。\n博客搭建初期探索 #\r自建、自部署博客 #\r为什么会考虑自己搭建博客框架、自己部署，原因如下：\n有一台 阿里云ECS，宿舍有一台小服务器。可以锻炼部署能力，发扬折磨精神。顺便玩一下之前没怎么接触过的 Nginx 系统性地修补我支离破碎的前端知识，磨练后端技术，增加项目经历。以后干不下去了可以搞开发。 自建博客对日后变化的需求友好，可以随时迭代满足需要。而且能保证满足审美。 这几个原因看着很踏实，但是当我一开始写了我才发现自己根本没有这个时间和精力。光这一点便难以支撑了😭。\n日后对这一方案的评价：可以像 jyy wiki 写纯html没css的博客。但还是需要一点时间。\nWordPress #\r上一方案破产之后，我转而尝试他人已经写好的框架。要说这个世界上最著名的自建网站框架，WordPress肯定是首屈一指的，于是我在宿舍的小服务器上搭建了WordPress，过程还是很简单的，网上教程多如牛毛。\n于我而言，WordPress的优点有三：\n搭建方便。尤其是用 Docker，起两个容器就行了 美化方便。WordPress主题数不胜数，并且很多主题可以在后台用GUI自定义一些元素。 管理方便。WordPress后台功能齐全，界面还说的过去。 缺点也有几个：\n如果要开https，得每三个月续一次证书（虽然有工具可以自动化） 功能太多了，图形界面用起来压力很大。想尽量简洁和轻量 服务器反向代理时，我无法解决跨域请求资源的问题，我太菜了🤡 总之，用起来哪哪都有一点不舒服。但是我感觉WordPress这个框架整体还是相当强大的，用不下去的主要原因除了上述缺点，更多的是我当时不太愿意深入研究这个框架。说不定我以后会用WordPress。\n静态博客框架 #\r上面两个方案都是自部署的方案。除此之外便是托管部署了，比如 Vercel 和 Github Pages 这种。我真正愿意考虑这个方案的一大契机，是我的很多优秀学长的博客都是这个方案搭建的，而且看起来效果相当好。\n学长普遍是 Hexo 框架 + Github Pages 搭建。我也照做。当我在查阅 Hexo 框架的文档和资料时，了解到了另一个叫Hugo的框架。\n经过对比，我选择了Hugo框架。Hugo框架是基于Go语言实现的，比Hexo的Node.js编译快很多。但是于我而言最主要的原因还是我在Hugo的官方主题库里找到了心仪的主题BLowFish。\n最后，我习惯Typora编写文本，所以顺便配了阿里云oss做图床。再结合一些其他的需求，我目前的方案总结如下（PPT画的，不要在意拼写检查）：\n顺便一提，这样的技术栈图我还蛮喜欢的\n使用Hugo搭建博客 #\r基本信息配置 #\r基本信息配置主要在hugo.toml这个文件里。我的主题还有诸如params.toml、menus.zh-cn.toml等配置文件。所以这都根据具体主题而定。不过基本按照Hugo文档、主题提供的文档以及自己稍微理解一下就能顺利配置博客的基本信息了。我后面主要介绍一些难点和进阶的部分。\n内容目录结构 #\r可以参考Content organization | Hugo (gohugo.io)\n这部分是我比较诟病这类静态网页框架的一点，你的文章结构必须按照静态网页url里的结构来组织。比较正规的文件结构是这样的：\n","date":"28 September 2024","externalUrl":null,"permalink":"/posts/%E5%BB%BA%E8%AE%BE%E5%8D%9A%E5%AE%A2%E6%96%B0%E5%BE%81%E7%A8%8B/%E5%8D%9A%E5%AE%A2%E5%88%9D%E6%AD%A5%E6%90%AD%E5%BB%BA%E9%81%93%E8%B7%AF/","section":"","summary":"写博客这件事，从初三开始打竞赛就已经提上日程了。当时很草率地创建了一个洛谷博客，然后一篇文章都没有www。后来又存在各种阻力，例如高中的学业压力、只有周末接触电子设备的机会。但对博客与日俱增的需求的动\u0026hellip;","title":"博客初步搭建道路","type":"posts"},{"content":"","date":"28 September 2024","externalUrl":null,"permalink":"/categories/%E5%BB%BA%E8%AE%BE%E5%8D%9A%E5%AE%A2%E6%96%B0%E5%BE%81%E7%A8%8B/","section":"","summary":"","title":"建设博客新征程","type":"categories"},{"content":"\r起因 #\r由于手贱不小心删了Ubuntu自带的Python，服务器上的Ubuntu Server炸了。。。只能重新装一遍系统。但是我懒得做启动U盘了，所以索性直接在VMware里把系统给装起来。\n创建虚拟机并挂载物理磁盘 #\r只需要先下好你要装的系统的映象就行。然后把要装系统的硬盘装到你的电脑上。 还有很重要的一点，VMware一点要以管理员身份启动！不然Windows不让加物理磁盘！\n首先随便创建一个虚拟机，配置选自定义。\n在安装来源这里选稍后安装操作系统，或者直接选系统映象。\n安装位置随便选一个地方就行，反正等会就给他删掉了。我直接放桌面。\n内存、网络正常选就行。 I/O控制器选VMware推荐的LSI Logic，其他的应该也没差。\n虚拟磁盘类型选SATA或者NVMe，取决于你的物理磁盘是哪种类型的。我装在机械硬盘上，所以选SATA。\n然后重要的来了，使用哪个磁盘这里选择使用物理磁盘。\n这里如果没有用管理员身份启动VMware就会出问题：\n然后就是选哪个PhysicalDrive的问题。这个只需要右键此电脑-管理-磁盘管理里面看就行。\n可以看到磁盘0、磁盘1和磁盘2。这就对应着PhysicalDrive的编号。然后选择使用整个磁盘。 磁盘分区信息放桌面那里就行了。\n安装Ubuntu Server #\r创建好虚拟机之后，如果你之前创建虚拟机的时候没有选择映象的话，在虚拟机设置里面的CD/DVD中把映象选上去。然后启动时连接记得打开，不然\n然后在硬盘一项中点击高级，模式选择独立-永久\n然后就是正常的安装流程了。基本会一点英文就能顺利通过啦~\n","date":"27 September 2024","externalUrl":null,"permalink":"/posts/%E6%9C%89%E6%84%8F%E6%80%9D%E7%9A%84%E6%8A%98%E8%85%BE/%E4%BD%BF%E7%94%A8vmware%E7%BB%99%E7%89%A9%E7%90%86%E7%A1%AC%E7%9B%98%E8%A3%85%E7%B3%BB%E7%BB%9F/","section":"","summary":"由于手贱不小心删了Ubuntu自带的Python，服务器上的Ubuntu Server炸了。。。只能重新装一遍系统。但是我懒得做启动U盘了，所以索性直接在VMware里把系统给装起来。 只需要先下好你\u0026hellip;","title":"使用VMware给物理硬盘装系统","type":"posts"},{"content":"linux新增磁盘或增加磁盘容量后，如何进行扩容 - 知乎 (zhihu.com)\n有时间补一下我是怎么操作的。\n","date":"6 September 2024","externalUrl":null,"permalink":"/posts/%E6%9C%89%E6%84%8F%E6%80%9D%E7%9A%84%E6%8A%98%E8%85%BE/linux%E6%A0%B9%E7%9B%AE%E5%BD%95%E6%89%A9%E5%AE%B9/","section":"","summary":"有时间补一下我是怎么操作的。","title":"Linux根目录扩容","type":"posts"},{"content":"","date":"4 September 2024","externalUrl":null,"permalink":"/categories/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0/","section":"","summary":"","title":"操作系统设计与实现","type":"categories"},{"content":"\r开机-实模式到保护模式 #\r实模式到保护模式这个过程已经接触过很多次了。最早从软院OS实验的例行检查里背过相关内容，然后便不无意外地忘掉了。这次在OSDI课上又涉及到了这部分内容，趁此机会重温一下并写一个通俗易懂的笔记，以便以后查阅(可能并不会)。\n实模式 #\r摆龙门阵 #\rIntel为了兼容8086搞出来的玩意，在8、90年代很有用，但是对于现在来说还是太old-school了，所以新的UEFI启动方式已经渐渐取代了原来的BIOS，尽管我的装机U盘上的PE系统还保留了Legacy启动。\n这里还有个UEFI和BIOS的区别 - 知乎专栏，有时间再看。\n我想，实模式作为入门OS的很大原因在于UEFI比较复杂，大学计算机课程只能以BIOS为框架进行教学，所以绕不开这个实模式到保护模式的转换。并且这个转换的过程能体现操作系统内存虚拟化的很多芝士，比如段页式内存管理。所以这一部分内容的理解还是有助于成为操作系统领域大神的www。\n实模式小介绍 #\r摘自课程助教编写的实验文档\n在QEMU中，i386为了保持向后兼容性，一开机并不是我们熟悉的保护模式，而是实模式。\n实模式简单来说就是一个16位的CPU，和保护模式相比，最主要有三点区别：\n一是寄存器\n不一样，实模式里只会用我们熟悉的寄存器的低16位，所以名字就少了前缀“E”，具体地有：\n通用寄存器（16 位）：AX，BX，CX，DX，SP，BP，DI，SI 段寄存器（16 位）：CS，DS，SS，ES 状态和控制寄存器（16 位）： FLAGS，IP 二是寻址方式不一样，在实模式里，虽然有段寄存器，但没有保护模式里的段表，更没有页表，物理地址就是 (段寄存器\u0026laquo;4) + 偏移地址 。段寄存器16位，偏移地址也是16位，所以寻址空间就是2^20=1MiB。\n三是中断处理不一样，不过我们现在也不关心这个东西，有兴趣的话可以去搜索一下实模式的中断向量表，现在只需要大概知道中断都是由BIOS代办的就行了。\nBIOS执行过程以及两个模式 #\r启动的第一条指令地址是0xffff0。这个地址是BIOS ROM地址的最后，指令跳到ROM稍微靠前的地址[CS:IP] 0f000:E05Bh。这个地址开始执行BIOS POST。\n这里会立马发生很重要的一个转换，就是从实模式转成保护模式。\n原因是POST需要在保护下执行，否则实模式那点空间不够。\n自检完后通过INT 19h开始自举。\n自举就是依次把每个磁盘的0扇区加载到0x7c00然后看是不是MBR，即看扇区尾巴是不是0x55和0xaa，是的话自举滴任务就完成辣！\n其实还没有，自举谢幕前还要进行重要的一步，就是转换回实模式。\n原因是要向后提供兼容。不是i386之前的架构的请自觉转到保护模式。\n总结为如下图：\n实模式到保护模式 #\r这部分是写本文最主要的目的，所以单独拉一个标题来写。\n实模式到保护模式主要是两步：设置段表GDT，再将CR0寄存器最低位置1。\n现在先只涉及GDT，LDT不管。\n保护模式的寻址怎么实现 #\r保护模式比实模式牛的地方之一就是实现了段式内存管理。我们都知道段式内存管理本质就是个二维寻址。\n保护模式下的寻址方式如下：\n$$逻辑地址 = 段选择子_{16bits} \\implies 段基址_{32bits} + 段内偏移_{32bits}$$段选择子，可以根据字面意思理解记忆，就是记录选择了哪个段的东西。它存放在段寄存器中。\n所以怎么从段选择子拿到段基址呢？这就要靠**段表**了。\n段表细节见后面小标题，这里只需要知道通过段选择子能找到段表中正确的项，而这个项(有名字，叫段描述符)含有我们想要的很多信息，主要就是段基址。\n实验中提到了\u0026quot;扁平模式\u0026quot;，即将段基址全置0，这样偏移量就直接是逻辑地址了。\n这样就实现了保护模式的寻址。\n段表 #\r段表是个一位线性表。表项是前面说的段描述符，一个段描述符有64位，下面粗略说一下段描述符有哪些信息。\n段基址：最主要的信息之一。占32位。 段限长：段的长度，保证内存访问不会越界。也比较重要，占20位。 其他控制位。包括段限长粒度、特权位等。 详细来说，如下\nDESCRIPTORS USED FOR APPLICATIONS CODE AND DATA SEGMENTS\r31 23 15 7 0\r+-----------------+-+-+-+-+---------+-+-----+-+-----+-+-----------------+\r| | | | |A| | | | | | | |\r| BASE 31..24 |G|X|O|V| LIMIT |P| DPL |S| TYPE|A| BASE 23..16 | 4\r| | | | |L| 19..16 | | | | | | |\r|-----------------+-+-+-+-+---------+-+-----+-+-----+-+-----------------|\r| | |\r| SEGMENT BASE 15..0 | SEGMENT LIMIT 15..0 | 0\r| | |\r+-----------------------------------+-----------------------------------+\rA - ACCESSED\rAVL - AVAILABLE FOR USE BY SYSTEMS PROGRAMMERS\rDPL - DESCRIPTOR PRIVILEGE LEVEL\rG - GRANULARITY\rP - SEGMENT PRESENT 具体大致看一下就行了，毕竟真要用到也不会有人记得清的。\n另外，这个段表的访问也大有学问。段表的基址和长度放在一个叫GDTR的寄存器里。\nGDT REGISTER\r+--------------------------------+---------------+\r| GDT BASE | GDT LIMIT |\r+--------------------------------+---------------+\r47 15 0 段选择子 #\r以下内容直接copy于实验手册\n15 3 1 0\r+-------------------------+-+---+\r| |T| |\r| INDEX | |RPL|\r| |I| |\r+-------------------------+-+---+\rTI - TABLE INDICATOR, 0 = GDT, 1 = LDT\rRPL - REQUESTOR\u0026#39;S PRIVILEGE LEVEL TI位表示该段选择子为全局段（查GDT）还是局部段（查LDT），实验中只会用到前者，RPL表示该段选择子的特权等级，13位Index表示描述符表中的编号（下标）。\n结合虚拟地址、段选择符和段表的相关概念，在分段机制中，将虚拟地址转换成线性地址（此时即为物理地址）的过程可描述如下：\n根据段选择子中的TI位选择GDT或LDT（总是GDT）； 根据段选择子中的index部分到GDT中找到对应位置上的段描述符； 读取段描述符中的base部分，作为32位段基址（总是0），加上32位段内偏移量获取最终的物理地址。 总结 #\r这部分内容最重要的就是为什么需要保护模式、保护模式下的寻址以及段表和段选择子是什么东西。这部分搞懂了基本就没什么问题了。\n在OS设计与实现的实验里这部分比较简单，概念搞清楚几行代码就搞定了。\n","date":"4 September 2024","externalUrl":null,"permalink":"/posts/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0/%E5%AE%9E%E6%A8%A1%E5%BC%8F%E5%88%B0%E4%BF%9D%E6%8A%A4%E6%A8%A1%E5%BC%8F/","section":"","summary":"实模式到保护模式这个过程已经接触过很多次了。最早从软院OS实验的例行检查里背过相关内容，然后便不无意外地忘掉了。这次在OSDI课上又涉及到了这部分内容，趁此机会重温一下并写一个通俗易懂的笔记，以便以后\u0026hellip;","title":"实模式到保护模式","type":"posts"},{"content":"\r内网穿透折腾记录 #\r还是草稿，以后有时间写\n在宿舍里搞了一台ubuntu server折腾用。想在校园网的特殊环境下实现外网访问内网的需求，从而能随时使用个人博客与code server等服务。\n以下为我在大二开学诞生这个需求，直到大三开学才基本实现的一整年的折腾过程的记录。由于计算机网络方面的知识十分浅薄（日常吐槽计网），文章中可能会出现十分多不专业的内容，欢迎各位大佬勘误与科普。同时也给正在折腾的朋友们一些十分不严谨的参考。\nFirst try #\r使用第三方frp/ngrok方案。\n这个方案源自于和朋友联机minecraft的经历。Minecraft服务器架设在内网端口，但可以通过一些frp服务来暴露到一个域名上，从而通过这个域名就能访问到mc服务器。\n对于其他的内网服务，这个方案基本也是可行的。好了问题解决了，这篇文章可以结束了。\n并不能。这种方案太不优雅了。临时使用的话现成frp或ngrok很不错。\n但是，使用现成frp缺点很多无法忍受：\n极小的带宽。一般免费隧道带宽只有3M以内，付费也就10M封顶。如果是好几个人一起玩mc或者传个文件啥基本就爆了。 限流量。之前用的好几个frp的流量都有每日签到领取，这个太难绷了。 随机域名/定死的顶级域名。没法用自己的域名，这个接受程度因人而异。 安全问题。数据都要走服务商那里转发，如果服务商被hack了就相当于裸奔了，不安全。 隧道数限制、校园网拦截等等 frp用了一两天后我直接关隧道跑路了，还是寻求其他方案吧。\nSecond try: #\r这次的方案转向了一个更加普遍的方案，就是直接通过某种方法拿到本机的公网IP。\n这种方案对于家里宽带有公网IPv4的十分方便且自由。但现在运营商基本不给公网ip了，所以IPv4基本走不通。\n但是，号称每一粒沙子都能分到地址的IPv6似乎就宽松很多了。如果能拿到服务器的IPv6地址，再绑个ddns，似乎基本就能实现我们的需求。\n开干。但是经历了九九八十一难，最终还是没能成功。\n第一难是路由器。我的路由器型号是Redmi 4A，官方的固件虽说能拿到IPv6的IP，但是没法关闭防火墙放行IPv6的出站流量。所以我给路由器刷了一个openwrt。\n第二难是openwrt。由于之前没接触过刷机，所以在找刷机包和编译上花了很多时间。最后还是用了大佬做好的刷机包。还好这个过程有breed防砖，不然路由器已经死了一百遍了。\n第三难是校园网IPv6分配。openwrt中获取到IPv6地址了，但是校园网的v6地址是/128的，也就是说真的只分配了一个地址，没法组子网。这个地址直接分给路由器了，路由器下的内网设备如果要以IPv\n6向外提供服务，就只能通过NAT6。这个NAT6难搞得一比，主要原因是路由器存储空间太小了，没法安装直接配置NAT6的插件。\n最后在这一步放弃了，因为在一次测试中突然发现了校园网是个大内网，你的路由器能上行不代表校园网中层层墙能让你上行……\n还有一个大问题。IPv6的站点只能由支持IPv6的设备访问，而就目前IPv6的普及情况……估计半数以上的情况都访问不了。\nThird try #\r第二次尝试失败后，由于学业繁忙，折腾的进程陷入停滞……\n转机在软工II课上，我为课程项目的后端购买了一个阿里云ECS。使用ecs一段时间后，我突然想到，能不能将ecs的公网IP，用在我的内网服务上呢？\n答案是肯定的。这种利用云服务器实现内网穿透的方案就是代理。\n出问题辣 #\r通过公网服务器端口访问内网服务时，如果内网服务是像wordpress这种比较复杂的网页，就会发生一系列错误的重定向。\n以我的wordpress博客举例，访问websiteIP:port的链接后，wp会返回301重定向，这个重定向会转到一系列链接\nReference #\r如何用阿里云实现内网穿透？如何在外网访问家里内网设备？-阿里云开发者社区 (aliyun.com)\nffdfgdfg/nps - Docker Image | Docker Hub\n","date":"1 September 2024","externalUrl":null,"permalink":"/posts/%E6%9C%89%E6%84%8F%E6%80%9D%E7%9A%84%E6%8A%98%E8%85%BE/nps%E6%8A%98%E8%85%BE%E8%AE%B0%E5%BD%95/","section":"","summary":"在宿舍里搞了一台ubuntu server折腾用。想在校园网的特殊环境下实现外网访问内网的需求，从而能随时使用个人博客与code server等服务。 以下为我在大二开学诞生这个需求，直到大三开学才基\u0026hellip;","title":"NPS折腾记录","type":"posts"},{"content":"\r评价指标 #\r混淆矩阵、精度矩阵 #\r精度矩阵是二分类下的混淆矩阵\n精度矩阵下的名词 #\rTRUE/FALSE: 预测结果与实际相符/不符\nPOSITIVE/NEGATIVE: 预测为真(阳性)/假(阴性)\n算术指标 #\rAccuracy 精度\n预测正确的比例 Sensitivity 敏感率\n同查全率 Specificity 特异率\n阴性里预测正确的比例 Precision 查准率\n预测为阳性中真的阳了的比例 Recall 查全率\n所有阳性中预测出来的比例 统计学基本概念 #\r距离度量函数 #\r对于两个样本 $x_i,x_j\\in R^d$\n欧式距离 $d(x_i, x_j)= \\sqrt{(x_i-x_j)^T(x_i-x_j)}=||x_i-x_j||_2$ 曼哈顿距离 $d(x_i, x_j)=||x_i-x_j||_1$ 切比雪夫距离 $d(x_i, x_j)=||x_i-x_j||_\\infty$ 余弦距离 $d(x_i, x_j)=\\frac{x_i^Tx_j}{||x_i||\\ ||x_j||}$ 马式距离 $d(x_i, x_j)=\\sqrt{(x_i-x_j)^TM(x_i-x_j)}$ ","date":"16 August 2024","externalUrl":null,"permalink":"/posts/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/%E6%A6%82%E8%A6%81/","section":"","summary":"精度矩阵是二分类下的混淆矩阵 \u003ccode\u003eTRUE\u003c/code\u003e/\u003ccode\u003eFALSE\u003c/code\u003e: 预测结果与实际相符/不符 \u003ccode\u003ePOSITIVE\u003c/code\u003e/\u003ccode\u003eNEGATIVE\u003c/code\u003e: 预测为真(阳性)/假(阴性) 对于两个样本 $xjin R^d$","title":"概要","type":"posts"},{"content":"","date":"14 August 2024","externalUrl":null,"permalink":"/categories/%E9%9A%8F%E8%AE%B0/","section":"","summary":"","title":"随记","type":"categories"},{"content":"\rMock和@Test注解 #\r@Test注解一定要是import org.junit.Test！如果是org.junit.jupiter.api.Test会导致Mock的对象全部为null\n","date":"14 August 2024","externalUrl":null,"permalink":"/posts/%E9%9A%8F%E8%AE%B0/%E9%9A%8F%E8%AE%B0/","section":"","summary":"@Test注解一定要是\u003ccode\u003eimport org.junit.Test\u003c/code\u003e！如果是\u003ccode\u003eorg.junit.jupiter.api.Test\u003c/code\u003e会导致Mock的对象全部为\u003ccode\u003enull\u003c/code\u003e","title":"随记","type":"posts"},{"content":"","date":"23 June 2024","externalUrl":null,"permalink":"/categories/%E6%AF%9B%E6%A6%82/","section":"","summary":"","title":"毛概","type":"categories"},{"content":"\r毛概复习-甘季国 #\r导论 #\r马克思主义中国化时代化的内涵 #\r马克思主义中国化时代化，就是\n立足中国国情和时代特点，坚持把马克思主义基本原理同中国具体实际相结合、同中华优秀传统文化相结合，深入研究和解决中国不同历史时期的实际问题，真正搞懂面临的时代课题，不断吸收新的时代内容，科学回答时代提出的重大理论和实践课题，创造新的理论成果。 马克思主义中国化时代化理论成果及其关系 #\r成果 #\r在马克思主义中国化时代化的历史进程中，产生了毛泽东思想、邓小平理论、“三个代表”重要思想、科学发展观、习近平新时代中国特色社会主义思想\n关系 #\r马克思主义中国化时代化的理论成果是一脉相承又与时俱进的关系。\n一方面，毛泽东思想所蕴含的马克思主义的立场、观点和方法，为中国特色社会主义理论体系提供了基本遵循。\n另一方面，中国特色社会主义理论体系在新的历史条件下进一步丰富和发展了毛泽东思想。\n毛泽东思想和中国特色社会主义理论体系，都是马克思列宁主义在中国的运用和发展，都以独创性的理论成果丰富和发展了马克思主义的理论宝库。\n毛泽东思想、邓小平理论、“三个代表”重要思想、科学发展观、习近平新时代中国色社会主义思想同马克思列宁主义一起，都是党和国家必须长期坚持的指导思想，是全国各族人民团结奋斗的共同思想基础。\n第二章 新民主主义革命理论 #\r新民主主义革命的总路线 #\r新民主主义革命总路线：无产阶级领导的、人民大众的、反对帝国主义、封建主义和官僚资本主义的革命。\n反映了中国革命的基本规律，指明了中国革命的对象、动力、领导力量、性质和前途，是新民主主义革命的指导路线。\n新民主主义的基本纲领 #\r政治纲领：推翻帝国主义和封建主义的统治，建立一个无产阶级领导的、以工农联盟为基础的、各革命阶级联合专政的新民主主义的共和国。 经济纲领：没收封建地主阶级的土地归农民所有，没收官僚资产阶级的垄断资本归新民主主义的国家所有，保护民族工商业。 文化纲领：新民主主义文化，就是无产阶级领导的人民大众的反帝反封建的文化，即民族的科学的大众的文化。 新民主主义革命的道路 #\r农村包围城市、武装夺取政权的革命道路\n内容：\n土地革命是中国革命的基本内容； 武装斗争是中国革命的主要形式，是农村根据地建设和土地革命的强有力保证； 农村革命根据地是中国革命的战略阵地，是进行武装斗争和开展土地革命的依托 新民主主义革命的三大法宝 #\r统一战线 武装斗争 党的建设 关系：\n统一战线和武装斗争是中国革命的两个基本特点，是战胜敌人的两个基本武器。 统一战线是实行武装斗争的统一战线，武装斗争是统一战线的中心支柱 党的建设则是掌握统一战线和武装斗争这两个武器的基本保障。 新民主主义革命理论的意义 #\r新民主主义革命理论，揭示了近代中国革命发展的客观规律，解决了中国革命的一系列理论问题，科学地回答了中国革命向何处去的问题，以及中国革命的发展阶段问题，极大地丰富了马克思主义的理论宝库。 在新民主主义革命理论的指导下，党团结带领人民经过浴血奋战，完成了新民主主义革命，于1949年建立了中华人民共和国，实现了民族独立、人民解放。 中国新民主主义革命的伟大胜利，是20世纪继俄国十月革命以后改变世界面貌的伟大历史事件，也极大改变了世界政治格局，鼓舞了全世界被压迫民族和被压迫人民争取解放的斗争，极大地增强了他们反对帝国主义斗争的信心，增强了世界人民争取和平的力量。 第三章 社会主义改造理论 #\r新民主主义社会是一个过渡性的社会 #\r从中华人民共和国成立到社会主义改造基本完成，是我国从新民主主义到社会主义的过渡时期。这一时期，我国社会的性质是新民主主义社会。新民主主义社会不是一个独立的社会形态，而是由新民主主义向社会主义转变的过渡性社会形态。\n党在过渡时期的总路线及其依据 #\r从中华人民共和国成立，到社会主义改造基本完成，这是一个过渡时期。党在这个过渡时期的总路线和总任务，是要在一个相当长的时期内，逐步实现国家的社会主义工业化，并逐步实现国家对农业、对手工业和对资本主义工商业的社会主义改造。\n现实依据\n经过1949年到1952年三年的努力，我国已经有了相对强大和迅速发展的社会主义国营经济，为党提出向社会主义过渡的总路线提供了物质基础。\n土地改革完成后，为发展生产、抵御自然灾害，广大农民具有走互助合作道路的要求。\n新中国成立初期，党和国家在合理调整工商业的过程中，出现了加工订货、经销代销、统购包销、公私合营等一系列从低级到高级的国家资本主义形式。\n当时的国际形式有利于中国向社会主义过渡。\n社会主义基本制度的确立及其理论根据 #\r确立\n1956年底，我国对农业、手工业和资本主义工商业的社会主义改造基本完成，农业、手工业个体所有制基本上转变成为公有制。 随着社会主义改造的进行，我国的人民民主政治建设也在有步骤地向前推进。 伴随着社会经济制度和社会经济结构的根本变化，我国社会的阶级关系也发生了根本的变化。 理论\n一方面，中国可以在没有实现工业化的情况下进入社会主义，社会主义基本制度的确立正是为了推进中国的工业化、现代化建设; 另一方面，由于经济文化还比较落后，中国的社会主义还只能是初级阶段的社会主义。不经过社会生产力的极大发展,是不可能超越这个阶段的 确立社会主义基本制度的重大意义 #\r社会主义基本制度的确立，为当代中国一切发展进步奠定了制度基础。社会主义制度的建立极大地提高了工人阶级和广大劳动人民的积极性、创造性，极大地促进了我国社会生产力的发展 我国社会生产力的发展，初步显示了社会主义的优越性 实现中华民族伟大复兴，必须建立符合我国实际的先进社会制度 中国社会主义基本制度的确立，使占世界人口 1/5的东方大国进入了社会主义社会，这是世界社会主义发展史上又一个历史性的伟大胜利 社会主义基本制度的确立，是以毛泽东同志为主要代表的中国共产党人对一个脱胎于半殖民地半封建的东方大国如何进行社会主义革命问题的系统回答和正确解决，是马克思列宁主义关于社会主义革命理论在中国的正确运用和创造性发展的结果 第四章 社会主义建设道路初步探索的理论成果 #\r初步探索的重要理论成果 #\r调动一切积极因素为社会主义事业服务\n正确认识和处理社会主义社会矛盾的思想\n走中国工业化道路的思想\n初步探索的意义和经验教训 #\r意义\n巩固和发展了我国的社会主义制度 为开创中国特色社会主义提供了宝贵经验、理论准备、物质基础 丰富了科学社会主义的理论和实践 教训(怎么做)\n必须把马克思主义与中国实际相结合，探索符合中国特点的社会主义建设道路 必须正确认识社会主义社会的主要矛盾和根本任务，集中力量发展生产力 必须从实际出发进行社会主义建设，建设规模和速度要与国力相适应，不能急于求成 必须发展社会主义民主，健全社会主义法制 必须坚持党的民主集中制和集体领导制度，加强执政党建设 必须坚持对外开放，借鉴和吸收人类文明成果建设社会主义，不能关起门来搞建设 第六章 邓小平理论 #\r邓小平理论首要的基本的理论问题 #\r什么是社会主义，怎样建设社会主义\n强调解放和发展生产力在社会主义社会发展中的重要地位，纠正了过去关于发展生产力的一些错误观念，反映了中国社会主义整个历史阶段尤其是初级阶段特别需要注重生产力发展的迫切要求，并明确了社会主义基本制度建立后还要通过改革进一步解放生产力 强调“消灭剥削，消除两极分化，最终达到共同富裕”，从生产关系和发展目标角度认识和把握社会主义本质 邓小平理论的精髓 #\r解放思想、实事求是\n邓小平理论的主要内容 #\r社会主义初级阶段理论和党的基本路线 #\r第一，我国社会已经是社会主义社会。我们必须坚持而不能离开社会主义。第二，我国的社会主义社会还处在初级阶段。我们必须从这个实际出发，而不能超越这个阶段。 党的基本路线：领导和团结全国各族人民，以经济建设为中心，坚持四项基本原则，坚持改革开放(一个中心，两个基本点)，自力更生，艰苦创业，为把我国建设成为富强、民主、文明的社会主义现代化国家而奋斗 四项基本原则：坚持社会主义道路、坚持人民民主专政、坚持共产党的领导、坚持马列主义毛泽东思想 社会主义根本任务和发展战略理论 #\r社会主义的根本任务是发展生产力 三步走 的发展战略 到1990年，实现国民生产总值比1980年翻一番，解决人民的温饱问题 到20世纪末，使国民生产总值再增长一1倍，人民生活达到小康水平 到21世纪中叶，人均国民生产总值达到中等发达国家水平，人民生活比较富裕，基本实现现代化。 社会主义改革开放和社会主义市场经济理论 #\r改革是社会主义社会发展的直接动力 一是计划经济和市场经济不是划分社会制度的标志，计划经济不等于社会主义，市场经济也不等于资本主义； 二是计划和市场都是经济手段，对经济活动的调节各有优劣，社会主义实行市场经济是要把两者优势结合起来； 三是市场经济作为资源配置手段本身不具有制度属性，可以和不同的社会制度结合，从而表现出不同的性质。坚持社会主义制度与市场经济的结合，是社会主义市场经济的特色所在、优势所在 中国特色社会主义外交和国际战略 #\r邓小平理论的历史地位 #\r邓小平理论是马克思列宁主义基本原理同当代中国实际和时代特征相结合的产物，是对马克思列宁主义、毛泽东思想的继承和发展，是全党全国人民集体智慧的结晶。 是中国特色社会主义理论体系的开篇之作。邓小平理论第一次比较系统地初步回答了建设中国特色社会主义的一系列基本问题，包括社会主义初级阶段理论，党在社会主义初级阶段的基本路线等，形成了一个比较完备的科学体系。 是改革开放和社会主义现代化建设的科学指南。邓小平理论指导了改革开放的伟大实践。 第七章 “三个代表”重要思想 #\r回答了：建设一个怎么样的党、怎样建设党\n“三个代表”重要思想的核心观点 #\r始终代表中国先进生产力的发展要求 始终代表中国先进文化的前进方向 始终代表中国最广大人民的根本利益 “三个代表”重要思想的主要内容 #\r发展是党执政兴国的第一要务 建立社会主义市场经济体制 坚持和完善公有制为主体，多种所有制经济共同发展的社会主义基本经济制度 全面建设小康社会 建设社会主义政治文明 实施“引进来”和“走出去”相结合的对外开放战略 推进党的建设新的伟大工程 第八章 科学发展观 #\r科学发展观的科学内涵 #\r推动经济社会发展是科学发展观的第一要义 以人为本是科学发展观的核心立场 全面协调可持续是科学发展观的基本要求 统筹兼顾是科学发展观的根本方法 科学发展观的主要内容 #\r加快转变经济发展方式 发展社会主义民主政治 推进社会主义文化强国建设 构建社会主义和谐社会 推进生态文明建设 全面提高党的建设科学化水平 ","date":"23 June 2024","externalUrl":null,"permalink":"/posts/%E6%AF%9B%E6%A6%82/%E6%AF%9B%E6%A6%82/","section":"","summary":"马克思主义中国化时代化，就是 1. 立足中国国情和时代特点，坚持把马克思主义基本原理同中国具体实际相结合、同中华优秀传统文化相结合，深入研究和解决中国不同历史时期的实际问题，真正搞懂面临的时代课题，不\u0026hellip;","title":"毛概","type":"posts"},{"content":"\r信号量与PV操作习题 #\r读者写者问题 #\rv1-读者优先策略 #\rrmutex的理解\n可以理解为更新临界资源readcount的坑位，同一时间只允许一个reader蹲在那里更新readcount 理发师问题 #\r一个理发师、一把理发椅、等候区容量N\n理发师：等候区有顾客就理发，没顾客睡觉\n顾客：等候区不满就进等候区，在等候区如果理发师睡觉就叫醒；等候区满就不理发了\n重要思想 #\r协同信号量: waiting \u0026lt;-\u0026gt; customers\nwaiting变量和customers信号量是一对协同量，二者意义相同，数值也相同(除了customer可能为-1)。 所以要用mutex信号量去保证二者在有顾客的时候是同步变化的，这样去理解mutex就容易的多了 为什么？因为我们要判断if(waiting\u0026lt;CHAIRS)，假如没有waiting，我们就得判断if(customers\u0026lt;CHAIRS)，但是用户代码直接访问信号量的操作是不被允许的 ","date":"24 May 2024","externalUrl":null,"permalink":"/posts/se%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/ex6-%E4%BF%A1%E5%8F%B7%E9%87%8F%E4%B8%8Epv%E6%93%8D%E4%BD%9C%E4%B9%A0%E9%A2%98/","section":"","summary":"rmutex的理解 : waiting customers","title":"Ex6 信号量与PV操作习题","type":"posts"},{"content":"","date":"24 May 2024","externalUrl":null,"permalink":"/categories/se%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/","section":"","summary":"","title":"SE操作系统","type":"categories"},{"content":" 解释中断向量 中断向量是确定中断服务程序的位置。包含段基址和偏移量。\n解释中断类型码 把每个中断服务程序进行编号，一个号代表一个中断服务程序，就是中断类型码，是计算机用来查找中断向量用的。(0-255)\n解释中断向量表 一片专门用来存放所有的中断向量的内存空间。\n在内存单元的最低处，地址空间为 00000H-003FFH (0-1024B)\n中断类型码 * 4 = 中断向量的首地址\n中断向量表提供了中断类型码与中断处理代码段入口地址的映射。\n实模式下中断程序地址如何得到? 根据中断类型码 n, 从中断向量表 n*4，取得中断处理程序的地址，段地址存入 CS，偏移量存入 IP，使得 CPU 转入中断程序运行。\n保护模式下中断程序地址如何得到? 以 IDTR 中中断向量表的基址为起始地址 + 调用号 N*8 = 中断门描述符首地址，取出中断门的 8 个字节\n根据中断门的选择子和偏移量得到中断处理程序入口\n中断向量的地址如何得到? 中断类型码 * 4\n实模式下如何根据中断向量的地址得到中断程序地址? 低二字节为偏移量，高二字节为段地址\n解释中断描述符 中断描述符含有中断处理程序地址信息，还包括许多属性和类型位\n每个中断描述符占用连续的8个字节，中断描述符分为三类：任务门、中断门和自陷门，CPU对不同的门有不同的处理方式\n低1，2字节和高7，8字节存偏移量\n2，3字节是段选择符\n4，5字节是访问权限字节\n保护模式下中断描述符表如何得到? 通过IDTR读取IDT的基地址。\n保护模式下中断门如何得到? IDT基地址+中断类型码*8\n保护模式下如何根据中断门得到中断处理程序地址? 中断门中的段选择符-\u0026gt;段基址 + 偏移量\n中断的分类，举例不同类型的中断? 从中断源的角度： 内部异常中断：由硬件异常或故障引起的\n软中断：程序执行了中断指令引起的中断，由程序员通过 INT 或 INT3 指令触发，通常当做 trap 处理，实现系统调用\n外部中断 / IO 中断：外部设备请求引起的中断（又可分为可屏蔽中断（INTR 引脚）和不可屏蔽中断（NMI 引脚）：重启、电源故障、内存出错等影响整个系统工作的中断时不能被屏蔽的）\n以 CPU 为界： 中断：CPU 以外的事件引起的中断（IO 中断、时钟中断、控制台中断等）\n异常：CPU 内部事件或程序执行中的事件引起的过程（除数为 0，CPU 本身故障、请求系统服务指令）\n中断与异常的区别? 狭义中断：CPU 以外的事件引起的中断（IO 中断、时钟中断、控制台中断等）\n异常：CPU 内部事件或程序执行中的事件引起的过程（除数为 0，CPU 本身故障、请求系统服务指令）\n实模式和保护模式下的中断处理差别 最大区别在于寻找中断处理代码入口的方式\n实模式：中断类型码 * 4 (中断向量表)\n保护模式：IDTR-\u0026gt;IDT中的中断描述符-\u0026gt;段基址+偏移\n如何识别键盘组合键（如 Shift+a）是否还有其他解决方案? 按下一个按键时检测之前或者此时是否有组合键的Make Code 记录特殊按键的状态，按下一般按键时检测其状态以确定组合键 IDT 是什么，有什么作用? 中断描述符表\n可以通过中断号 * 8访问对应中断描述符，进而得到中断处理程序的地址等信息\nIDT 中有几种描述符? 三种\n中断门描述符\n陷阱门描述符\n任务门描述符\n异常的分类? Fault：可被更正的异常，一旦被更正，程序可以不失连续性继续执行，返回地址是产生 fault 的指令。\nTrap：在发生 trap 的指令执行之后立即被报告的异常，也允许程序不失连续性继续执行，返回地址为产生 trap 的指令之后的那条指令。\nAbort：不总是报告精确异常发生位置的异常，不允许程序继续执行，用来报告严重错误的。\n用户态和内核态的特权级分别是多少? 3, 0\n中断向量表中，每个中断有几个字节?里面的结构是什么? 4个字节。高二字节 = 段地址，低二字节 = 偏移量\n中断异常共同点（至少两点），不同点（至少三点） 共同点：\n都是程序执行过程中的强制性转移，转移到相应的处理程序\n都是软件或硬件发生了某种情形而通知处理器的行为。\n不同点：\n中断是 CPU 具备的功能，通常因为硬件而随机发生；异常时软件运行过程中的一种开发过程中没有考虑到的程序错误。\n中断是 CPU 暂停当前工作，有计划地去处理其他事情，其发生一般是可预知的，处理过程也是实现制定好的，处理中断时程序是正常运行的；异常是 CPU 遇到了无法响应的工作，而进入一种非正常状态，异常的出现表明程序有缺陷。\n中断是异步的，是来自指令流之外的；异常是同步的，是来自指令流内部的。\n中断或异常的返回点。良性如中断和 trap，处理程序完了后返回到原指令流的下一条指令；恶性如 fault 和 abort，对于可修复 fault，会重新执行该指令，对于不可修复 fault 或 abort，则不会再返回。\n中断是由与当前程序无关的中断信号触发的，CPU 对中断的响应是被动的，且与 CPU 模式无关。既可以发生在内核态也可以发生在用户态；异常是由 CPU 控制单元产生的，大部分异常发生在用户态。\n","date":"22 May 2024","externalUrl":null,"permalink":"/posts/se%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/lab3/","section":"","summary":"中断向量是确定中断服务程序的位置。包含段基址和偏移量。 把每个中断服务程序进行编号，一个号代表一个中断服务程序，就是中断类型码，是计算机用来查找中断向量用的。(0-255) 一片专门用来存放所有的中断\u0026hellip;","title":"Lab3","type":"posts"},{"content":"","date":"21 May 2024","externalUrl":null,"permalink":"/categories/%E8%BD%AF%E5%B7%A5ii%E5%A4%A7%E4%BD%9C%E4%B8%9A-%E8%93%9D%E9%B2%B8%E5%95%86%E5%9F%8E/","section":"","summary":"","title":"软工II大作业-蓝鲸商城","type":"categories"},{"content":"\r商品推荐算法初探 #\r分析 #\r项目情况 #\r蓝鲸网购商城，这个问题域下涉及的对象只有商品和用户。这两个对象和推荐算法相关的属性有如下：\n商品 名称 分类 价格 图片等复杂信息 用户 商品访问记录 访问次数 商品购买记录(订单) 订单价格 商品评分记录 评分 需求 #\r能应对相对大量用户和商品的系统 算法必须能在2核2g的服务器上正常运行 使用在线算法 约束 #\r开发时间紧张 用户量和商品量十分小 可能有方法会改善这个情况，比如自动化生成工具 用户行为数据有限 因为要人工操作。但是同上。 算法的选择 #\r基于用户的协同过滤-User CF #\r核心思想：人以群分，推荐和你最相似的用户喜欢的商品\n优点 #\r在线算法 实现简单 效率高 缺点 #\r十分依赖于其他用户和商品的交互数据。交互越多推荐效果越好。 基于交互，会同时涉及用户和商品两个模块 基于商品的协同过滤-Item CF #\r核心思想：物以类聚，推荐和你喜欢的商品最相似的商品，相似度基于交互\n优点 #\r没怎么细看，我姑且认为这个更加准确吧\n缺点 #\r算法要求先离线处理所有商品的相似度 效率较慢 基于交互，会同时涉及用户和商品两个模块 基于内容的推荐算法 #\r核心思想：物以类聚，推荐和你喜欢的商品最相似的商品，相似度基于商品属性\n优点 #\r自然。推荐商品最直接、朴素的想法就是推荐内容相似的物品啦。\n静态。基于商品稳定的属性。不用依赖于不稳定的用户与商品的交互。\n缺点 #\r实现上不如前两种算法那么规范，主观性比较大。 ","date":"21 May 2024","externalUrl":null,"permalink":"/posts/%E8%BD%AF%E5%B7%A5ii%E5%A4%A7%E4%BD%9C%E4%B8%9A-%E8%93%9D%E9%B2%B8%E5%95%86%E5%9F%8E/%E6%8E%A8%E8%8D%90%E7%AE%97%E6%B3%95%E5%88%9D%E6%8E%A2/","section":"","summary":"蓝鲸网购商城，这个问题域下涉及的对象只有和。这两个对象和推荐算法相关的属性有如下： 没怎么细看，我姑且认为这个更加准确吧","title":"推荐算法初探","type":"posts"},{"content":"\r第五章-文件管理 #\r5.1-文件系统概述 #\r引入文件的优点 #\r用户使用方便，按名存取 文件安全可靠 文件可备份 文件可共享 文件系统的功能 #\r面向用户 按名存取 共享和保护 操作和使用 OS要实现 文件目录的建立与维护 存储空间的分配和回收 数据安全 用户权限 5.2-文件的存储 #\r物理文件 #\r卷：介质的物理单位\n块：主存储器和辅助存储器进行信息交换的物理单位，也叫物理记录\n逻辑文件 #\r流式文件 #\r文件中的数据是一串没有结构的字符流，比如一串字符串组成的文件\n记录式文件 #\r若干逻辑记录信息所组成的记录流文件。逻辑记录是逻辑上的一坨信息的单位\n逻辑记录的成组与分解 #\r这个条目解决了从逻辑记录大小和物理记录大小的不匹配的问题\n优点 #\r节省存储空间 减少IO次数 特点 #\r提前读：因为一次读了多个逻辑记录\n推迟写：要缓冲区逻辑记录满了才写\n长记录 #\r变长记录 #\r跨块记录 #\r文件的物理结构 #\r这个条目解决了从逻辑记录存到物理记录的组织\n顺序文件 #\r逻辑记录——线性排列——\u0026gt;物理记录\n优点：顺序读取快\n缺点：无法动态分配、修改\n连接文件 #\r逻辑记录——链表——\u0026gt;物理记录\n优点：能动态增长与修改\n缺点：读取必须从头顺序读\n直接文件 #\r逻辑记录——Hash——\u0026gt;物理记录\n优点：动态、即时读取\n缺点：哈希冲突\n⭐索引文件 #\r逻辑记录——索引表——\u0026gt;物理记录\n优点：动态、“半“即时读取\n缺点：建表空间开销和查表时间开销\n通常是多级索引。多级索引的项指向了一个目录块\n5.3-文件的目录结构 #\r文件目录是实现按名存取的重要结构\n如其名，就是个目录。既可能是像书那样的线性目录，也可能是树形目录\n目录结构的分类 #\r一级目录结构 #\r一张线性表当目录\n评价：所有用户共享、文件还不能重名，所以这样很混乱\n二级目录结构 #\r第一级目录按用户分，第二级就是对应用户的文件目录\n评价：用户的问题解决了，但是对单个用户来说还是很难用\n树形目录结构 #\r层次性的目录结构，既可以是森林(Windows)，也可以是一颗树(UNIX)\n评价：层次关系能反映现实的关系、文件可以重名、每个子树都可以设置权限等机制\n活动文件表 #\r解决查目录的访辅存问题，给每一个进程建立一个活动文件表\n用文件之前，通过OS提供的“打开文件”操作，文件的有关目录被放到主存的活动文件表\n不用文件了就关掉，并且把修改过的内容写回辅存\n⭐inode #\r直观理解：从文件名到inode号的映射\ninode区 #\r在磁盘上，保存了诸多inode项\ninode项 #\r保存了inode号、inode引用数、inode所在设备等信息\n更重要的，保存了文件的索引表\n活动/动态inode #\r类比活动文件表，把活跃的inode从磁盘里复制到主存\n静态inode就是磁盘里inode区存的一堆inode项\n5.4-文件的安全和保护 #\r文件共享 #\r不同用户共同使用\n好处 #\r减少用户大量重复性劳动 免除系统复制文件的工作 节省文件占用的存储空间 减少程序设计输入输出文件的次数 文件保护 #\r防止文件损坏\n文件副本 #\r动态多副本\n多个介质上维持同一内容的文件(有点类似RAID0？) 会增加设备和系统开销，适合小而重要的文件的保护 文件转储\n定时保存文件副本 存取控制矩阵 #\r为每个用户设置访问每个文件对象的存取属性\n系统的全部用户对全部文件的存取属性就组成的一个二维矩阵，称为存取控制矩阵\n二维矩阵是稀疏矩阵，故将其简化为存取控制表，每行包括：用户、文件、存取属性\n文件属性 #\r先对用户分类，再对每一类用户规定文件属性\n用户分类：属主、合作者、其他\n文件属性：读、写、执行等\n文件保密 #\r防止某些用户窃取\n措施 #\r隐蔽文件目录 设置口令 使用密码 ","date":"16 May 2024","externalUrl":null,"permalink":"/posts/se%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/c5-%E6%96%87%E4%BB%B6%E7%AE%A1%E7%90%86/","section":"","summary":"卷：介质的物理单位 块：主存储器和辅助存储器进行信息交换的物理单位，也叫 文件中的数据是一串没有结构的字符流，比如一串字符串组成的文件 若干逻辑记录信息所组成的记录流文件。是逻辑上的一坨信息的单位 这\u0026hellip;","title":"C5 文件管理","type":"posts"},{"content":"","date":"11 May 2024","externalUrl":null,"permalink":"/categories/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86/","section":"","summary":"","title":"编译原理","type":"categories"},{"content":"\r编译原理知识点索引 #\r声明 #\r本文档只包含一些关键的知识点\n词法分析-正则表达式和自动机理论 #\r对应Lecture-3\n定义 #\r字母表 #\r$$字母表\\Sigma是一个有限的符号集合$$ 串 #\r$$字母表\\Sigma上的串s是由\\Sigma中符号构成的一个有穷序列$$$空串:\\epsilon$\n语言 #\r$语言是给定字母表\\Sigma上一个任意的可数的串的集合$\n正则表达式 #\r$给定字母表\\Sigma, \\Sigma上的正则表达式由且仅由以下规则定义:$\n(1) $\\epsilon是正则表达式$\n(2) $\\forall a\\in\\Sigma, a是正则表达式$\n(3) $如果r是正则表达式, 则(r)是正则表达式$\n(4) $如果r, s都是正则表达式, 则 r|s, rs, r^*也是正则表达式$\nNFA(Nondeterministic Finite Automaton) #\r$非确定性有穷自动机\\mathcal{A}是一个五元组\\mathcal{A}=(\\Sigma,S,s_0,\\delta,F)$\n见课件-3-26\nDFA(Deterministic Finite Automaton) #\r见课件-3-34\nRE, NFA, DFA等价转化 #\rRE-\u0026gt;NFA - Thompson构造法 #\r见课件-3-40:45\nNFA-\u0026gt;DFA - 子集构造法 #\r原理见课件-3-54\n为什么叫子集构造法:\n构造出的DFA的每一个状态$s_D\\in S_D$, 对应原来NFA的状态的一个子集$s_D\\subseteq 2^{S_N}$ 总结:\n对NFA的每个状态求其对应**$\\epsilon$闭包**, 即只通过$\\epsilon$转移可达的状态集合. 这个集合中的状态可以被视作DFA中的一个状态 新的DFA中的状态的转移函数是其对应NFA状态集合中每个状态的转移函数构成的. 这一条课件讲的更清楚 DFA-\u0026gt;DFA - DFA最小化 #\rIR-LLVM #\rLLVM #\rLow Level Virtual Machine\n但是现在已经不止上面的含义了\nThree Address Code (TAC) #\r三地址指令\n一条指令所含操作数和地址的数量不超过3\nStatic Single Assignment (SSA) #\r静态单赋值\n静态:\n单赋值: 每个寄存器只在赋值号左边出现一次\nControl Flow Graph (CFG) #\r控制流图\n节点: 基本块(跳转与分支只能在基本块退出点执行, 跳转到另一个基本块的进入点)\n边: 跳转关系\n$\\phi$指令(phi) #\r根据控制流的来源决定返回值\n%3 = phi i32 [1, %1], [2, %2]\r// 如果从%1控制流来, 就给%3赋值1, 否则赋值2 ","date":"11 May 2024","externalUrl":null,"permalink":"/posts/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86/%E8%AF%BE%E5%A0%82%E7%9F%A5%E8%AF%86%E7%82%B9%E7%B4%A2%E5%BC%95/","section":"","summary":"本文档只包含一些关键的知识点 对应Lecture-3 为什么叫子集构造法: 总结: 根据控制流的来源决定返回值 ``` %3 = phi i32 [1, %1], [2, %2] // 如果从%1控制\u0026hellip;","title":"课堂知识点索引","type":"posts"},{"content":"\r使用Jenkins部署Maven项目到Docker #\rJenkins：能够自动配置、自动部署项目。通过Webhook可以实现项目一旦被Push就会自动重新配置项目并且部署，以实现更新\n1 准备步骤 #\r1.1 安装Docker #\r这步比较简单，网上教程也很多，故省略\n1.2 拉取jenkins镜像 #\r执行拉取镜像的命令\ndocker pull jenkins/jenkins:lts 查看当前的镜像，可以发现jenkins已经在列表里了\ndocker images REPOSITORY TAG IMAGE ID CREATED SIZE\rbluewhale-backend master 044e4cb8919f 16 hours ago 318MB\rmysql latest f3df03e3cfc9 8 days ago 585MB\rjenkins/jenkins lts 4e586344183a 3 weeks ago 469MB\ropenjdk 8-jre 0c14a0e20aa3 21 months ago 274MB 1.3 创建容器 #\r使用run命令从镜像创建容器\n镜像和容器的关系就像类和对象的关系\ndocker run -d --restart=always -uroot \\ --name jenkins \\ -p 8080:8080 \\ -v /home/jenkins:/var/jenkins_home \\ -v /var/run/docker.sock:/var/run/docker.sock \\ -v /usr/bin/docker:/usr/bin/docker \\ -v ~/.ssh/:/root/.ssh \\ jenkins/jenkins:lts 参数说明\n-d：让容器运行在后台，不占用当前的终端 --restart=always：让docker重启后自动启动这个容器 -uroot：容器以root身份创建 --name：指定容器名称，否则docker会随机生成美丽的名字 -p：将容器的端口映射到宿主机的端口。冒号前是宿主机的，后者是容器里的 -v：将宿主机的目录挂载到容器里，能让容器访问宿主机的目录。冒号前宿主机，后容器。 第一个挂载将宿主机的路径挂载到jenkins的工作目录，能让jenkins的工作目录持久化到宿主机，这样容器被销毁了也不会让jenkins的配置和数据被销毁 第二个和第三个挂载是让容器内部能使用宿主机的docker命令，以便jenkins在宿主机创建maven项目的容器 第四个挂载是把ssh的密钥挂载上，这样jenkins就可以用ssh从仓库拉取代码了。当然也可以在容器里面重新生成密钥对。 创建容器后查看当前正在运行的容器\ndocker ps CONTAINER ID IMAGE COMMAND CREATED STATUS PORTS NAMES 9ed58b36b0c4 jenkins/jenkins:lts \u0026#34;/usr/bin/tini -- /u…\u0026#34; About a minute ago Up About a minute 0.0.0.0:8080-\u0026gt;8080/tcp, :::8080-\u0026gt;8080/tcp, 50000/tcp jenkins 排版很烂是因为这个表太长了，不过只要有jenkins就行\n另外，使用-a选项可以查看所有状态的容器，包括已经退出和挂起的\n补充：容器的生命周期(摘自CSDNdocker容器的生命周期-CSDN博客)\n2 配置Jenkins #\r2.1 初始化Jenkins #\r2.1.1 管理员初始密码 #\r在浏览器访问8080端口进入Jenkins工作台\n根据提示输入管理员密码\n这里的路径是容器内的路径，所以要进入容器的命令行\ndocker exec -it jenkins bash 我尝试过从宿主机挂载的目录访问，但是权限会有问题，懒得解决了\n2.1.2 安装插件 #\r安装推荐的插件就行。\n但是我的ECS内存太少了，所以我都是用什么插件装什么\n2.1.3 创建管理员账户 #\r可以根据提示创建账户。如果不需要的话直接使用admin账号继续即可\n2.1.4 配置完成 #\r一路点到配置完成，就进入Jenkins的Dashboard了\n2.2 对Jenkins进行全局配置 #\r2.2.1 Dashboard-\u0026gt;Manage Jenkins-\u0026gt;Plugins #\r安装Maven集成插件，以便项目的构建 2.2.2 Dashboard-\u0026gt;Manage Jenkins-\u0026gt;Tools #\r安装JDK Jenkins好像自带一个JDK。但是如果想用自己的版本的话就要在JDK installations里面配置自己的JDK 安装Maven Maven可以自动安装，选择Install automatically就可以了 2.2.3 Dashboard-\u0026gt;Manage Jenkins-\u0026gt;Credentials #\r一路点开System-\u0026gt;Global credentials\n根据自己的验证方式配置就行了。\n我的是ssh密钥对，所以把id_rsa的内容全部(包括-----BEGIN OPENSSH PRIVATE KEY-----)复制进去\n记得把公钥复制到仓库的凭据设置里面\n3 部署Maven项目 #\r","date":"10 May 2024","externalUrl":null,"permalink":"/posts/%E8%BD%AF%E5%B7%A5ii%E5%A4%A7%E4%BD%9C%E4%B8%9A-%E8%93%9D%E9%B2%B8%E5%95%86%E5%9F%8E/jenkins%E9%83%A8%E7%BD%B2maven%E9%A1%B9%E7%9B%AE%E5%88%B0docker/","section":"","summary":"这步比较简单，网上教程也很多，故省略 执行拉取镜像的命令 \u003ccode\u003ebash docker pull jenkins/jenkins:lts \u003c/code\u003e 查看当前的镜像，可以发现jenkins已经在列表里了 \u0026hellip;","title":"Jenkins部署Maven项目到Docker","type":"posts"},{"content":"\r随记 #\rPumping Theorem的理解 #\r一个足够长的，能被正则表达式$r$接受的字符串，一定能分成$xyz$三个部分。因为$r$对应DFA的状态数$p$是有限的，而串的长度大于$p$时，一定有一个状态被经历了两次及以上\n其中$y$对应$r$的DFA中起始状态和结束状态是同一个状态\n由于是同一个状态，我就可以接受任意多个$y$，所以$xy^iz\\in L$肯定成立\n扩展：上下文无关法的Pumping Theorem，具体可见课件里面\n","date":"9 May 2024","externalUrl":null,"permalink":"/posts/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86/%E9%9A%8F%E8%AE%B0/","section":"","summary":"","title":"随记","type":"posts"},{"content":"\r待解决问题 #\rLexer #\rDFA最小化为什么是正确的\nDFA最小化的结果唯一吗\n有关自动机的书：《计算理论导引》、J.E.H R.M J.D.U《Automata Theory, Languages, and Computation 第三版》\n","date":"8 May 2024","externalUrl":null,"permalink":"/posts/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86/%E9%97%AE%E9%A2%98%E6%94%B6%E9%9B%86/","section":"","summary":"","title":"问题收集","type":"posts"},{"content":"\rJPA使用Specification动态查询 #\r解决动态多条件查询的问题。我们可能会设置许多查询条件，但实际查询时只会用到其中的某一些条件，动态查询能保证只查询这一部分条件。 实现 #\rRepository接口继承JpaSpecificationExecuter\u0026lt;T\u0026gt; public interface ItemRepository extends JpaRepository\u0026lt;Item,Integer\u0026gt;, JpaSpecificationExecutor\u0026lt;Item\u0026gt;{} 新建处理Specification的类，便于构造筛选条件 public class itemSpecification { public static Specification\u0026lt;Item\u0026gt; whereItem(Map\u0026lt;String, Object\u0026gt; params) { // 通过匿名内部类实现Specification接口 // 摘自 https://blog.csdn.net/weixin_46005530/article/details/132626158 return (Root\u0026lt;Item\u0026gt; root, CriteriaQuery\u0026lt;?\u0026gt; query, CriteriaBuilder cb) -\u0026gt; { List\u0026lt;Predicate\u0026gt; predicates = new ArrayList\u0026lt;\u0026gt;(); // 处理name参数 String name = (String) params.get(\u0026#34;name\u0026#34;); if (name != null) { // 模糊查询的实现: cb.like predicates.add(cb.like(root.get(\u0026#34;name\u0026#34;), \u0026#34;%\u0026#34; + name + \u0026#34;%\u0026#34;)); } ... // 处理category参数 String catName = (String) params.get(\u0026#34;category\u0026#34;); CategoryEnum category = CategoryEnum.valueOf(catName); if(catName != null){ predicates.add(cb.equal(root.get(\u0026#34;category\u0026#34;), category)); } // 返回封装好的查询条件 return query.where( predicates.toArray(new Predicate[predicates.size()]) ).getRestriction(); } } } 在ServiceImpl层直接findAll @Override public List\u0026lt;Item\u0026gt; getItemByConditions(Map\u0026lt;String, Object\u0026gt; params){ return itemRepository.findAll(itemSpecification.whereItem(params)); } 细节 #\r用Map\u0026lt;String, Object\u0026gt;存不确定的筛选条件，模拟了一个不确定格式的JSON 在Controller层可以用@RequestBody传也可以用@RequestParams传 @RequestBody Map\u0026lt;String, Object\u0026gt; map 从Enum名字(String)到Enum类(和Integer等价)的转换，用xxxEnum.valueOf(str) String catName = (String) params.get(\u0026#34;category\u0026#34;); CategoryEnum category = CategoryEnum.valueOf(catName); @data注解 #\r@data注解可以自动生成无参构造函数、Getter、Setter和toString等方法 可以用于VO和PO(DAO)的注解，替代@Getter、@Setter、@NoArgsConstructor一系列注解 Docker上部署Mysql Server的持久化 #\rdocker run -p 3306:3306 --name mysql \\ -v /home/docker/mysql/log:/var/log/mysql \\ -v /home/docker/mysql/data:/var/lib/mysql \\ -v /home/docker/mysql/conf:/etc/mysql/conf.d \\ -e MYSQL_ROOT_PASSWORD=root \\ -d mysql JavaDoc #\r项目可以直接自动生成文档\n任务栏Tools-\u0026gt;Generate JavaDoc\n使用@Documented注解可以使这个类出现在文档中\n","date":"8 May 2024","externalUrl":null,"permalink":"/posts/%E8%BD%AF%E5%B7%A5ii%E5%A4%A7%E4%BD%9C%E4%B8%9A-%E8%93%9D%E9%B2%B8%E5%95%86%E5%9F%8E/%E7%9F%A5%E8%AF%86%E7%82%B9%E9%9A%8F%E8%AE%B0/","section":"","summary":"\u003ccode\u003ejava public interface ItemRepository extends JpaRepository, JpaSpecificationExecutor{} \u003c/code\u003e ```jav\u0026hellip;","title":"知识点随记","type":"posts"},{"content":"\r第四章-设备管理 #\r4.1-设备管理概述 #\r⭐设备管理的目标 #\r解决设备和CPU速度的不匹配，使两者充分并行工作 屏蔽设备的具体操作细节，配置驱动程序，提供统一接口 设备控制器 #\rCPU和物理设备之间的接口\n组成\n⭐IO控制方式 #\r轮询 #\rCPU向控制器发送I/O命令，轮询I/O结果。 若设备未就绪，则重复，直至设备就绪。 设备就绪，CPU执行内存交换 中断 #\rCPU向控制器发出I/O命令，然后干其他事情 如果进程支持异步IO，就不用换进程 否则进程挂起，换进程 控制器在设备就绪后向CPU发出中断 CPU响应中断，进行内存交换 DMA #\rCPU向DMA模块发出I/O命令\n处理器干其他事，DMA负责等设备就绪和传送数据\nDMA数据传完之后中断CPU\nDMA一般用周期窃取的方式访问内存。因为CPU大部分情况下用Cache，这时空闲的主存就能被DMA高效利用\nI/O通道 #\r没看懂是啥 总线 #\r解决I/O速度不匹配的问题 不同总线结构的本质是让速率相近的设备在一条总线上 单总线 #\r三级总线 #\r南北桥 #\r4.2-I/O软件的实现 #\r设计目标 #\r效率：改善设备效率，尤其是磁盘\n通用：用统一标准来管理所有设备\n⭐I/O软件的层次结构 #\r从低到高为\nI/O中断处理程序 I/O设备驱动程序 独立于设备的I/O软件 用户空间的I/O软件 I/O中断处理程序 #\r位于OS底层，和设备联系紧密\n数据传输结束后产生I/O中断，CPU响应请求并转入中断处理程序\n功能：检查设备状态寄存器，根据状态进行相关操作\n报错 正常结束，唤醒请求这个I/O的进程 其他 I/O设备驱动程序 #\r初始化设备\n逻辑I/O请求转化为物理I/O操作\n监督设备正确执行，缓冲区纠错\n独立于设备的I/O软件 #\r执行适用于所有设备的常用I/O功能\n设备命名：通过路径名寻址设备 设备保护：用户是否有权访问设备 提供与设备无关的数据单位：字符/块 缓冲技术：调整CPU与I/O速度不匹配 分配和状态跟踪：分配设备 错误处理/报告：驱动无法处理的错误 用户空间的I/O软件 #\r库函数 虚拟设备软件，如Spooling 缓冲技术 #\r目的 #\r速度不匹配 协调逻辑记录大小和物理记录大小的不匹配 提高并行 减少I/O对CPU的中断次数 放宽中断响应时间 缓冲区 #\r放在主存中\n缓冲技术类型 #\r单缓冲 双缓冲 循环缓冲 4.3-设备分配-独占型外围设备 #\r独占型外围设备：一次只能由一个进程独占使用\n⭐分配方式 #\r静态分配：进程运行前申请 动态分配：进程随用随申请 分配设备的数据结构 #\r设备类表：存不同类设备的信息 设备表：存一类设备中不同物理设备的信息 4.5-虚拟设备-SPOOLing系统 #\rSPOOLing系统 #\rSPOOLing-外部设备联机并行操作-假脱机技术\n处在用户空间的I/O软件层\n核心思想：用高速的磁盘设备来模拟慢速的字符设备，缩短进程在内存中的驻留时间\n实现 #\r预输入程序：输入设备通过预输入程序把数据输到输入井就可以干其他事情了\n缓输出程序：输出全都计算好了，输出设备就通过缓输出程序慢慢把这一堆数据输完\n井交换程序：控制作业进程和井的数据交换\n补充-磁盘调度 #\rFIFO-先进先出 #\r按顺序处理请求\nSSTF-最短服务时间优先 #\r每次找距离当前磁头最近的任务\n会饥饿 SCAN-扫描 #\r一次只沿一个方向扫\n磁头移动到最外或最内磁道才掉头\n⭐LOOK-电梯调度 #\r一次只沿一个方向扫\n磁头移动到最外或最内任务才掉头\nCSCAN-循环扫描 #\r只会沿一个方向扫\n磁头到磁道末端后，返回另一端末端开始扫\n","date":"7 May 2024","externalUrl":null,"permalink":"/posts/se%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/c4-%E8%AE%BE%E5%A4%87%E7%AE%A1%E7%90%86/","section":"","summary":"\u003col\u003e\n\u003cli\u003e解决设备和CPU的不匹配，使两者充分工作 2. 设备的具体操作细节，配置驱动程序，提供 ：改善设备效率，尤其是磁盘 ：用统一标准来管理所有设备 从低到高为 位于OS底层，和设备联系紧密 数据传输\u0026hellip;\u003c/li\u003e\n\u003c/ol\u003e\n","title":"C4 设备管理","type":"posts"},{"content":"\r第三章-存储管理 #\r3.1-存储管理基础 #\r有哪些地址 #\r逻辑地址 #\r又叫相对地址。是用户编程所使用的地址空间。 物理地址 #\r处理器执行指令时所使用的地址空间 虚拟地址 #\r辅存的地址空间 为啥要存储管理 #\r转换地址 OS有两种转换地址的模式 静态重定位：程序装入内存时转换地址(由装入程序支持) 动态重定位：解析命令才转换地址(现在都用这个，考虑效率的话必须由硬件支持) 分配和去配主存空间 管理进程对主存的共享 保护进程，避免越界访问 扩充主存空间 把磁盘作为主存的扩充 对换技术：调出一部分进程 虚拟技术：调入进程的一部分 存储管理的模式 #\r单连续存储管理：1D逻辑地址 占用 一个 主存固定或可变分区 段式存储管理：2D逻辑地址 占用 多个 主存可变分区 页式存储管理：1D逻辑地址 占用 多个 页框 段页式存储管理：2D逻辑地址 占用 多个 页框 虚拟存储器 #\r基本思想 #\r为了让程序员不必考虑主存容量的限制，夸夸用地址，就把辅存的一部分当成主存，随用随调入 主存不够了，就把部分数据调出到辅存上去 3.2-单连续分区存储管理 #\r每个进程占用一个物理上完全连续的存储空间 主存：系统区+用户区 栅栏寄存器存两个区的分界，在访存时提供保护 一般采用静态重定位 内存分配 #\r固定分区存储 #\r主存按递增大小的块来分区，加载任务的时候大小合适就丢进去。\ne.g.\n0 4k 12k 28k 44k 92k \u0026hellip; OS区(4k) 分区1(8k) 分区2(16k) 分区3(16k) 分区4(24k) 分区5(24k) \u0026hellip; 可变分区存储 #\r按实际分配需求来确定内存分区\n存储用已分配区表和未分配区表记录。包含：分区基址、分区长度、分区标志(未分配还是任务1还是任务2还是\u0026hellip;)\n分配算法\n最先适应分配算法 First fit 从头找第一个大小够的分区 最容易产生碎片 邻近适应分配算法 Next fit 从上一次的空闲分区开始找，第一个大小够的分区 最优适应分配算法 Best fit 找大小最接近的分区 最坏适应分配算法 Worst fit 找最大的分区 移动技术\n把已分配的分区移到一堆，碎片就能变成一个新的大空间 需要动态重定向支持(不知道为什么qwq) 3.3-页式存储管理 #\r","date":"25 April 2024","externalUrl":null,"permalink":"/posts/se%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/c3-%E5%AD%98%E5%82%A8%E7%AE%A1%E7%90%86/","section":"","summary":"| 0 | 4k | 12k | 28k | 44k | 92k | \u0026hellip; | | \u0026mdash;\u0026mdash;- | OS区(4k) | 分区1(8k) | 分区2(16k) | 分区3(16k) | 分区4(2\u0026hellip;","title":"C3 存储管理","type":"posts"},{"content":"\r第三章-关系数据库标准语言SQL #\r数据定义 #\r创建模式 #\rCREATE SCHEMA \u0026lt;模式名\u0026gt; AUTHORIZATION \u0026lt;用户名\u0026gt;\n命令后可接受\nCREATE TABLE CREATE VIEW GRANT 执行创建模式语句必须有DBA权限\n删除模式 #\rDROP SCHEMA \u0026lt;模式名\u0026gt; \u0026lt;CASCADE|RESTRICT\u0026gt;\nCASCADE 级联：删除模式同时删除模式内所有数据库对象 RESTRICT 限制：只在模式下无任何下属对象才删除，否则拒绝执行 创建基本表 #\rCREATE TABLE \u0026lt;表名\u0026gt; (\u0026lt;列名\u0026gt; \u0026lt;数据类型\u0026gt; [\u0026lt;列级完整性约束条件\u0026gt;] [,同上] [,\u0026lt;表级完整性约束条件\u0026gt;]) e.g. CREATE TABLE Course (Cno CHAR(4) PRIMARY KEY, Cname CHAR(40) UNIQUE, Cpno CHAR(4), FOREIGN KEY(Cpno) REFERENCES Course(Cno) ); 修改基本表 #\rALTER TABLE \u0026lt;表名\u0026gt; [ADD[COLUMN] \u0026lt;列名\u0026gt; \u0026lt;数据类型\u0026gt; [完整性约束]] [ADD \u0026lt;表级完整性约束\u0026gt;] [DROP [COLUMN] \u0026lt;列名\u0026gt; [CASCADE|RESTRICT]] [DROP CONSTRAINT\u0026lt;完整性约束名\u0026gt;[CASCADE|RESTRICT]] [ALTER COLUMN \u0026lt;列名\u0026gt;\u0026lt;数据类型\u0026gt;]; 删除基本表 #\rDROP TABLE \u0026lt;表名\u0026gt; [CASCADE|RESTRICT]\n建立索引 #\rDBMS一般会自动建立PRIMARY KEY和UNIQUE列上的索引 CREATE [UNIQUE] [CLUSTER] INDEX\u0026lt;索引名\u0026gt; ON \u0026lt;表名\u0026gt; (\u0026lt;列名\u0026gt;[\u0026lt;次序\u0026gt;],[同前]···) e.g. CREATE UNIQUE INDEX SCno ON SC(Sno ASC, Cno DESC); ASC-升序\tDESC-降序\n有关聚簇索引CLUSTER\n在最经常查询的列上建立CLUSTER可以提高查询效率 一个基本表只能建立一个聚簇索引 经常更新的列不宜建立聚簇索引 数据查询 #\rSELECT [ALL|DISTINCT] \u0026lt;目标列表达式\u0026gt; [,\u0026lt;目标列表达式\u0026gt;]··· FROM \u0026lt;表|视图\u0026gt; [,\u0026lt;表|视图\u0026gt;]··· [WHERE\u0026lt;条件表达式\u0026gt;] [GROUP BY\u0026lt;列名\u0026gt;[HAVING\u0026lt;条件表达式\u0026gt;]] [ORDER BY\u0026lt;列名\u0026gt;[ASC|DESC]]; DISTINCT-消除取值重复的行\tALL-缺省\n目标列表达式 包括\n算数表达式2024-Sage\n字符串常量'Year of Birth'\n函数LOWER(Sdept)\n列别名BIRTH 2024-Sage\nWHERE查询满足条件的元组\n查询条件 谓词 比较 =,\u0026gt;,\u0026lt;,\u0026gt;=,\u0026lt;=,!=,\u0026lt;\u0026gt;,!\u0026gt;,!\u0026lt; 确定范围 BETWEEN value1 AND value2 确定集合 IN (element1, element2, \u0026hellip;) 字符匹配 LIKE \u0026lsquo;pattern\u0026rsquo; ESCAPE \u0026lsquo;转义符\u0026rsquo; 空值 IS NULL 多重条件 AND, OR, NOT ORDER BY中，空值默认为最大值\n聚集函数\nCOUNT SUM AVG MAX MIN 聚集函数 ([DISTINCT|ALL] \u0026lt;列名\u0026gt;) COUNT ([DISTINCT|ALL] *) GROUP BY作用\n细化聚聚函数。分组后，聚集函数将分别作用于每个组 WHERE与HAVING\nWHERE作用于基本表或视图，从中选择满足表达式的元组。HAVING作用于组，从中选择满足条件的组。 WHERE不能用聚集函数 连接查询 #\r等值连接和非等值连接 #\rWHERE中连接两个表的条件格式\n[\u0026lt;表名1\u0026gt;]\u0026lt;列名1\u0026gt; \u0026lt;比较运算符\u0026gt; [\u0026lt;表名2\u0026gt;]\u0026lt;列名2\u0026gt; [\u0026lt;表名1\u0026gt;]\u0026lt;列名1\u0026gt; BETWEEN [\u0026lt;表名2\u0026gt;]\u0026lt;列名2\u0026gt; AND [\u0026lt;表名3\u0026gt;]\u0026lt;列名3\u0026gt; 如果比较运算符是=,这个连接是等值连接。若在等值连接中把目标列中重复的属性列删掉则为自然连接\n自身连接 #\r一个表和自己连接。必须给表起别名，且属性前有表别名前缀。 e.g. SELECT FIRST.Cno, SECOND.Cpno FROM Course FIRST, Course SECOND WHERE FIRST.Cpno == SECOND.Cno; 外连接 #\rLEFT|RIGHT OUT JOIN \u0026lt;表名\u0026gt; ON e.g. SELECT Student.Sno, Sname, Ssex, Sage, Sdept, Cno FROM Student LEFT OUT JOIN SC ON (Student.Sname=Cno); 多表连接 #\re.g. SELECT Student.Sno, Sname, Cname, Grade FROM Student, SC, Course WHERE Student.Sno = SC.Sno AND SC.Cno = Course.Cno; 嵌套查询 #\r将一个查询块嵌套在另外一个查询块的WHERE或HAVING里面\n查询块：一个SELECT-FROM-WHERE语句 子查询不能用ORDER BY字句\n相关子查询/不相关子查询: 是否需要用到父查询的信息\nALL和ANY量词\n用在比较符号后面，集合或者查询结果前面\ne.g. WHERE Sage\u0026lt;ALL (SELECT Sage FROM Student WHERE Sdept=\u0026#39;CS\u0026#39;) EXIST量词\ne.g. SELECT Sname FROM Student WHERE EXISTS (SELECT * FROM SC WHERE Sno=Student.Sno AND Cno=\u0026#39;1\u0026#39;) 遍历Student每一列，如果这一列能让子查询结果非空，EXISTS就会返回真，这一列也会加入查询结果里去。\nEXIST后面子查询都用*，因为子查询只返回是否非空，给列名没啥用\nEXIST前面可加NOT\n量词间的替换\nIN、比较运算符、ANY、ALL都可以被EXIST等价替换 反过来不一定行 ","date":"22 April 2024","externalUrl":null,"permalink":"/posts/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%AE%A1%E7%90%86%E5%9F%BA%E7%A1%80/c3-sql/","section":"","summary":"\u003ccode\u003eCREATE SCHEMA AUTHORIZATION \u003c/code\u003e \u003ccode\u003eDROP SCHEMA \u003c/code\u003e \u003ccode\u003esql CREATE TABLE ( [] [,同上] [,]) \u003c/code\u003e ```sql e.g. CR\u0026hellip;","title":"C3-SQL","type":"posts"},{"content":"","date":"22 April 2024","externalUrl":null,"permalink":"/categories/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%AE%A1%E7%90%86%E5%9F%BA%E7%A1%80/","section":"","summary":"","title":"数据库管理基础","type":"categories"},{"content":"\r第二章-处理器管理 #\r本章结构 2.1-处理器 #\r特权指令 #\r特权指令：只能被操作系统内核使用的指令 比如启动IO指令、置PC指令等 处理器模式 #\r0=OS内核；1=系统调用；2=共享库程序；3=用户程序 现代操作系统：内核模式(特权指令ok)，用户模式(非特权指令) 2.2-中断 #\r中断概念 #\r广义中断：程序执行过程中，遇到急需处理的事件时，暂时中止当前程序的运行，转去执行相应的事件处理程序。等中断处理完成后再返回原程序中断的地方或调度其他程序执行的过程叫中断。 狭义中断：事件来源于处理器外的广义中断。如IO中断、时钟中断、外部信号中断 广义中断 minus 狭义中断 异常：事件来源于处理器运行指令引起的广义中断。如地址异常、算术异常、处理器硬件故障 系统异常：执行陷入(trap)指令而触发系统调用引起的终端事件。如请求设备、请求IO、创建进程 中断驱动下的进程状态机 #\r中断源 #\r处理器硬件故障中断 程序性中断 自愿性中断-系统调用 IO中断 外部中断 2.3-进程 #\r⭐⭐⭐进程的概念 #\r进程是一个具有一定独立功能的程序关于某个数据集合的一次运行活动 进程是操作系统进行资源分配和调度的一个独立单位 对于多线程系统来说，进程是资源分配的独立单位 线程是资源调度的独立单位 进程的形式化定义 #\r⭐⭐⭐进程的三态模型 #\r运行态指进程占有处理器运行\n就绪态指进程具备运行条件等待处理器运行\n等待态指进程由于等待资源、输入输出、信号等而不具备运行条件\n进程挂起 #\r计算机资源不足，会剥夺某些进程的资源，调入OS管理的堆换区。这些进程就被挂起了。 挂起的进程不参加进程调度。在适当的时候被调回内存。 挂起和非运行态的本质区别是有没有占用系统资源 ⭐⭐⭐进程控制块 PCB #\rOS用于记录和刻画进程状态及环境信息的数据结构。说白了就是面向OS的进程的花名册\n包含标识信息、现场信息、控制信息。\n⭐⭐⭐进程映像 Process Image #\r进程的内存级实体 包括：PCB、进程程序空间、进程数据空间、核心栈 核心栈就是在内核态执行指令时用的栈 进程上下文 Process Context #\r进程执行所需要的环境信息 包括：用户级上下文、寄存器上下文、系统级上下文 原语 Primitive #\r若干条指令构成的程序，执行上具有原子性。意思是原语不可能被中断。 用于执行一些涉及修改OS核心数据结构的操作。为了防止并发和中断等时间上的错误，原语必须整块执行。 常用原语：进程控制原语、进程通信原语 2.4-多线程技术 #\r为什么要多线程 #\r单线程能一定程度上实现并发了，但我们还想更进一步。 限制单线程并发程度的要素： 进程切换开销大。想切换执行路径就必须换进程，开销很大。 进程通信开销大。进程通信要陷入系统调用，涉及模式转换，开销大。 解决： 分离资源分配和调度。因为资源分配比较静态，不会很频繁。相对而言，(如果想更加并发的话)调度比资源分配频繁多了。 两者分离的结果就是进程和线程 进程和线程 #\r进程 #\r操作系统的视角：是OS进行保护和资源分配的独立单位。\n是线程的容器。给线程提供运行环境和系统资源，包括内存等资源。\n线程 #\r操作系统视角：是OS调度的基本单位\n是进程的一条执行路径\n并发多线程的优点 #\r线程切换快 管理比进程方便(因为线程比较小) 通信容易实现，因为有进程这个容器的支 并行程度高 节省内存空间 线程的实现-KLT和ULT #\rKLT-内核级线程 #\r线程是OS实现并管理的 优点：线程的阻塞不会引起进程的阻塞(内核进程内部知道发生了什么并且还能给进程切换线程)、多处理器支持、使内核自身也可KLT实现 缺点：由于线程管理是OS实现的，相关操作要切换模式，开销较大(但应该还是比单线程系统管理进程要快，不然这样KLT就没意义了)。 ULT-用户级线程 #\r线程由用户实现并管理 OS感知不到多线程的存在。这样会带来一些问题。 优点：自定义程度高、多平台支持(可以移植到单线程的OS)、用户模式就能管理，开销小 缺点：多处理器不支持、线程阻塞会被OS视为进程阻塞 Jacketing技术 #\r当线程陷入系统调用时，执行jacketing程序。由jacketing程序来检查资源使用情况，以决定是否执行进程切换或传递控制权给另一个线程 混合策略 #\r单应用的多个ULT可以映射成一些KLT，通过调整KLT数目，可以达到较好的并行效果 2.5-处理器调度 #\r处理器调度的层次 #\r高级调度 决定进程的创建和终止 中级调度 决定进程的挂起和恢复 为了提高内存利用率和作业吞吐量，短期内调整系统负载 低级调度 决定哪个进程交给处理器运行 最核心、最影响系统性能的调度 ","date":"22 April 2024","externalUrl":null,"permalink":"/posts/se%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/c2-%E5%A4%84%E7%90%86%E5%99%A8%E7%AE%A1%E7%90%86/","section":"","summary":"","title":"C2 处理器管理","type":"posts"},{"content":"\r第一章-计算机操作系统概述 #\r本章结构 1.2.2-操作系统及其分类 #\r理论 #\rOS的概念：OS是计算机系统最基础的系统软件，管理软硬件资源、控制程序执行、改善人机界面、合理组织计算机工作流程，为用户使用计算机提供良好运行环境\nOS的组成：进程调度、进程通信、内存管理、设备管理、文件管理、网络通信、作业控制\nOS的类型：\n多道批处理系统（脱机） 分时操作系统 实时操作系统 1.3.5-程序接口的视角 #\r系统调用 #\r实现的基础是陷阱机制：从用户态陷入内核态 调用系统调用时(int **h)，操作系统从用户态转入内核态执行系统调用 系统调用返回时转入用户态 1.3.6-系统结构的视角 #\r操作系统内核设计 #\r设计概念：模块化、层次化、虚拟化 内核设计分类 #\r单内核 在一大坨代码中实际包含了所有操作系统功能，并作为一个单一进程运行，具有唯一地址空间。 大部分UNIX(包括Linxu)系统都采用的单体内核。 微内核 大部分OS功能作为单独的进程在内核态外运行，他们通过消息传递进行通讯。 内核态只有最基本、最核心的功能模块。比如IPC、虚存、调度 混合内核 外内核 OS本身值提供很低级的硬件操作，没有很完整的硬件抽象。 用在嵌入式上 ","date":"22 April 2024","externalUrl":null,"permalink":"/posts/se%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/c1-%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E6%A6%82%E8%BF%B0/","section":"","summary":"","title":"C1 计算机操作系统概述","type":"posts"},{"content":"\rLec-0 绪论 #\r观察OS的视角 #\r用户角度 #\rOS是服务提供者 - 接口和服务 系统角度 #\rOS是资源管理者 - 处理器管理、存储管理、设备管理、文件管理 OS是虚拟机 - 虚拟机、os结构、os运行模型、网络环境下的操作系统 OS是程序执行的控制者 - 进程交互、调度、同步、通信、死锁 最基础的抽象🤓☝️ #\r进程抽象-是对已进入主存正在运行的程序在处理器上操作的状态集的抽象 。 虚存抽象-是对物理主存的抽象，进程可获得一个硕大的连续地址空间来存放可执行程序和数据，可使用虚拟地址来引用物理主存单元。 文件抽象-是对设备(磁盘)的抽象 。 复习Roadmap #\r","date":"22 April 2024","externalUrl":null,"permalink":"/posts/se%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/c0-%E7%BB%AA%E8%AE%BA/","section":"","summary":"","title":"C0 绪论","type":"posts"},{"content":"\r关于 #\r有时间再写哦。\n","externalUrl":null,"permalink":"/about/","section":"","summary":"","title":"","type":"about"},{"content":"","externalUrl":null,"permalink":"/authors/","section":"Authors","summary":"","title":"Authors","type":"authors"},{"content":"","externalUrl":null,"permalink":"/series/","section":"Series","summary":"","title":"Series","type":"series"},{"content":"","externalUrl":null,"permalink":"/tags/","section":"Tags","summary":"","title":"Tags","type":"tags"}]