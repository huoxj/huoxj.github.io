
[{"content":"\r更新计划 #\r无 ","date":"1 January 2025","externalUrl":null,"permalink":"/","section":"","summary":"","title":"","type":"page"},{"content":"\r文章归档 #\r","date":"1 January 2025","externalUrl":null,"permalink":"/posts/","section":"","summary":"","title":"","type":"posts"},{"content":"\r分类 #\r","date":"29 December 2024","externalUrl":null,"permalink":"/categories/","section":"","summary":"","title":"","type":"categories"},{"content":"","date":"29 December 2024","externalUrl":null,"permalink":"/categories/c++%E6%8B%BE%E9%81%97/","section":"","summary":"","title":"C++拾遗","type":"categories"},{"content":"\r错误 #\r语法错误：编译器解决 逻辑错误：测试解决 异常 #\r运行环境造成。如内存不足、文件操作失败等 特征 可以预见 无法避免 异常处理：提高程序鲁棒性 异常处理方法 #\r传统的方法是，使用函数参数或者返回值来标识是否发生异常、发生什么异常。\n函数调用者检查参数或者返回值来确定异常，并处理异常。\n这样需要逐层返回。并且对于一些特殊的情况无法处理，比如构造函数发生异常。\nC++ 异常处理机制 #\rtry #\r监控语句序列中是否发生异常。\ntry{ statements to monitor } throw #\rtry 中检测到异常时，抛出异常。\nthrow expression catch #\r捕获异常并处理。try 后可以跟随多个 catch 来捕获不同类型的异常。\ncatch (ExceptionType e){ deal with exception... } 异常处理的嵌套 #\r抛出的异常会在调用链中自下往上捕获。\n最终还未被捕获的异常，由系统的 abort 处理。\n异常类间的继承 #\r在捕获一系列有继承关系的异常类对象的时候，需要注意：\n用引用传递异常对象。 即：\ntry {...} catch(Exception1 \u0026amp;e1){...} catch(Exception2 \u0026amp;e2){...} 如果直接传异常对象，容易发生对象切片。\nclass EBase {}; class EDerived: public EBase {}; void f(EBase e) { throw e; } EDerived e; try { f(e); // Object Slicing, throwing EBase instead of EDerived } catch(EDerived e) { cout\u0026lt;\u0026lt;\u0026#34;Derived\u0026#34;; } catch(EBase e) { cout\u0026lt;\u0026lt;\u0026#34;Base\u0026#34;; } // e caught here 按 “从最派生的类到最基的类” 的顺序来捕获 catch 是按声明顺序捕获的。\n派生类对象可以被基类的 catch 捕获。\n基类在前面的话，后面的派生类会无法捕获。\n无参数 throw #\r将捕获到的异常对象重新抛掷出去\ncatch(int) { throw; } ","date":"29 December 2024","externalUrl":null,"permalink":"/posts/c++%E6%8B%BE%E9%81%97/%E5%BC%82%E5%B8%B8%E5%A4%84%E7%90%86/","section":"","summary":"传统的方法是，使用或者来标识是否发生异常、发生什么异常。 函数检查参数或者返回值来确定异常，并。 这样需要逐层返回。并且对于一些特殊的情况无法处理，比如构造函数发生异常。 \u0026mdash; 语句序列中是否发生异\u0026hellip;","title":"异常处理","type":"posts"},{"content":"\r用户 #\r用户特性 #\r心理学原理部分，假设每个人都有相似的能力和局限性。\n交互产品设计人员应该意识到个性的差异。\n用户的差异主要体现在：\n体验水平 年龄 文化 健康 体验水平差异 #\r新手用户 #\r特点\n敏感，且很容易在开始有挫折感 设计要求 不能将新手状态视为目标 让学习过程快速且富有针对性 确保程序充分反映了用户关于任务的心智模型 无论什么样的帮助，都不应该在界面中固定 具有向导功能的对话框帮助较好 不要使用在线帮助作为学习指导 菜单项应该是解释性的 专家用户 #\r特点\n对缺少经验的用户有着异乎寻常的影响 欣赏更新的且更强大功能 不会受到复杂性增加的干扰 设计要求 对经常使用的工具集，要能快速访问 中间用户 #\r特点\n需要工具 知道如何使用参考资料 能够区分经常使用和很少使用的功能 高级功能的存在让永久的中间用户放心 设计要求 工具提示（Tooltip）是适合中间用户最好的习惯用法 在线帮助是永久中间用户的极佳工具 常用功能中的工具放在用户界面的前端和中心位置 提供一些额外的高级特性 年龄差异 #\r老年人和儿童\n文化差异 #\r符号：勾（√）和叉（X）分别表示肯定和否定 姿势：点头vs.摇头 颜色：如红色与绿色 健康差异 #\r听见、视觉 身体损伤 语言 朗读 ⭐用户建模 #\r可能会考设计、评估人物角色\n使用人物角色 (Personas) 对用户进行建模。\n人物角色 #\r不是真实的人 是基于观察到的那些真实人的行为和动机，并且在整个设计过程中代表真实的人 是在人口统计学调查收集到的实际用户的行为数据的基础上形成的综合原型 解决什么问题 #\r弹性用户 自参考设计 边缘情况设计 怎么构造人物角色 #\r观点：真实用户和人物角色，既是多对一的关系，也是一对多的关系\n建模时基于如下问题：\n谁将使用系统？ 这些用户属于哪些类型的人群？ 是什么因素决定他们将怎样使用系统？ 他们与软件的关系有什么特征？ 他们通常需要软件提供什么支持？ 他们对软件会有怎样的行为？他们对软件的行为有什么期望？ 例子 #\r例子中还包含了场景。\n⭐场景 #\r理解就行\n场景表示任务和工作结构的“非正式的叙述性描述”。\n翻译：讲故事\n回答了：\n用户的行为 用户的需要、需求与目标（故事的焦点） 用户的体验与意见 任务的上下文 例子： 正确输入作者姓名的重要性 用户对输入口令感到反感 应提供更灵活的检索方法 在匹配不成功时，应给出相近的检索结果 ⭐任务分析 #\r任务分析是记录人们如何完成任务的一种方式，对用户体验至关重要。\n主要的技术是层次化任务分析 HTA。\nHTA #\r类似建树的递归过程：目标 / 任务 -\u0026gt; 子目标 / 子任务\n可以用列表表示，也可以用树表示。\n分解过程 #\r基础情况：要分析的任务 递归步骤： 将当然任务分成一系列子任务，子任务能够描述如何实现该任务 停止条件： 包含复杂机械响应的子任务。如“移动鼠标” 涉及内部决策的子任务。如“选择感兴趣的商品”，即根据用户的认知直接就能执行的操作。 特点 #\r层次化任务分析非常耗时，且不完善 会给出一个有用的、有代表性的描述 但没有说明如何去收集那些我们希望表达的任务信息 不应作为界面结构和风格的唯一评价标准 优点 有经验的分析师能够使用HTA相对快捷地提供有用的设计信息 缺点 分析结果的展现方式不容易和软件工程师所用的表示方式联系起来 画图表示注意点 #\r树的节点用方框表示，里面放任务名 任务名前面要编号，子任务的编号前缀来自父任务 叶子节点（不能再细分的任务），在方框下面画一条横线 对于可分解的任务，要说明子任务的执行次序 如果这个任务的执行可能有多种路径，可以分别说明 例子们 #\r用列表表示： 用树表示\n","date":"27 December 2024","externalUrl":null,"permalink":"/posts/%E4%BA%BA%E6%9C%BA%E4%BA%A4%E4%BA%92/lec-8-%E4%BA%A4%E4%BA%92%E5%BC%8F%E7%B3%BB%E7%BB%9F%E7%9A%84%E9%9C%80%E6%B1%82/","section":"","summary":"心理学原理部分，假设每个人都有相似的能力和局限性。 交互产品设计人员应该意识到个性的差异。 用户的主要体现在： 特点 设计要求 特点 设计要求 特点 设计要求 老年人和儿童 使用人物角色 (Perso\u0026hellip;","title":"Lec-8 交互式系统的需求","type":"posts"},{"content":"","date":"27 December 2024","externalUrl":null,"permalink":"/categories/%E4%BA%BA%E6%9C%BA%E4%BA%A4%E4%BA%92/","section":"","summary":"","title":"人机交互","type":"categories"},{"content":"\rWhy #\rC 中的强制类型转换是通过在表达式前面加类型名实现的。\nC++ 中，强制类型转换被细分成了四个运算符：\nstatic_cast reinterpret_cast const_cast dynamic_cast 原因如下：\n不同场景下的强制转换，风险是不同的，需要细分来体现 比如，int 转成 double 是风险不大的；但是将 const 指针转换成非 const 指针是十分危险的。 在继承场景下，将基类转换成派生类需要检查是否成功 C 中的强制转换是无法知道基类指针转换成派生类是否成功的。但是 dynamic_cast 可以以返回 nullptr 的方式告诉你转换是否成功。 程序中强制类型转换难以定位 新方法中，你只需要找 cast 单词出现的地方，就能知道所有进行了显示强制类型转换的地方。 类型转换出错时，cast 会报错，方便定位错误 static_cast #\rstatic_cast 负责风险低、自然的转换。允许可以隐式转换的类型间的转换。\n具体来说：\n允许基本类型之间的转换。比如 int、float、double 之间的转换 允许对象的重载了强制类型转换运算符的转换 其他场景尽量不要用 static_cast dynamic_cast #\rdynamic_cast 负责基类到派生类的引用和指针的转换。\n目标类型是源类型的派生。即父转子。 被转换的类需要有虚函数，否则会报错： bad_dynamic_cast_not_polymorphic: 'xxx' is not polymorphic reinterpret_cast #\rreinterpret_cast 负责指针的不安全的转换。转换时，逐 bit 复制数据，也印证了 reinterpret 的含义，就是对相同的 01 bit 流进行不同的解释。\n负责不同类型的指针、引用之间的转换 指针到指针数值（里面存的地址）的转换。 const_cast #\rconst_cast 负责去除 const 的转换。\n将 const 的只读变量转换成普通的可读可写的变量 参考 #\rC++强制类型转换运算符（static_cast、reinterpret_cast、const_cast和dynamic_cast） - C语言中文网\nC++ 类型转换详解\n","date":"24 December 2024","externalUrl":null,"permalink":"/posts/c++%E6%8B%BE%E9%81%97/c++-%E5%BC%BA%E5%88%B6%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2/","section":"","summary":"C 中的强制类型转换是通过在表达式前面加类型名实现的。 C+，强制类型转换被细分成了四个运算符： 原因如下： 比如，int 转成 double 是风险不大的；但是将 const 指针转换成非 cons\u0026hellip;","title":"C++ 强制类型转换","type":"posts"},{"content":"根据上课 PPT 和同学与学长的笔记整理而成。\n介绍 #\rC++ 历史 #\r先跳过。。。\n结构化编程部分 #\r强制类型转换 #\r表达式的副作用 #\r副作用，就是一个过程是否会修改参与的变量的性质。\n在表达式中，有副作用的运算符：= += ++ \u0026lt;\u0026lt; 等等 无副作用的运算符：+ \u0026amp;\u0026amp; 等等\ndecltype #\r和 auto 有相似之处。\nauto 和 decltype 都用在声明变量上，都是基于 RTTI 机制实现的。\nauto 是对初始化的右值进行类型推导，然后给声明的变量确定类型、赋值。\ndecltype 是对传入的参数类型进行类型推导，然后本身就作为这个类型的名称。\nint x = 0; int\u0026amp; ref = x; auto ref1 = x; decltype(ref) ref2 = x; // equals to \u0026#34;int\u0026amp; ref2 = x\u0026#34; 既然本身就作为这个类型的名称，我们也可以结合 using 和 typedef：\nint x = 0; int\u0026amp; ref = x; using int_ref = decltype(ref); 参考 #\rC++11特性：decltype关键字 - melonstreet - 博客园\n聚合初始化 #\r聚合初始化的规则比较复杂，考试应该不涉及。下面简单举几个例子：\nint[] arr = {1, 2, 3}; int[5] arr1 = {1, 2, 3, 4}; vector\u0026lt;int\u0026gt; arr2{1, 2, 3}; vector\u0026lt;vector\u0026lt;int\u0026gt;\u0026gt; arr3{{1, 2, 3}, {4, 5}, {6}}; Union 实现多态 #\r父类联合体包含所有子类结构体。然后记得给子类加上类型的枚举。\n例子中的声明顺序只是为了方便查看，不用在意是否能编译通过。\n// Base union FIGURE { FIGURE_TYPE t; Line line; Rectangle rect; Ellipse ellipse; }; // Derived struct Line{ FIGURE_TYPE t; int x, y; }; struct Ellipse { FIGURE_TYPE t; int x, y, r; }; struct Rectangle{ FIGURE_TYPE t; int left, top, right, bottom; }; Struct 对齐 #\r先讨论没有 #pragma pack 的情况，如何确定 struct 的对齐与大小。\n首先有如下规则：\n结构体的成员声明的顺序就是在内存中的顺序 某一个成员相较于 struct 开头的偏移量，必须是自身大小的整数倍 整个结构体大小必须是最大成员大小的整数倍 第一条规则，确定了成员的顺序就是声明的顺序。\n我们按照声明的顺序，一个一个地应用第二条规则。不满足规则的，就补齐。\n最后，看满不满足第三条规则。不满足就补齐。\n有了 pragma 之后，每个数据成员的对齐，按照#pragma pack指定的数值和自身对齐模数中较小的那个。\ncin/cout 输入/输出操纵符 #\r操纵符是令代码能以 operator\u0026laquo; 或 operator\u0026raquo; 控制输入/输出流的帮助函数。\n包括的一些感觉比较重要的操纵符如下 输入用：\nskipws get_time 输出用 showbase setbase uppercase dec hex oct setprecision setw put_time 可以翻阅 cppreference -\u0026gt; 输入输出库 -\u0026gt; 输入输出操纵符\nTuple #\r大名叫 std::tuple。元组。能保存任意数量的任意类型的成员变量。可以看成一个类型安全、使用灵活便捷的结构体。\n头文件 \u0026lt;tuple\u0026gt;\ntuple 是静态的，需要在声明的时候就确定要保存哪些类型：\nstd::tuple\u0026lt;int, double, std::string, char\u0026gt; t; 初始化：\n// constructor std::tuple\u0026lt;int, double, std::string, char\u0026gt; t(1, 2.0, \u0026#34;hello\u0026#34;, \u0026#39;c\u0026#39;); // make_tuple t = make_tuple(1, 2.0, \u0026#34;hello\u0026#34;, \u0026#39;c\u0026#39;); 使用 std::get\u0026lt;\u0026gt; 获取元素：\nint first = std::get\u0026lt;0\u0026gt;(t); int i = 1; std::get\u0026lt;i\u0026gt;(t); // Wrong!!! Cannot use variable 使用 std::tie 解包：\nint a; double b; std::string c; char d; std::tie(a, b, c, d) = t; 使用 std::tuple_size 获取 tuple 元素个数：\nint el_count = std::tuple_size\u0026lt;decltype(t)\u0026gt;::value; 参考 #\rC++ tuple（STL tuple）模板用法详解 - RioTian - 博客园\nC++ tuple元组的基本用法(总结)-CSDN博客\nOptional #\r和 java 的 optional 如出一辙。大致是为了包装函数返回值而生的。\n头文件 \u0026lt;optinal\u0026gt;\noptional 可以理解为包含了两个信息：函数运行信息（成功，失败）、函数返回值\n声明 optional：\nstd::optional\u0026lt;T\u0026gt; opt; // 不包含值的 optional nullopt; // 不包含值的 optional，宏定义好了 std::optional\u0026lt;T\u0026gt; opt(value); // 包含 value make_optional\u0026lt;T\u0026gt;(value); // make 方法 函数失败：\nreturn nullopt; 函数成功，返回 result：\nreturn make_optional\u0026lt;T\u0026gt;(result); 函数调用方： 使用 has_value 检查函数返回是否为空（函数执行是否失败） 如果成功，可以直接将 optional 当成结果来取值。注意，这里 value 类似迭代器，是一个指向结果的指针。\nauto result = foo(); if(!result.has_value()) { cout\u0026lt;\u0026lt; \u0026#34;failed\u0026#34;; } else { result-\u0026gt;xxx ...; // 直接将 optional 对象当成返回结果的指针用 } 参考 #\rC++17 新特性之 std::optional（上） - 知乎\nC++三剑客之std::optional(一) : 使用详解_c++ optional-CSDN博客\nPair #\r特化的 tuple。只能放两个元素。\n头文件 \u0026lt;utility\u0026gt;\n用 first 和 second 来访问两个元素。\nmake_pair 来创建一个 pair。通过 tie 来解包。和 tuple 一毛一样。\nVariant #\r类型安全的 union。但不允许包含引用、数组、void。\n头文件 \u0026lt;variant\u0026gt;\n创建与访问：\nstd::variant\u0026lt;int, float, std::double\u0026gt; var; var = \u0026#34;abc\u0026#34;; // or var.emplace(\u0026#34;abc\u0026#34;) std::get\u0026lt;std::string\u0026gt;(var); // \u0026#34;abc\u0026#34; std::get\u0026lt;int\u0026gt;(var); // exception std::bad_variant_access var = 0.1f; const auto intPtr = std::get_if\u0026lt;float\u0026gt;(\u0026amp;var) // safe get 检查当前是否持有某类型：\n使用 std::holds_alternative\nif(std::holds_alternative\u0026lt;int\u0026gt;(var)) { std::cout\u0026lt;\u0026lt;\u0026#34;var holds int\u0026#34;\u0026lt;\u0026lt;endl; } 空状态：\n即 variant 什么都没放的 “无值” 状态。用 std::monostate 表示\nstd::variant\u0026lt;std::monostate, int\u0026gt; var; 参考 #\rC++17 std::variant 详解：概念、用法和实现细节 - 非法关键字 - 博客园\nAny #\r类型安全的，能存放任意类型数据的容器(void*)。\n头文件 any\n声明与赋值：\nstd::any a; a = 1; // store an integer a.emplace(1); // same effect as above a = make_any(1) // make method 取出使用：\na = 1; std::any_cast\u0026lt;int\u0026gt;(a); // returns 1 std::any_cast\u0026lt;char\u0026gt;(a); // throw std::bad_any_cast exception 检查是否有值：\n使用 has_value 成员函数。返回 bool。\nstd::any a; a.has_value(); // false a = 1; a.has_value(); // true 检查所存储元素类型：\n使用 type 成员函数。返回成员类型的 typeid\na = 1; a.type() == typeid(int) // true a.type() == typeid(char) // false new/delete #\r在使用 new 创建数组时，前 4 个字节会存放声明的数组长度。\n方便 delete[] 时，知道要释放多少空间。\nRAII 与智能指针 #\rC 数组特性 #\r指针作为函数参数 #\r为什么\n提高传输效率，不用拷贝传递的实参 使用函数的副作用，改变传入参数的值。如果不想要副作用，可以加 const 函数指针 #\r没啥讲的。方便实现函数的动态调用。然后就是 lambda 函数。\n函数指针的解析，看：\n函数执行机制 #\r如下只是大致的步骤，会根据具体的函数调用约定而有些许不同。\n建立被调用函数的栈空间 参数传递： 值传递 (call by value) 引用传递 (call by reference) 保存调用函数的运行状态 返回地址 调用者的 ebp 将控制转交被调函数 设置新的 ebp 和 esp 恢复上下文 恢复调用者 ebp 恢复返回地址 函数调用约定 #\r函数调用约定回答了如下问题：\n当参数个数多于一个时，按照什么顺序把参数压入堆栈 函数调用后，由谁来把堆栈恢复原装 stdcall #\rpascal 风格的调用约定。\nint __stdcall foo(int a, int b); 参数从右向左压栈 函数自己恢复堆栈 例子中，被调用者 foo 的返回的汇编为 ret 8，表示清除 a 和 b 参数占的堆栈 函数名的标签变为 _ + 函数名 + @ + 参数大小 例子中，函数的标签为 _foo@8 cdecl #\rC 调用约定。是 C 语言默认的调用约定。\nint __cdecl foo(int a, int b); int foo(int a, int b); // default is cdecl 参数从右往左压栈 调用者恢复堆栈 被调用者直接用 ret 返回，不恢复堆栈。 调用者在 call foo 之后，使用 add esp, 8 来恢复两个 int 参数的堆栈。 函数名标签 _ + 函数名 这种调用约定能支持可变参数。可变参数在声明里面是放在最右边的，这样保证了左边的参数先入栈，能通过 ebp 确定，从而确认可变参数。并且调用者可以根据自己传的参数大小来恢复堆栈。\nfastcall #\r和 stdcall 类似，但是更 fast，因为用到了寄存器。\nint __fastcall foo(int a, int b); 第一个和第二个声明的大小小于等于 DWORD 的参数，通过 ecx 和 edx 传 例子中，a 和 b 分别放到 ecx 和 edx 中。然后就没有参数需要压栈了。 其他的参数还是按 stdcall 的方式压栈 被调用者清理堆栈 thiscall #\rC++ 默认的调用约定。特殊处理了 this 指针。\nint foo(int a, int b); int __thiscall foo(int a, int b); // wrong! no need for \u0026#39;__thiscall\u0026#39; 参数从右向左压栈 参数个数确定的情况下，this 指针通过 ecx 传递；有可变参数，this 指针最后被入栈 参数个数确定，被调用者清理堆栈；可变参数，调用者清理堆栈 参考 #\rC/C++ 函数调用约定（__cdecl、__stdcall、__fastcall）-CSDN博客\n关于调用约定 cdecl、stdcall 和 fastcall 的区别 | 拾遗记\nstdcall、cdecl、fastcall、thiscall 、naked call的汇编详解 - findumars - 博客园\n格式化串攻击 #\r由于调用约定的存在，不定参数的函数是不知道参数的个数与大小的。这在 scanf 和 printf 上会产生漏洞。\n比如，用户在 scanf 输入字符串时，故意包含了格式化字符\nchar str[100]; scanf(\u0026#34;%s\u0026#34;, str); // 输入 %x\\n%x\\n%x\\n printf(str); printf 只知道你传入了 str 格式串。一旦扫描到了 %x，就将对应偏移量的参数给输出出来，但是调用方并没有传对应的参数，这会导致 printf 输出对应地址上的内容。\n所以，当 printf 传入参数不足格式化串中字符的个数时，就会导致这个漏洞。\n泄露地址 栈上地址任意写入（通过输入 %n） 函数重载 #\r原则：\n名同，参数不同（个数、类型、顺序） 返回值类型不作为区别重载函数的依据 特殊情况：传入类型没有重载，但是可以隐式转换到多个重载的，编译无法通过\nvoid foo(char a){} void foo(double a){} foo(1); // Call to \u0026#39;foo\u0026#39; is ambiguous 默认参数 #\r函数传入的参数可以设置默认参数，在不传默认参数时使用默认参数指定的值。就像 Python 一样。\n注意点：\n默认参数的声明，要在函数原型中给出。如果没有函数原型，就在函数定义中给出。 默认参数从右到左声明，不能间断 void foo(double, char, int=2); // okay void foo(double=1.0, char, int); // wrong!!! void foo(double=1.0, char, int=2); // wrong!!! 默认函数和函数重载不能出现 ambiguous void f(int); void f(int, int=2); f(1); // ambiguous!!! 内联函数 #\rinline 关键字\n目的\n提高可读性 提高效率，因为减少了函数调用的过程 限制\n不能递归 不能作为函数指针 适用：频率高、简单、小段的代码\n其他：inline 声明仅仅是请求，编译器可以拒绝\n缺点\n增大目标代码 换页抖动 降低指令 cache 的命中率 Namespace #\r命名空间。限制全局标识符的作用域，方便区分同名函数。\n声明形式：\ndeclaration using std::cout; using std::cin; directive 不建议同一文件多次用 directive using namespace std; 默认匿名命名空间 using ::variable; 别名 namespace std_alias=std; 全局 只要在某个文件里声明了 namespace，其他文件可以直接访问 开放 namespace 的内容完全公开 可嵌套 namespace A{ int a; namespace B{ int b; } } A::a; A::B::b; 重载 编译预处理 #\rPPT 上说：与作用域、类型、接口等概念格格不入。\n能理解，但理解得不多🫠。\ninclude #\r作用是复制其中的文件内容到此处。\n包含头文件 防止重定义：用 #ifdef 等 替换操作 printf(\u0026#34;#\u0026#34;) \u0026quot;\u0026quot; 与 \u0026lt;\u0026gt; 使用 \u0026lt;\u0026gt; 时，预处理器会按如下顺序寻找文件： 到编译选项 -l 指定的目录 到环境变量 INCLUDE 指定的目录 使用 \u0026quot;\u0026quot; 时： Current Workspace Directory 编译选项 -l 目录 环境变量 INCLUDE 目录 define #\r替换文本宏。define 定义替换，undef 取消定义\n空 define 多用于防止重复定义 预定义宏 比如 c++ 标准版本的宏 功能特性测试宏 比如开优化的宏 仿函数宏 含参数的宏，比如之前打 oi 常用的省时间宏 #define f(q, w, e) for(int q = w; q \u0026lt; e; q++) f(i, 0, n) {...} 还能实现泛型 #define add(x, y) (x + y) 加括号是必要的，为了保证加法不受外部运算符优先级的影响。\n对于函数体的替换 用 do while(0) 保证函数体的独立性与完整性 #define incAndPrint(a) do{\\ a++;\\ a.print();\\ } while(0); 如果没有 do while(0)，放在无花括号的 if 里就出问题了。\n// with out do while(0) if(a) incAndPrint(a); // equals to if(a) a++; a.print(); // outside of if # 运算符 运算符后跟参数名，将这个参数转换成字符串。 #define foo(x) #x foo(12345); // \u0026#34;12345\u0026#34; foo(n); // \u0026#34;n\u0026#34; ## 运算符 运算符后跟参数名，将这个参数的名字作为一个 token 拼接到代码中。 #define def_stack(x) typedef stack_##x{} def_stack(int); // typedef stack_int{} pragma #\r结构体对齐。没研究过，先跳过。\n泛型 #\r前面说过，可以用宏实现泛型：\n#define CREATE_STACK(T) \\ typedef struct stack_##T { \\ T* array; \\ int top; \\ } stack_##T\\ \\ void __init(stack_##T *stack, int capacity) {...}\\ void __push(stack_##T *stack, T data) {...}\\ ... 但是太麻烦了\n代码可读性查 难调试 需要显式写出类型参数 手动实例化 使用模板实现：\ntemplate\u0026lt;typename T\u0026gt; struct Stack{ T* array; int capacity; int top; }; ... 好写很多。\nconcept #\r约束类模板和函数模板的模板类型和非类型参数的命名要求。\n比如，限制函数模板不能是指针：\ntemplate\u0026lt;typename T\u0026gt; concept DataAvailable = !std::is_pointer\u0026lt;T\u0026gt;::value; template \u0026lt;DataAvailable T\u0026gt; void function(T t) {...} 其他写法：\ntemplate \u0026lt;typename T\u0026gt; requires DataAvilable void function(T t) {...} template \u0026lt;typename T\u0026gt; void function(T t) requires DataAvilable\u0026lt;T\u0026gt; {...} void function(DataAvilable auto v) {...} 可以用 \u0026amp;\u0026amp; 组合多个约束：\n```cpp template \u0026lt;typename T\u0026gt; concept signed_integral = integral\u0026lt;T\u0026gt; \u0026amp;\u0026amp; std::is_signed_v\u0026lt;T\u0026gt;; SFINAE #\rSubstitution Failure Is Not An Error\n模板的匹配失败不是错误。在匹配类型失败后，编译器还需要尝试其他的可能性\n特化 #\rC++ 模板 全特化与偏特化 - 知乎\n参考 #\rC++20: Concept详解以及个人理解 - 知乎\nC++模板进阶指南：SFINAE - 知乎\n元编程 Meta programming / constexpr #\r在编译期就计算出运行时需要的东西。\n面向对象部分 #\r面向对象概念 #\r构造函数 #\r构造函数 #\r构造函数有三种：\n无参构造函数 有参构造函数 拷贝构造函数 默认提供 #\r编译器会提供 默认无参构造函数 和 拷贝构造函数。\nEmpty(); Empty(const Empty\u0026amp;); 默认的无参构造函数是空函数，什么都不干。\n拷贝构造函数，对所有成员进行浅拷贝。\n成员初始化表 #\r析构函数 #\r编译器默认提供空的析构函数。\n拷贝构造函数 #\r移动构造函数 #\r动态内存 #\rconst 成员 #\rstatic 成员 #\r友元 #\r友元类 #\r友元函数 #\r友元函数不是类的成员函数！！！\n编译器默认提供的函数 #\rclass Empty { Empty(); Empty(const Empty\u0026amp;); ~Empty(); Empty\u0026amp; operator=(const Empty\u0026amp;); Empty* operator \u0026amp;(); const Empty* operator \u0026amp;() const; } 继承概念 #\r目的：基于目标代码的复用\n思想：对事物进行分类。派生类是基类的具体化。把事物（概念）以层次结构表示出来，有利于描述和解决问题。\n可用于：增量开发\n多态 #\r同一论域中一个元素可有多种解释\n提高语言灵活性 程序设计语言 一名多用——函数重载 类属——模板 OO 程序设计——虚函数 运算符重载 #\r动机：使用操作符的语义。为自定义数据类型提供类似内置类型的操作方式。 作用：提高可读性、可扩充性 对象切片 #\r将派生类对象赋值给基类对象时，会发生对象切片。派生类对象会变成基类，只有其基类部分的成员被保留。\nclass Base{ public: virtual void foo() { cout\u0026lt;\u0026lt;\u0026#34;Base\u0026#34;; } }; class Derived: public Base{ public: void foo() override { cout\u0026lt;\u0026lt;\u0026#34;Derived\u0026#34;; } } void function(Base base){ base.foo(); } Derived derived; function(derived); // Base 从结果上来说，把 derived 的数据赋给一个 base 对象的内存是不现实的，因为一般来说 sizeof Derived 比 sizeof Base 大。\n避免发生切片的方法是使用引用或者指针。\nvoid function(Base\u0026amp; base){ // use Reference base.foo(); } Derived derived; function(derived); // Derived 其他 #\r异常处理 #\r右值引用 #\r","date":"24 December 2024","externalUrl":null,"permalink":"/posts/c++%E6%8B%BE%E9%81%97/c++%E6%9C%9F%E6%9C%AB%E5%A4%8D%E4%B9%A0/","section":"","summary":"根据上课 PPT 和同学与学长的笔记整理而成。 先跳过。。。 {{}} 副作用，就是一个过程是否会修改参与的变量的性质。 在表达式中，有副作用的运算符：\u003ccode\u003e=\u003c/code\u003e \u003ccode\u003e+=\u003c/code\u003e \u003ccode\u003e++\u003c/code\u003e \u003ccode\u003e\u0026lt;\u0026lt;\u003c/code\u003e 等等 无副\u0026hellip;","title":"C++期末复习","type":"posts"},{"content":"用户测试主要是指在受控环境中测量典型用户执行典型任务的情况，目标是获取客观的性能数据来评价系统的可用性，适合对原型和现有系统进行评估。\nDECIDE 评估框架 #\r六个步骤 #\r决定评估需要完成的总体目标 发掘需要回答的具体问题 选择用于回答具体问题的评估范型和技术 标识必须解决的实际问题，如测试用户的选择 决定如何处理有关道德的问题 评估解释并表示数据 1. 确定目标 #\r评估目标决定了评估过程，影响评估范型的选择。\n评估的 why：\n产品设计是否理解了用户需要 为概念设计选择最佳隐喻 界面是否满足一致性需要 探讨新产品应做的改进 2. 发掘问题 #\r根据目标确定问题。 问题可逐层分解 3. 选择评估范型和技术 #\r范型决定了技术类型 必须权衡实际问题和道德问题 最适合的技术可能成本过高、所需时间过长、不具备必要设备和技能 可结合使用多种技术 不同技术有助于了解设计的不同方面 不同类型数据可从不同角度看待问题 组合有助于全面了解设计的情况 4. 明确实际问题 #\r即如下因素的选择，以及明确限制等注意事项。\n用户 选择恰当的用户 用户任务时间 安排用户熟悉系统 设施及设备 期限与预算 技能技术 是否需要可用性专家 选择参与者 #\r选择具有代表性的典型用户； 通常需要根据实际情况平衡性别比例。 至少 4−5 位，5−12 位用户就足够了。 5. 处理道德问题 #\r保护个人隐私\n指导原则 #\r说明研究的目的及要求参与者做的工作 说明保密事项 测试对象是软件，而非个人 对测试过程的特殊要求，是否边做边说等 用户可自由表达对产品的意见 说明是否对过程进行录像 不能拍摄用户的面部 欢迎用户提问 用户有随时终止测试的权利 对用户话语的使用应征得同意，并选择匿名方式 6. 评估、解释并表示数据 #\r评估技术决定了：搜集什么类型的数据，如何分析，如何表示 可靠性 有效性 偏见 普遍性 环境影响 小规模试验 #\r对评估计划进行小范围测试\n以确保评估计划的可行性 如检查设备及使用说明 练习访谈技巧 检查问卷中的问题是否明确 小规模试验可进行多次\n类似迭代设计 测试——反馈——修改——再测试 快速、成本低 可用性问题分级 #\r方法一：基于量化数据的分级 如多少人遇到该问题，耗费多少时间等 方法二：问题严重性的主观打分，取平均值 方法三：可用性分级的两个因素 多少用户会遇到这个问题 用户受该问题影响的程度 该问题只在第一次使用时出现，还是会永远出现 ","date":"22 December 2024","externalUrl":null,"permalink":"/posts/%E4%BA%BA%E6%9C%BA%E4%BA%A4%E4%BA%92/lec-7-%E8%AF%84%E4%BC%B0%E6%8A%80%E6%9C%AF-%E7%94%A8%E6%88%B7%E6%B5%8B%E8%AF%95/","section":"","summary":"用户测试主要是指在测量典型用户的情况，目标是获取的性能数据来评价系统的可用性，适合对原型和现有系统进行评估。 1. 决定评估需要完成的总体目标 2. 发掘需要回答的具体问题 3. 选择用于回答具体问题\u0026hellip;","title":"Lec-7 评估技术-用户测试","type":"posts"},{"content":"\r背景 #\r了解用户的需要和对产品的意见和建议 观察用户 询问用户 适用于客观上较难度量的、与用户主观满意度和可能的忧虑心情相关的问题 访谈和问卷调查 在研究用户如何使用系统，以及哪些系统功能是用户非常喜欢或不喜欢的方面也非常有效 不知道该怎么做或者对预期的结果没有把握 请专家帮忙 不能帮助大家成为可用性专家 但有助于更好地去评估自己和他人的工作 询问用户-访谈 #\r有目的的对话过程。\n分类 #\r开放式（或非结构化）访谈 问题是开放式的，不限定内容和格式 受访人自行选择详细回答还是简要回答 访问人应确保能够搜集到重要问题的回答 结构化访谈 根据预先确定的一组问题进行访谈 问题通常是“封闭式”的，它要求准确的回答 半结构化访谈 开放式问题+封闭式问题 集体访谈 基本思想：个别成员的看法是在应用的上下文中通过与其他用户的交流而形成的 “焦点小组”是集体访谈的一种形式 原则 #\r避免过长的问题 避免使用复合句 避免使用可能让用户感觉尴尬的术语或他们无法理解的语言 避免使用有诱导性的问题 尽可能保证问题是中性的 焦点小组 #\r非正式的评估方法 在界面设计之前和经过一段使用之后评估用户的需要和感受 是市场、政治和社会科学研究经常使用的方法 人数限制：由大约6到9个典型用户组成 如在评估大学的网站时，可考虑由行政人员、教师和学生们组成3个分别的焦点小组 主持人工作 事先列出一张讨论问题和数据收集目标的清单 保持所谈论的内容不离题 保证小组的每个成员都积极参与谈论 讨论结果的分析报告 焦点小组存在风险 询问用户-问卷调查 #\r问卷调查是用于搜集统计数据和用户意见的常用方法。\n问卷设计原则 #\r问题明确，具体 在可能时，采用封闭式问题并提供充分的答案选项 对于征求用户意见的问题，应提供一个“无看法”的答案选项 注意提问次序，先提出一般化问题，再提出具体问题 避免使用复杂的多重问题 在使用等级标度时，应设定适当的等级范围，并确保它们不重叠 避免使用术语 明确说明如何完成问卷 既要做到紧凑，也应适当留空 问题类型 #\r常规问题 年龄、性别、职业、居住地、应用计算机的经验等 自由回答问题 量化分级问题 多选题 用户满意度调查表 QUIS #\rQUIS: questionnaire for user interaction satisfaction\n使用9级标度 内容：\n界面细节（如符号的易读性和屏幕显示的布局设计） 界面对象（如具有象征意义的图标） 界面行为（如为用户经常使用的操作设置的快捷方式） 任务表达（如适当的术语和屏幕显示顺序） 问卷组织 #\r问卷调查中的两个关键问题 如何寻找有代表性的用户 如何达到合理的回复率 有助于提高回复率的措施：\n精心设计问卷，避免用户因为厌烦而拒绝回复 参照QUIS，提供简要描述，说明用户若没有时间完成整份问卷，可以只完成简短的部分 提供一个带有回复地址并粘好了邮票的信封 解释为什么要进行这些问卷调查，并说明将为参与者保密 在发出问卷之后，通过后续邮件、电话或电子邮件联系参与者 采取一些激励措施（如有偿调查等） 进行小规模测验 询问专家-认知走查 #\r逐步检查使用系统执行任务的过程，从中找出可用性问题。 无需用户参与 主要目标是确定使一个系统如何易于学习 试图想象出人们在第一次使用某个产品时的想法以及所采取的动作，它的大作流程是怎样的 评估的具体过程就是把用户在完成这个功能时所做的所有动作讲述成一个令人可以信服的故事 步骤 #\r标识并记录典型用户的特性 基于评估重点，设计样本任务 制作界面原型（或界面描述），明确用户执行任务的具体步骤 由设计人员和专家级评估人员（一位或多位）共同进行分析 评估人员结合应用的上下文，逐步检查每项任务的操作步骤 正确的操作对于用户是否足够明显？（可预见） 用户能否注意到正确的操作？ （可理解） 能否正确解释操作的响应？（可解释） 在完成逐步检查之后，汇总关键信息 修改设计，更正发现的问题 优缺点 #\r优点：\n不需要用户参与 不需要可运行的原型 能找出非常具体的用户问题 缺点： 工作量大，非常费时 关注面有限，只适合于评估易学习性 询问专家-启发式评估 #\r一种灵活而又相当廉价的评估方式。由可用性专家完成。\n步骤 #\r彻底检查界面 将界面与启发式规则进行对比 列举可用性问题 应用启发式规则，对每个问题进行解释与确认 严重性分类 #\r决定严重性的因素 #\r频率 影响 持续时间 严重性等级 #\r不严重就不修复，严重就修复。\n优缺点 #\r优点 不涉及用户，限制少 成本低、快捷 缺点 专家少 专家不完美。可能会有虚假警报 友情提醒 #\r邀请多个评估专家，3-5 个为宜 使用用户测试代替启发式评估 用户测试才是可用性的Gold Standard 观察人员可以帮助评估专家 ","date":"22 December 2024","externalUrl":null,"permalink":"/posts/%E4%BA%BA%E6%9C%BA%E4%BA%A4%E4%BA%92/lec-6-%E8%AF%84%E4%BC%B0%E6%8A%80%E6%9C%AF-%E8%AF%A2%E9%97%AE%E7%94%A8%E6%88%B7%E4%B8%8E%E4%B8%93%E5%AE%B6/","section":"","summary":"有目的的对话过程。 问卷调查是用于搜集统计数据和用户意见的常用方法。 QUIS: questionnaire for user interaction satisfaction 内容： 有助于提高回复\u0026hellip;","title":"Lec-6 评估技术-询问用户与专家","type":"posts"},{"content":"\r背景 #\r观察用户怎样工作，很重要 用户口头描述可能不客观、不完整、不真实 用户会忽略细节 观察用户是所有可用性方法中最简单的方法 观察用户适用于开发的任何阶段 观察方式 #\r真实环境观察 观察者可以是参与者 重点是应用的上下文 受控环境观察 观察者不能参与 重点是研究用户执行任务的细节 二者差别不大（？）。两者经常互为补充、互相参考。\n以下是具体的观察方法。\n直接观察 #\r实验室观察 #\r在专门为可用性测试而安装配置的固定设备的环境下进行的观察。\n布局 #\r测试区、观察区\n二者分开，防止互相干扰。\n还可以让用户坐在家里测试。\n优缺点 #\r优点：提供了可控且一致的评估环境\n缺点：\n人为环境，不自然。可能降低测试结论的一般性。 不利于观察多人之间的协作 实际问题 #\r地点选择 设备安装 录面部表情 录交互过程 录肢体语言 测试设备 文档准备 协议书：说明测试目的、时间、用户权利等细节 脚本：用户要执行什么任务 现场观察 #\r在用户的实际环境中观察用户在使用软件时的情况。\n是发现同使用环境有关的问题的最佳手段\n问题清单 #\r明确初步的研究目标和问题 选择一个框架指导观察 决定数据记录方式 笔记、录音、摄像，还是三者结合 确保设备到位并能正常工作 评估后，尽快与观察者或被观察者共同检查所记录的笔记和其他数据 研究细节，找出含糊之处 人的记忆能力是有限的，最好24小时内回顾数据 数据记录时，应区分个人意见和观察数据 明确标注需要进一步了解的事项 培养良好的合作关系 取得被观察对象的认可和信任 避免只关注某些人，应注意小组的所有成员 处理敏感问题 避免让观察对象产生被冒犯的感觉 注重团队协作 通过比较不同评估人员的记录，得到更为可信的数据 应从不同的角度进行观察，避免只专注于某些特定行为 注意事项 #\r观察人员自始至终应尽量保持安静 让用户感觉不到观察人员的存在 保证用户操作和平时工作的状态一样 当用户的操作令观察人员无法理解时 需要打断用户，请他对所做的某些操作进行解释 或把用户莫名其妙的操作行为记录下来 观察初期，应该拒绝用户的任何帮助请求 希望观察用户在没有系统专家指点的情况下如何操作 待评估完成后为用户提供适当帮助 间接观察 #\r日志和交互记录 #\r适用场合 #\r直接观察可能影响用户 或者评估人员无法在现场进行研究 可根据搜集到的数据，推断实际情形，并找出可用性和用户体验方面的问题 优点 #\r体现了用户是如何完成真实任务的 使得从工作在不同环境下的大量用户那里自动收集数据变得相当容易 适用于用户分散、无法当面测试的情形 如互联网应用和网站设计项目等 观察框架 #\r用于组织观察活动和明确观察重点。因为观察过程中发生的事件都非常复杂且变化迅速。\nGoetz and Lecomfte框架 #\r关注事件的上下文、涉及的人员和技术\nRobson 框架 #\r有助于组织观察和数据搜集活动\n观察中的问题 #\r不知道用户在想什么 只能根据观察结果揣测 解决方法：边做边说\n要求被测试人说出自己的想法以及想要做的事情 帮助观察人员了解他们的思考过程 当用户沉默时，观察人员可以提醒用户 优点：简单、只需要很少的专业技术 缺点：不自然，可能改变人们执行任务的方式 观察与访谈结合 #\r观察方法只能展示用户做了什么，而无法知道用户为什么这样做 结合访谈 让用户面对记录数据时应非常小心，避免让用户产生被监视的想法 ","date":"22 December 2024","externalUrl":null,"permalink":"/posts/%E4%BA%BA%E6%9C%BA%E4%BA%A4%E4%BA%92/lec-5-%E8%AF%84%E4%BC%B0%E6%8A%80%E6%9C%AF-%E8%A7%82%E5%AF%9F%E7%94%A8%E6%88%B7/","section":"","summary":"\r\n\r\n\u003ch2 class=\"relative group\"\u003e观察方式 二者差别不大（？）。两者经常互为补充、互相参考。 \u0026mdash; 以下是具体的观察方法。 在专门为可用性测试而安装配置的固定设备的环境下进行的观察。 测试区、观察区 二者分开，防止互相干扰。 \u0026hellip; \r\n    \u003cdiv id=\"%E8%A7%82%E5%AF%9F%E6%96%B9%E5%BC%8F-%E4%BA%8C%E8%80%85%E5%B7%AE%E5%88%AB%E4%B8%8D%E5%A4%A7%E4%B8%A4%E8%80%85%E7%BB%8F%E5%B8%B8%E4%BA%92%E4%B8%BA%E8%A1%A5%E5%85%85%E4%BA%92%E7%9B%B8%E5%8F%82%E8%80%83-----%E4%BB%A5%E4%B8%8B%E6%98%AF%E5%85%B7%E4%BD%93%E7%9A%84%E8%A7%82%E5%AF%9F%E6%96%B9%E6%B3%95-%E5%9C%A8%E4%B8%93%E9%97%A8%E4%B8%BA%E5%8F%AF%E7%94%A8%E6%80%A7%E6%B5%8B%E8%AF%95%E8%80%8C%E5%AE%89%E8%A3%85%E9%85%8D%E7%BD%AE%E7%9A%84%E5%9B%BA%E5%AE%9A%E8%AE%BE%E5%A4%87%E7%9A%84%E7%8E%AF%E5%A2%83%E4%B8%8B%E8%BF%9B%E8%A1%8C%E7%9A%84%E8%A7%82%E5%AF%9F-%E6%B5%8B%E8%AF%95%E5%8C%BA%E8%A7%82%E5%AF%9F%E5%8C%BA-%E4%BA%8C%E8%80%85%E5%88%86%E5%BC%80%E9%98%B2%E6%AD%A2%E4%BA%92%E7%9B%B8%E5%B9%B2%E6%89%B0-\" class=\"anchor\"\u003e\u003c/div\u003e\r\n    \r\n    \u003cspan\r\n        class=\"absolute top-0 w-6 transition-opacity opacity-0 ltr:-left-6 rtl:-right-6 not-prose group-hover:opacity-100\"\u003e\r\n        \u003ca class=\"group-hover:text-primary-300 dark:group-hover:text-neutral-700\"\r\n            style=\"text-decoration-line: none !important;\" href=\"#%E8%A7%82%E5%AF%9F%E6%96%B9%E5%BC%8F-%E4%BA%8C%E8%80%85%E5%B7%AE%E5%88%AB%E4%B8%8D%E5%A4%A7%E4%B8%A4%E8%80%85%E7%BB%8F%E5%B8%B8%E4%BA%92%E4%B8%BA%E8%A1%A5%E5%85%85%E4%BA%92%E7%9B%B8%E5%8F%82%E8%80%83-----%E4%BB%A5%E4%B8%8B%E6%98%AF%E5%85%B7%E4%BD%93%E7%9A%84%E8%A7%82%E5%AF%9F%E6%96%B9%E6%B3%95-%E5%9C%A8%E4%B8%93%E9%97%A8%E4%B8%BA%E5%8F%AF%E7%94%A8%E6%80%A7%E6%B5%8B%E8%AF%95%E8%80%8C%E5%AE%89%E8%A3%85%E9%85%8D%E7%BD%AE%E7%9A%84%E5%9B%BA%E5%AE%9A%E8%AE%BE%E5%A4%87%E7%9A%84%E7%8E%AF%E5%A2%83%E4%B8%8B%E8%BF%9B%E8%A1%8C%E7%9A%84%E8%A7%82%E5%AF%9F-%E6%B5%8B%E8%AF%95%E5%8C%BA%E8%A7%82%E5%AF%9F%E5%8C%BA-%E4%BA%8C%E8%80%85%E5%88%86%E5%BC%80%E9%98%B2%E6%AD%A2%E4%BA%92%E7%9B%B8%E5%B9%B2%E6%89%B0-\" aria-label=\"锚点\"\u003e#\u003c/a\u003e\r\n    \u003c/span\u003e        \r\n    \r\n\u003c/h2\u003e\r\n","title":"Lec-5 评估技术-观察用户","type":"posts"},{"content":"std::optional std::tuple std::any\n","date":"21 December 2024","externalUrl":null,"permalink":"/posts/c++%E6%8B%BE%E9%81%97/%E4%B8%89%E5%89%91%E5%AE%A2/","section":"","summary":"std::optional std::tuple std::any","title":"三剑客","type":"posts"},{"content":"\r输入、输出处理 #\r用流替代 sprintf / sscanf #\rC++如何理解 sprintf 函数 ，寻找更好的替代方案_c++ sprintf-CSDN博客\n","date":"12 December 2024","externalUrl":null,"permalink":"/posts/c++%E6%8B%BE%E9%81%97/%E6%B5%81/","section":"","summary":"","title":"流","type":"posts"},{"content":" std::mutex std::condition_variable std::unique_lock std::atomic 参考 #\rC++11多线程 unique_lock详解_uniquelock-CSDN博客 C++11多线程条件变量std::condition_variable详解（转 ）_while (!ready) cv.wait(lck);-CSDN博客 【C++入门到精通】condition_variable（条件变量）C++11 [ C++入门 ]_c++ condition variable-CSDN博客 C++ 标准库 atomic | 菜鸟教程\n","date":"11 December 2024","externalUrl":null,"permalink":"/posts/c++%E6%8B%BE%E9%81%97/%E9%94%81%E4%B8%8E%E6%9D%A1%E4%BB%B6%E5%8F%98%E9%87%8F/","section":"","summary":"","title":"锁与条件变量","type":"posts"},{"content":"\r可重载的运算符 #\r大部分运算符都可重载：\n双目算术运算符 + (加)，-(减)，*(乘)，/(除)，% (取模) 关系运算符 ==(等于)，!= (不等于)，\u0026lt; (小于)，\u0026gt; (大于)，\u0026lt;=(小于等于)，\u0026gt;=(大于等于) 逻辑运算符 ||(逻辑或)，\u0026amp;\u0026amp;(逻辑与)，!(逻辑非) 单目运算符 + (正)，-(负)，*(指针)，\u0026amp;(取地址) 自增自减运算符 ++(自增)，\u0026ndash;(自减) 位运算符 | (按位或)，\u0026amp; (按位与)，~(按位取反)，^(按位异或),，\u0026laquo; (左移)，\u0026raquo;(右移) 赋值运算符 =, +=, -=, *=, /= , % = , \u0026amp;=, |=, ^=, \u0026laquo;=, \u0026raquo;= 空间申请与释放 new, delete, new[ ] , delete[] 其他运算符 ()(函数调用)，-\u0026gt;(成员访问)，,(逗号)，[](下标) 所以，只需要记住不可重载的：\n.：成员访问 .*：成员指针的成员访问 ::: 域运算符 ?:: 三目运算符 还有，不建议重载的：\n\u0026amp;\u0026amp;, ||: 重载会影响短路机制 改变原运算符含义的。比如 + 重载成减法 改变运算符的优先级、结合方向或操作数 只能用成员函数重载的：\n=, (), [], -\u0026gt; 类内重载 #\r类内重载，重载函数作为类的成员函数。运算符的操作数（中的第一个）隐含了 this 指针。\n比如对 Test 类的运算符进行重载，可以实现如下合法运算：\nclass Test{...}; Test t, s; t + s; t + 1; t + \u0026#34;test\u0026#34;; !t; *t; 注意：\n= [] () -\u0026gt; 只能类内重载 这四个运算符情况比较特殊。\n对于 = 赋值运算符： 我们知道，编译器会隐式地定义赋值操作符重载函数。如果我们在类外又进行重载，就会发生二义性。因为类外的所谓重载函数，比如通过友元实现，并不是这个类的成员函数。\n所以编译器提供的函数，和我们类外声明的函数会同时存在。\n在发生赋值运算的时候，就会产生二义性。虽然这种代码在此之前就会编译不过。\n对于 [] () -\u0026gt;： 类外重载能为我们提供什么？可以让第一个参数不是 this 指针。\n而这三个操作符，第一个参数一定必须要是 this，否则会出现下面这堆畸形儿：\nMyArr arr; 5[arr]; MyFunc func; char c = \u0026#39;0\u0026#39;; c(func, 6); MyObject obj; \u0026#34;wtf\u0026#34;-\u0026gt;obj; 当然，= 操作符也是一样的。\n可以总结为：这四个操作符，必须保证参数的顺序。特别地，对于 =，还要避免二义性。 类外重载 #\r对于一目运算符，类内重载完全够用了。但是对于二目运算符存在这种情况：1 + t 以及 cout\u0026lt;\u0026lt;t。这是类内重载无法匹配的，因为类内重载中 this 默认为第一个参数。所以此时需要类外重载。\nclass Test{ friend Test operator+ (const int a, const Test b); }; Test operator+ (const int a, const Test b); 也可以不用友元函数实现，但要提供对应成员的 get / set 方法。\n注意：\n流运算符、第一个参数不为 this 指针的二目运算符，只能在类外重载 叫成“类外重载”其实有误导性。因为无论是通过友元函数，还是 Getter/Setter 方法，我们声明的新的运算符重载函数不是类的成员函数 写法细节 #\r这里只提供比较特殊的写法细节。\n区分单目和双目 #\r相同字符的运算符可能有两种含义，比如 - 是减法或者负号, * 是乘法或者解引用。重载时怎么区分呢？\n既然是重载，同名函数要区分开来自然是靠参数的对应关系。单目运算符对应的函数接受一个参数，双目两个。\nT operator-(const T x); T operator-(const T x, const T y); 流运算符 #\r流运算符可以用来 cin 和 cout 输入输出。当然也可以对其他流进行重载。\n要引入 iostream 头文件，并且只能在类外重载。\nistream\u0026amp; operator\u0026gt;\u0026gt;(istream \u0026amp;stream, T \u0026amp;t) { stream \u0026gt;\u0026gt; t.x; return stream; } ostream\u0026amp; operator\u0026lt;\u0026lt;(ostream \u0026amp;stream, T \u0026amp;t) { stream \u0026lt;\u0026lt; t.x; return stream; } 赋值运算符 #\r默认重载 #\r编译器默认会提供一个赋值运算符重载函数。\n逐个成员赋值，即逐个调用它们的赋值运算符函数 对含有对象成员的类，该定义是递归的 warning #\r有问题，还待研究\n赋值运算符是唯一一个不能被派生类继承的运算符函数。\n原因：\n基类的赋值操作不一定适用于派生类。比如派生类新增了成员。 编译器还是会生成一个默认的赋值号函数。二者可能会冲突。 class Base{ Base\u0026amp; operator= (int other) {} }; class Derived: public Base{ // Base::operator= (int other) {} } 复制赋值 #\r处理自赋值 返回引用，以便 a = b = c = d 这种语句 // 复制赋值 T\u0026amp; operator=(const T\u0026amp; other) { // 防止自赋值 if (this == \u0026amp;other) return *this; // 假设 *this 保有可重用资源，例如一个在堆的缓冲区分配的 mArray if (size != other.size) // *this 中的存储不可复用 { temp = new int[other.size]; // 分配存储，如果抛出异常则等同于什么也不做 delete[] mArray; // 销毁 *this 中的存储 mArray = temp; size = other.size; } std::copy(other.mArray, other.mArray + other.size, mArray); return *this; } 移动赋值 #\r移动赋值和上面的注意点是一样的，但要额外注意：\n使 other 遗留在合法状态 // 移动赋值 T\u0026amp; operator=(T\u0026amp;\u0026amp; other) noexcept { // 防止自赋值 if (this == \u0026amp;other) return *this; // delete[]/size=0 也可以 delete[] mArray; // 释放 *this 中的资源 mArray = std::exchange(other.mArray, nullptr); // 令 other 遗留在合法状态 size = std::exchange(other.size, 0); return *this; } 自增自减 #\r用一个 dummy 参数 int 来标识后缀 后缀自增会返回旧的对象 // 前缀自增 X\u0026amp; operator++() { // 实际上的自增在此进行 return *this; // 以引用返回新值 } // 后缀自增 X operator++(int) { X old = *this; // 复制旧值 operator++(); // 前缀自增 return old; // 返回旧值 } 参考 #\rCppReference\n为什么有的操作符重载函数只能是成员函数?_为什么赋值运算符只能作为成员函数进行重载-CSDN博客\n","date":"5 December 2024","externalUrl":null,"permalink":"/posts/c++%E6%8B%BE%E9%81%97/%E8%BF%90%E7%AE%97%E7%AC%A6%E9%87%8D%E8%BD%BD/","section":"","summary":"大部分运算符都可重载： | 双目算术运算符 | 加)，-(减)，*(乘)，/(除)，% (取模) | | \u0026mdash;\u0026mdash; | 关系运算符 | ==(等于)，!= (不等于)， (大于)，=(大于等于) \u0026hellip;","title":"运算符重载","type":"posts"},{"content":"\r问题 #\r在训练机器学习作业的 ResNet 网络时，发现每一个 epoch 之前都会卡上十几二十秒才开始 模型真正的训练。具体表现如下：\n每个 epoch 的 tqdm 进度条之间要卡十几秒才会出现 显卡占用率时高时低，没有全力干活 原因 #\r一句话概括，是每个 epoch 前数据读取到内存再到显存占用了绝大部分时间。\n看下面两张图，时间都花到读数据了，显卡基本全程摸鱼。\n详细来说，在每个 epoch 开始之前，dataloader 从传入的 dataset 中通过 getitem，将初始化时准备好的数据返回。\nclass MyDataset(Dataset): ... def __getitem__(self, idx): image = self.images[idx] label = self.labels[idx] if self.transform: image = self.transform(image) return image, label 而且，这里 transform 将图像转换成 tensor 也花了不少时间。这种与数据增强无关的 transform 显然可以提前处理好。但这里每次读取都要 transform 一遍，很浪费。\n再来看 dataloader：\ntrainLoader = Data.DataLoader(trainSet, batch_size=batch_size, shuffle=True, num_workers=16, drop_last=True) windows 上设置 num_workers 不为 0 时会让数据提供给 cpu，也就是到内存里去。这样我们 getitem 返回的数据又被拷贝了一份。\n然后，在 epoch 中的训练里经过如下代码：\nfor batch, (x, y) in loop: x, y = x.cuda(), y.cuda() ... 内存里的数据又要拷到显存里，我们训练才得以正式开始。\n前前后后，一份数据被拷贝了三回啊三回。训练能不慢吗。\n解决 #\r小试牛刀 #\r把 dataloader 的 num_worker 设置为 0。直接将内存的数据拷到显存。这样已经能基本解决问题了。\n更快 #\r如果数据集如果不是太大，并且显存没有到捉襟见肘的地步时，提前将数据集读入显存显然是最省时的方案。\n先修改 dataset 类，在初始化的时候就进行一部分的 transform 以及读入显存。\nclass MyDataset(Dataset): ... def __init__(..., pre_transform=None, ...): self.all_data = [] self.all_label = [] ... foreach: data = ... label = ... if pre_transform: data = pre_transform(data) data = torch.tensor(data) self.all_data.append(data) self.all_label.append(label) ... self.all_data = torch.stack(self.all_data).cuda() self.all_label = torch.tensor(self.all_label).cuda() ","date":"2 December 2024","externalUrl":null,"permalink":"/posts/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/pytorch-dataloader-%E5%8A%A0%E9%80%9F/","section":"","summary":"在训练机器学习作业的 ResNet 网络时，发现每一个 epoch 之前都会卡上十几二十秒才开始 模型真正的训练。具体表现如下： 一句话概括，是每个 epoch 前占用了绝大部分时间。 看下面两张图，\u0026hellip;","title":"Pytorch DataLoader 加速","type":"posts"},{"content":"","date":"2 December 2024","externalUrl":null,"permalink":"/categories/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/","section":"","summary":"","title":"机器学习","type":"categories"},{"content":"","date":"28 November 2024","externalUrl":null,"permalink":"/categories/python/","section":"","summary":"","title":"Python","type":"categories"},{"content":"对于 Python 来说，环境管理有着十分甚至九分的作用。本文列出一些常用的虚拟环境管理方式，以供参考。\nConda #\r最常用的虚拟环境管理器。\nvenv #\rPython 自带的虚拟环境管理器。\n使用 VSCode ctrl + shift + p 呼出命令面板，搜索 Python: Create Environment。\n按步骤来就行。选择 venv 放哪个文件夹、有 requirements.txt 就选。\n","date":"28 November 2024","externalUrl":null,"permalink":"/posts/python/python-%E8%99%9A%E6%8B%9F%E7%8E%AF%E5%A2%83/","section":"","summary":"对于 Python 来说，环境管理有着十分甚至九分的作用。本文列出一些常用的虚拟环境管理方式，以供参考。 最常用的虚拟环境管理器。 Python 自带的虚拟环境管理器。 \u003ccode\u003ectrl hift \u003c/code\u003e 呼出\u0026hellip;","title":"Python 虚拟环境","type":"posts"},{"content":"\r背景 #\r评估是设计过程的组成部分 评估 #\r评估是系统化的数据搜集过程 用户在与原型、应用程序等交互时收集关于用户体验方面的信息，从而改进其设计 评估侧重系统的可用性和用户体验 目的不是设法理解用户，而是评估特定用户在一个特定的环境背景中如何使用一个系统来执行一个特定的任务 评估的四 W #\rWhy：肯定是要设计一个好的交互系统呀 What：交互系统的可用性和用户体验 Where：取决于评估的对象 When：取决于产品类型。可以在研发前，也可以在完成产品后。 评估原则 #\r评估应当依赖产品的用户 评估与设计应当结合进行 评估应该在用户的实际工作任务和操作环境下进行 评估要选择有广泛代表性的用户 评估范型 #\r“范型”与“技术”：\n范型与具体学科相关，对如何评估有很大影响：可用性测试是一种评估范型 每种范型有特定的技术：可用性测试的技术有观察、问卷调查、访谈等 快速评估 #\r设计人员非正式地向用户或顾问了解反馈信息，以证实设计构思是否符合用户需要。\n基本特征：快速\n可在任何阶段进行 强调 “快速了解”，而非仔细记录研究发现 得到的数据通常是非正式、叙述性的 是设计网站时常用的方法 可用性测试 #\r基本特征：在评估人员的密切控制之下实行\n评测典型用户执行典型任务时的情况。并进行量化 缺点：测试用户的数量通常较少、不适合进行细致的统计分析 实地研究 #\r理解用户的实际工作情形以及技术对他们的影响。\n基本特征：在自然工作环境中进行\n探索新技术的应用契机 确定产品的需求 促进技术的引入 评估技术的应用 难点：\n如何不对受试者造成影响 控制权在用户，很难预测即将发生和出现的情况 预测性评估 #\r研究人员通过想象或对界面的使用过程进行建模。\n基本特征：用户可以不在场；快速成本低\n专家们根据自己对典型用户的了解预测可用性问题的可用性评估 逐步通过场景或基于问题回答的走查法 用于比较相同应用不同界面的原型法，如使用Fitts定律预测使用设备定位目标的时间 评估技术 #\r似乎今年 PPT 上没有。但是这肯定很重要，毕竟下列评估方法就是后面几节讲的内容。\n内容 #\r观察用户 询问用户意见、专家意见 用户测试 基于模型和理论评估 区分评估技术的因素 #\r评估在周期中的位置：设计早期阶段的评估更快速、便宜 评估的形式：实验室环境 or 工作环境 技术的主客观程度 技术越主观，受评估人员知识的影响越大，如认知走查等 测量的类型：与技术的主客观性有关 主观技术：定性数据 客观技术：定量数据 提供的信息 低层信息：这个图标是可理解的吗？ 高层信息：这个系统是可用的吗？ 响应的及时性 边做边说法可及时记录用户行为 任务后的走查取决于对事件的回忆 干扰程度：直接响应测量可能会影响用户表现 所需资源：设备、时间、资金、参与者、评估人员的专业技术及环境等 评估方法组合 #\r评估方法的组合取决于项目待评估的具体特性。\n常用组合 启发式评估+边做边说等用户测试技术 专家可通过启发性评估排除显而易见的可用性问题 重新设计后，经用户测试，反复检查设计的效果 访谈+问卷调查 先对小部分用户进行访谈，确定问卷中的具体问题 启发式评估 vs.用户测试 前者不需要用户参与 二者发现的可用性问题不同，可以互补 人机交互的实证研究方法 #\r研究假设 #\r假设是一种可以通过实证研究直接检验的精确问题陈述 一个具体的研究假设奠定了一个实验以及统计学显著性检验的基础 零假设：不同的实验条件不会产生差异 备择假设：与零假设相反\n目标是找到统计学证据来反驳或否定零假设，以支持备择假设。\n好的假设：\n用精确而清晰的语言提出 专注于一个可以在单次实验中检验的问题 明确说明实验的对照组或实验条件 包括研究的自变量和因变量（必须明确定义） 自变量：研究者感兴趣的因素或因变量变化的可能“原因” 因变量：研究者感兴趣的结果或效果\n实验构成 #\r实验条件：自变量的取值、其他需要确定的因素 实验单位：应用实验条件的对象。通常是有指定特征的人类受试者 分配方式：将实验单位分配到不同实验条件的方式。一般采取随机化的方式。 举例：\n假设：传统QWERTY键盘比DVORAK键盘的打字速度快 实验条件：键盘的类型（两种） 实验单位：无两种键盘使用经验的受试者 分配：抛硬币 实验设计 #\r真正的实验具有如下特点：\n以至少一个可检验的研究假设为基础，并旨在验证它 通常至少有两种条件（实验条件和对照条件）或组（实验组和对照组） 因变量通常使用定量测量 通过各种统计显著性检验对结果进行分析 以消除潜在偏差为目标来设计和进行 具备不同的参与者样本，在不同的时间，不同的地点，由不同的参与者进行复现 组间设计和组内设计 #\r组间设计： 每个参与者只暴露在一种实验条件下 参与组的数量直接对应于实验条件的数量。 避免了学习效应和疲劳问题 但同时在参与者总数不变的前提下也减少了采样的数量。 适合简单的任务、个体差异小的任务和受学习效果影响较大的任务。此外，某些实验必须采用组间设计，如实验条件为新手用户和老手用户的实验等。 组内设计： 每个参与者暴露在所有实验条件下，只有一个参与组。 它可以充分利用每个参与者来获取更多的信息 学习效应和疲劳问题。 适合个体差异较大、学习效果不太容易受到影响的任务、或目标参与者群体很小的任务。 多个自变量的实验 #\r当一个实验调查一个以上的自变量或因素时，广泛采用析因分析。\n可以同时调查所有自变量的影响以及多个变量之间的交互影响 析因设计中条件的数量由自变量的总数和每个自变量的取值决定 说白了，就是将每个自变量的取值进行排列组合。对于结果，进行列联分析就行。\n使用组内设计和组件设计均可，难点在于平衡实验中的顺序和条件。\n如果同时使用组内设计和组间设计，称之为裂区设计。\n","date":"25 November 2024","externalUrl":null,"permalink":"/posts/%E4%BA%BA%E6%9C%BA%E4%BA%A4%E4%BA%92/lec-4-%E8%AF%84%E4%BC%B0%E7%9A%84%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/","section":"","summary":"\u0026mdash; \u0026mdash; “范型”与“技术”： 1. 范型与具体学科相关，对如何评估有很大影响：可用性测试是一种评估范型 2. 每种范型有特定的技术：可用性测试的技术有观察、问卷调查、访谈等 设计人员非正式地向\u0026hellip;","title":"Lec-4 评估的基础知识","type":"posts"},{"content":"不知道为什么没有 Lec-2，往年这个标题是 Lec-2 来着，但是今年老师发的 PPT 直接跳过 2 了。具体什么情况无从知晓，因为上课根本没听嘛。\n交互框架 #\r交互框架是提供理解或定义某种事务的一种结构。\n说白了，就是给交互建模得到的框架。\nECC 框架 - 执行 / 评估活动周期 #\r一种具体的交互框架。PPT 上说是最有名的。\n模型基础 #\rECC 定义了活动的四个组成部分：\n目标(Goal) 执行(Execution) 客观因素(World) 评估(Evaluation) 目标就是交互要达到的目的，意图可以理解为实现目标的一系列活动。一个目标可以对应多个意图。目标≠意图(Intention)\n图示 #\r图中，每个循环代表一个动作。\n执行阶段：\n形成目标 形成意图 明确动作 执行动作 评估阶段 感知系统状态 解释系统状态 评估输出 作用与意义 #\rECC 模型可以解释为什么有些交互设计得有问题。因为我们可以从两个阶段进行分析了。\n在执行阶段出现问题，叫执行隔阂；\n用户为达到目标而做出的动作，与系统允许的动作之间有差别 评估阶段，评估隔阂。\n系统状态的实际表现，与用户预期之间有差别 因此，我们分别能从两个阶段知道：\n如何才能够使用户简单地确定哪些活动是被允许的 如何确定系统是否处于期望的运行状态等问题 也即 ECC 模型的意义所在。圆上这段第一句话了。 扩展 ECC 模型 #\rEEC模型不能描述人与系统通过界面进行的通信。\n图示 #\r扩展 ECC 模型将交互抽象成了语言的翻译过程。\nS I O U 意义如下：\n$S$ $U$ $I$ $O$ 系统 用户 输入 输出 内核（核心）语言 任务语言 输入语言 输出语言 箭头表示翻译过程；图示左侧是系统，右侧是用户。\n作用 #\r让设计人员更好地设计系统（废话），具体来说，要简化两个过程的翻译：\n执行阶段：\n应保证从输入到系统的翻译是容易的。即 $I\\rightarrow S$ 过程。 评估阶段： 应保证用户观察系统输出是容易的。即 $O\\rightarrow U$ 过程。 设计目标\n可用性目标 #\r背景 #\r省流：用户在变，用户的观念在变，开发方式在变。\n这能考？\n指标 #\r易学性、易记性、安全性、效用性和高效率。\n应该很重要。\n易学性 learnability #\r使用系统的难易。\n关键问题是：用户准备花多少时间，学习并能够执行某种任务。\n请君脑补一下学习曲线的图。\n易记性 memorability #\r记住如何使用的难易。\n易记性的影响因素大致如下：\n意义：使用有意义的图标、命令名和菜单； 位置：将特定对象放在某个特殊位置； 分组：对事物按照逻辑进行恰当的分组； 惯例：尽可能使用通用的对象或符号； 冗余：使用多种感知通道对信息进行编码。 以及使用启发。即通过用户已有的经验帮助提高易记性。e.g. Adobe 全家桶\n效用性 utility #\r产品是否提供了正确的功能。\n比如，计算器只能算加减法（\n高效率 efficiency #\r产品对用户执行任务的支持程度\n人话，就是用户的熟练度与完成任务效率的关系。\n注意，并不是指产品的运行效率！！！\n（这图年龄估计比我大了。。。）\n安全性 safety #\r避免用户发生危险和陷入不好的情形\n第一个层面和工效学相关，如在特殊环境中允许远程操控计算机 第二个层面指帮助任何用户在任何情况下避免因偶然执行不必要的行动而造成的危险 减少按钮等组件被误启动的风险 提供出错时的恢复方法 用户体验目标 #\r这主要包括用户使用交互系统的主观满意度。\n用户体验 vs 可用性 #\r主观 vs 客观 矛盾：二者有时不可兼得。 许多玩家喜欢找最具挑战、非简单的游戏：违反可用性 设计 既安全又有趣的过程控制系统 是不可能的。\n矛盾如何化解-超越可用性 #\r应该更多地关注用户体验而非可用性 以说服为目的的设计关键主要是采用巧妙和令人愉快的方式令人信任和感到舒服 简易可用性工程 #\r理解就行\n以提高产品的可用性为目标的先进的产品开发方法论。\n过程 #\r完整过程（直接忽略）：\n了解用户 竞争性分析 设定可用性目标 用户参与的设计 迭代设计 产品发布后的工作 简化过程（四种主要技术）：\n用户和任务观察 了解产品的目标用户 场景（scenario） 一种简便易行的原型 水平原型：重界面整体性，轻功能深度 垂直原型：重功能深度，轻界面整体性 简化的边做边说（thinking aloud） 最有价值！（上课的时候就做了） 启发式评估 让多个不同的人来进行经验性评估 5名专家能够发现约80%的可用性问题 设计规则 #\r设计规则是经验性的，需要灵活运用。\n基本规则 #\r可学习性：新用户能用它开始有效的交互并能获得最大的性能 灵活性：用户和系统能以多种方式交换信息 健壮性：在决定成就和目标评估方面对用户提供的支持程度 黄金规则 #\r尽可能保证一致：一致性让界面变得熟悉和可预测。 符合普遍可用性：充分考虑用户操作的熟练程度（例如新手用户和专家用户）、年龄范围、身体状况（如是否有残疾）等多方面的不同需求。 提供信息丰富的反馈：对常用操作，则反馈信息可以相对简短；对不常用操作，系统的反馈信息就应该丰富一些。 设计说明对话框以生成结束信息：让用户知道什么时候他们已经完成了任务。 预防并处理错误：用户错误能够在清晰的指导下进行恢复。 让操作容易撤销：减轻用户的焦虑情绪，并鼓励用户尝试新的选项。 支持内部控制点：鼓励用户成为行为的主动者而不是响应者。 减轻短时记忆负担：界面显示尽可能简单，要确保提供用户足够的学习代码、记忆操作方法和操作序列的时间，并提供适当的在线帮助信息。 十条启发式规则 #\r重要\n系统状态的可见度：对于用时较长的操作（如，长于 3−5 秒）,需要给出显式的反馈； 系统和现实世界的吻合：界面上的语言要使用用户熟悉的词汇、短语和概念，信息应当遵循自然的逻辑顺序出现； 用户享有控制权和自主权：对于由于错误而做出的选择，提供一个“返回方法”； 一致性和标准化：产品内部对同一功能使用的术语和形式一致； 避免出错：产品应当经过精细设计，减少高危操作，避免用户犯错； 依赖识别而非记忆：用户应当经常被提示，而不是被要求记住； 使用的灵活性和高效性：充分考虑不同类型用户的使用偏好和使用技巧； 审美感和最小化设计：少即是多； 帮助用户识别、诊断和恢复错误：提供明确的错误信息，以及用户可以采取的行动，而不是错误代码； 帮助和文档：提供帮助和文档，以便用户可以找到所需的信息。文档的表述应当是非技术的。 ","date":"25 November 2024","externalUrl":null,"permalink":"/posts/%E4%BA%BA%E6%9C%BA%E4%BA%A4%E4%BA%92/lec-3-%E4%BA%A4%E4%BA%92%E8%AE%BE%E8%AE%A1%E5%8E%9F%E5%88%99%E4%B8%8E%E7%9B%AE%E6%A0%87/","section":"","summary":"不知道为什么没有 Lec-2，往年这个标题是 Lec-2 来着，但是今年老师发的 PPT 直接跳过 2 了。具体什么情况无从知晓，因为上课根本没听嘛。 \u0026mdash; 交互框架是提供理解或定义某种事务的一种结\u0026hellip;","title":"Lec-3 交互设计原则与目标","type":"posts"},{"content":"\r术语 #\rHMI: Human-Machine Interaction MMI: Man-Machine Interaction HCI: Human-Computer Interaction MCI: Man CHI: Computer-Human Interaction UCD: User-Centered Design HF: Human Factors 人机交互的定义 #\rBy ACM\nHCI is a discipline concerned with the design, evaluation and implementation of interactive computing systems for human use and with the study of major phenomena surrounding them. HCI 是一门涉及人类使用的交互式计算系统的设计、评估和实施以及围绕它们的主要现象的研究的学科. HCI 研究内容 #\rU（使⽤用计算机的上下文） H（⼈人的特性） C（计算机系统和⽤用户接口架构） D（开发过程）（本课重点）保证产品开发/交互性能的有效性 D1：设计方法 D2：实现技术与工具 D3：评估技术 D4：示例系统和样例学习 HCI 是典型的交叉学科 #\r孤立地从一个学科出发不可能设计出有效的交互式系统\nHCI 重要性 #\r市场角度 #\r用户期望简单易用的系统 对设计低劣系统的容忍度越来越差 企业角度 #\r提高员工的生产效率 降低产品的开发成本 降低产品的后续支持成本 用户角度 #\r获得较高的主观满意度 减少时间、金钱、生命损失 ","date":"25 November 2024","externalUrl":null,"permalink":"/posts/%E4%BA%BA%E6%9C%BA%E4%BA%A4%E4%BA%92/lec-1-%E4%BA%BA%E6%9C%BA%E4%BA%A4%E4%BA%92%E6%A6%82%E8%BF%B0/","section":"","summary":"By ACM 孤立地从一个学科出发不可能设计出有效的交互式系统","title":"Lec-1 人机交互概述","type":"posts"},{"content":"\r起因 #\r","date":"21 November 2024","externalUrl":null,"permalink":"/posts/%E6%B8%B8%E8%AE%B0/%E5%8D%97%E4%BA%AC-%E5%B9%95%E5%BA%9C%E5%B1%B1-24-11/","section":"","summary":"","title":"南京-幕府山-24-11","type":"posts"},{"content":"","date":"21 November 2024","externalUrl":null,"permalink":"/categories/%E6%B8%B8%E8%AE%B0/","section":"","summary":"","title":"游记","type":"categories"},{"content":"\r前言 #\r考试必考。所以在网上找一些笔记，记下有价值的部分以供复习。\n继承和派生这对名词基本是一个意思，只是各自用语习惯不一样：\n继承 —— 基类 —— 派生类 派生 —— 基类 —— 派生类 OO 是 Java 学的，所以我倾向于第一种表达。\n继承权限 #\r继承方式 #\rC++ 很神奇地提供了三种继承方式：public、private 和 protected。\nclass parent{}; class child1: public parent{}; class child2: protected parent{}; class child3: private parent{}; 继承方式决定了基类成员在派生类中的访问权限，权限高于继承方式的会被限制。\n比如 protected 继承会将基类中 public 的成员变成 protected。\n修改基类成员的访问权限 #\r使用 using 关键字可以修改基类成员在派生类中的访问权限。权限提高和降低都没问题。\nclass parent{ protected: int element; }; class child{ public: using parent::element; // protected -\u0026gt; public private: using parent::element; // protected -\u0026gt; private } 成员覆盖 #\r继承中的成员覆盖问题，本质是作用域的问题。\n通过派生类访问成员时，首先会在派生类的作用域下寻找这个名字的成员。如果没找到，再到基类的作用域里找。\n主要注意以下情景：\n派生类同名成员变量访问权限低于基类时 parent{ public: int a; }; child{ private: int a; } child c; c.a; // cannot access a. c.parent.a; // ok 派生类与基类不会发生函数重载 parent{ void foo(int a); }; child{ void foo(double a); } child c; int a; c.foo(a); // double c.parent::foo(a); // int 构造函数 #\r构造函数无法继承。\n派生类默认会调用基类默认构造函数。\n要手动调用基类的构造函数实现初始化，必须在成员初始化表里调用。\nparent{ public: parent(){}; parent(int a){...}; } child{ public: child(int a, int b): parent(a), ...; } 否则（没有手动调用基类构造函数），派生类会调用基类默认构造函数。\n析构函数 #\r派生类无法显式调用基类的析构函数。\n至于调用顺序：派生类析构 之后 基类析构。与构造的顺序相反。\n虚函数 #\r基类的引用或指针可以引用或指向派生类对象。当调用这个指针或者引用的虚函数时，会调用派生类中定义的虚函数。\n前期绑定 #\r没用 virtual 修饰的函数，是前期绑定。\n编译时绑定 根据对象的静态类型 效率高、灵活性差 动态绑定 #\r用 virtual 修饰的函数，是动态绑定。\n运行时刻 依据对象的实际类型（动态） 灵活性高、效率低 需要用 virtual 显式指出 限制 #\r类的成员函数才可以是虚函数\n静态成员函数不能是虚函数 内联成员函数不能是虚函数 构造函数不能是虚函数 析构函数可以（往往）是虚函数 实现 #\r为每一个类的对象添加一个隐藏成员，这个成员是一个指向虚函数表的指针。\n而虚函数表存放了这个类所有的虚函数。如果虚函数在这个类中重定义了，表里就放重定义的函数，否则放基类的函数。\n关键字 #\rfinal #\r这个函数无法被重写。\nclass Base{ virtual void foo(int) final; }; class Derived: Base{ void foo(int); // wrong! foo is final }; override #\r显式声明这个函数是基类某个虚函数的重写，参数、返回值等属性必须完全一致（访问权限可以不一样）。\n是可选的关键字，也就是说，override 删掉也能跑。 但建议加上，以防止错误。\nstruct B { virtual void f1(int) const ; virtual void f2 (); void f3 () ; }; struct D: B { void f1(int) const override ; // correct void f2(int) override ; // wrong: parameter dosent match void f3 () override ; // wrong: f3 is not virtual void f4 () override ; // wrong: no func named f4 纯虚函数 #\r接口。基类函数只提供声明，不提供实现。派生类必须重写这个函数接口。\n在虚函数原型后增加 =0 来声明。\nclass Base{ virtual void foo() = 0; }; class Derived: Base{ void foo() override{ // implementation } } 缺省参数值 #\r不要重新定义继承而来的缺省参数值 缺省参数值是在编译期确定的（静态绑定），不会进行动态绑定。所以派生类在没指定缺省参数时，会根据当前指针的类型来静态确定缺省参数值。\nclass Base { virtual void foo(int x = 0) = 0; }; class Derived: Base{ void foo(int x = 1) { cout\u0026lt;\u0026lt;x; } }; Base* ptr = new Derived(); ptr-\u0026gt;foo(); // 0 ptr-\u0026gt;foo(100); // 100 Derived* ptr_d = new Derived(); ptr_d-\u0026gt;foo(); // 1 虚函数的小总结 #\r纯虚函数 只有函数接口会被继承 派生类必须继承函数接口 （必须）提供实现代码 一般虚函数 函数的接口及缺省实现代码都会被继承 派生类必须继承函数接口 可以继承缺省实现代码 非虚函数 函数的接口和其实现代码都会被继承 必须同时继承接口和实现代码 使用规范 #\r确定 public 继承，是真正意义的“is_a”关系 不要定义与继承而来的非虚成员函数同名的成员函数 明智地运用 private 继承 需要使用基类中的 protected 成员，或重载 virtual function 不希望一个基类被访问派生类的一方使用 多继承 #\rclass child: public parent1, private parent2, protected parent3 {}; 声明顺序 #\r基类的声明次序决定：\n对基类构造函数/析构函数的调用次序 对基类数据成员的存储安排 成员访问 #\r对于多继承中同名的成员，访问其成员时要加上类名和域解析符。\nchild: parent1, parent2{}; child c; c.parent1::a; c.parent2::a; 虚继承 #\r菱形继承中，派生类可能同时继承了有相同基类的两个类，这样派生类就会得到这个间接基类的两个副本。\n通过虚继承，派生类可以只保留一份间接基类的成员。\n虚基类的构造函数由最新派生出的类的构造函数调用 虚基类的构造函数优先非虚基类的构造函数执行 调用非虚基类构造函数时，重复的间接基类就不会被构造了 class grand{}; class parent1: public grand{}; class parent2: public grand{}; class child: public parent1, virtual public parent2{}; 内存模型：\n参考 #\rC++ 基础系列——继承与派生 - 锦瑟，无端 - 博客园\n图解C++菱形继承、虚继承对象的内存分布_菱形继承 虚函数内存结构图-CSDN博客\n","date":"21 November 2024","externalUrl":null,"permalink":"/posts/c++%E6%8B%BE%E9%81%97/oo-%E7%BB%A7%E6%89%BF%E4%B8%8E%E6%B4%BE%E7%94%9F/","section":"","summary":"考试必考。所以在网上找一些笔记，记下有价值的部分以供复习。 继承和派生这对名词基本是一个意思，只是各自用语习惯不一样： OO 是 Java 学的，所以我倾向于第一种表达。 C+神奇地提供了三种继承方式\u0026hellip;","title":"OO-继承与派生","type":"posts"},{"content":"\r空类默认提供的方法 #\rclass T {}; class T { T(); // 构造函数 T(const T\u0026amp;); // 拷贝构造 ~T(); // 析构函数 T\u0026amp; operator=(const T\u0026amp;); // 拷贝赋值 T *operator \u0026amp;(); // 取地址 const T* operator \u0026amp;() const; // 取地址 const 重载版 }; 最后两个函数比较怪。一个是返回非 const 的指针，另一个返回 const 的。在调用时，编译器如何决定调用哪个呢？\n注意函数后的 const 修饰符。这两个函数实际应该长这样：\nT *operator \u0026amp;(T *this); const T* operator \u0026amp;(const T *this); 是 this 指针的功劳。调用方是哪种就执行哪个。\nconst 与 static 成员 #\rstatic const 成员变量 #\r对于成员变量，变量会在编译期确定，并被放到程序静态区。运行时，这个成员和类与对象在内存上没有关系，但是要通过类名来访问。\nstatic const 只能修饰成员变量。在成员函数前面加 static const 的意义是对函数修饰 static，对函数返回值修饰 const。\nstatic 成员 #\rstatic 成员属于类，和对象没关系。\n初始化 #\r初始化需要在类的外部。因为在类的内部初始化实际上是对象的行为，而 static 变量是与对象无关的。\nclass Test{ public: static a = 1; // not allowed static constexpr int a = 1; // C++ 17 }; int Test::a = 1; // okay 使用与修改 #\r对于 private 的 static 变量，除了初始化，在类外无法访问。\n对 public 的变量，加上类限定符就可以访问了。\nconst 成员 #\r对于 const 成员变量没什么好说的，const 起到限定无法修改的作用。\n对 const 成员函数就有意思了。不过严格来说，就不该叫“const 成员函数”。\n有些成员函数不会对对象的属性进行修改，对这类函数可以在其声明后加上 const 限制。\nclass Test{ public: void get() const; } 其原理很简单，就是将成员函数的 this 指针加上 const 限定：\nvoid get(); \u0026lt;=\u0026gt; void get(Test *this); void get() const; \u0026lt;=\u0026gt; void get(const Test *this); 友元 #\r做朋友。破坏类原有的封装性，使外部能够在尽可能少的改动下，从一个类的外部访问这个类的私有成员。\n友元类 #\rA 指定 类B 是朋友。B 中就可以随意访问 A 的成员了。\n注意，友元类要处理声明顺序的问题，看代码第一行。\nclass B; // A 声明友元需要 B 的定义，B 也需要访问 A 的成员。所以先把 B 声明在这里，方便 A 使用。 class A { friend class B; private: int x; static int y; void foo(); }; class B { A a; void f() { a.x; A::y; foo(); } }; 友元函数 #\r无论哪种友元函数，都不是这个类的成员函数！！！\n首先是友元成员函数。类 A 和 类 B 的一个成员函数 foo 做朋友。函数内部能随意访问 A 的私有成员，但函数之外都不行。\n注意几点：\n依赖顺序，需要前向声明 foo 的参数只能是 A 的指针或者引用，因为此时 A 只是有了个名字，不知道占空间大小 friend 定义友元函数语句中，函数前要加类限定符 class A; class B{ void foo(A \u0026amp;a) { a.x; // okay } void f(A \u0026amp;a) { a.x; // invalid } } class A{ friend void B::foo(A \u0026amp;a); int x; }; 然后是友元全局函数。类 A 和外部函数 foo 做朋友。foo 能访问 A 所有东西。\n依赖顺序随意。当然，如果函数参数有类的话还是要先声明，如代码中的例子 函数参数包含类对象时，可以不为指针和引用 多用于实现类运算符重载 class A{ friend void foo(A a); }; void foo(A a) { } ","date":"20 November 2024","externalUrl":null,"permalink":"/posts/c++%E6%8B%BE%E9%81%97/oo-%E6%9D%82%E9%A1%B9/","section":"","summary":"\u003cdiv class=\"highlight\"\u003e\u003cpre tabindex=\"0\" class=\"chroma\"\u003e\u003ccode class=\"language-cpp\" data-lang=\"cpp\"\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e","title":"OO 杂项","type":"posts"},{"content":"\rRAII \u0026amp; 智能指针 #\rRAII #\rRAII： Resource acquisition is initialization\n将资源管理交给其本身的思想。\n尽量使用对象的生命周期来管理资源，初始化时调用构造函数进行资源分配，离开作用域时自动调用析构函数释放资源。而不是自己来管理资源的分配与释放。\n智能指针 #\r所以很自然想到智能指针：\ntemplate\u0026lt;class T\u0026gt; class auto_ptr{ public: auto_ptr(T *p=0):ptr(p) {} ~auto_ptr() { delete ptr; } T* operator-\u0026gt;() const { return ptr; } T\u0026amp; operator *() const { return *ptr; } private: T* ptr; } 这种手搓的是会出问题的。比如拷贝构造后，两个智能指针对象指向同一块内存，会导致这块内存被析构函数释放两次。\n标准库智能指针 #\r头文件：#include \u0026lt;memory\u0026gt;\nauto_ptr #\r和手搓的基本一样。代码不是很复杂的情况下用这个就行。\nunique_ptr #\r独占所有权的指针。就是说，unique_ptr 指向的内存只能被它一个人占有。同一时间内只会有一个 unique_ptr 指向同一块内存。\n这建立在你完全使用 unique_ptr 提供的接口的情况之上。也就是说完全有办法让两个 unique_ptr 指向同一块内存。\nC++14 以后，使用 std::make_unique 来创建 unique_ptr。\n特点是：\n不允许拷贝构造 支持移动语义 using int_ptr=std::unique_ptr\u0026lt;int\u0026gt;; int *ptr = new int(5); int_ptr p(ptr); int_ptr p_ = std::make_unique\u0026lt;int\u0026gt;(5); // In c++14 cout\u0026lt;\u0026lt; *p \u0026lt;\u0026lt; endl; // 5 int_ptr q = p; // you can not clone unique_ptr!!! int_ptr r(std::move(p)); // move semantic cout\u0026lt;\u0026lt; *r \u0026lt;\u0026lt; endl; // 5 int_ptr s(ptr); // this will cause double free!!! shared_ptr #\r含引用计数的指针。这样就可以实现多个指针指向同一对象了。\n当指向某内存的最后一个 shared_ptr 被释放以后才会释放这块内存。\n特点：\n有复制构造函数，支持共享所有权 支持移动语义 避免多次释放内存 using int_ptr=std::shared_ptr\u0026lt;int\u0026gt;; int *ptr = new int(5); int_ptr p(ptr); int_ptr p_ = std::make_shared\u0026lt;int\u0026gt;(5); // In c++ 14 int_ptr q = p; // ok :) 但还是无法解决循环引用的问题。要结合 weak_ptr 完成。\nweak_ptr #\r专门用来解决循环引用问题的智能指针，真气派。\n只能配合 shared_ptr 使用。简单来说就是一种不参与引用计数的 shared_ptr。\n所以 weak_ptr 可以从从一个 shared_ptr 或另一个 weak_ptr 对象构造。并且 weak_ptr 完全不负责资源管理，没有 RAII 的特性。\n青春版 goto #\r有时候用 goto 会使得分支结构变得简单，如下：\nif(check) { goto bad; } work(); return; bad: exception(); 但是 goto 不让用，这时候可以用 do_while(0) 代替：\ndo { if(check) { break; } work(); return; }while(0); exception(); ","date":"17 November 2024","externalUrl":null,"permalink":"/posts/c++%E6%8B%BE%E9%81%97/%E6%9D%82%E9%A1%B9/","section":"","summary":"RAII： Resource acquisition is initialization 将资源管理交给其本身的思想。 尽量使用对象的生命周期来管理资源，初始化时调用构造函数进行资源分配，离开作用域时\u0026hellip;","title":"杂项","type":"posts"},{"content":"向函数传不定个数的参数就是可变参数。标识符为 ...。\n举例：\nint printf(const char *format, ...); 在 C 中的使用 #\rC 中使用可变参数需要引入头文件 stdarg.h。\n","date":"15 November 2024","externalUrl":null,"permalink":"/posts/c++%E6%8B%BE%E9%81%97/%E5%8F%AF%E5%8F%98%E5%8F%82%E6%95%B0/","section":"","summary":"向函数传不定个数的参数就是可变参数。标识符为 \u003ccode\u003e...\u003c/code\u003e。 举例： \u003ccode\u003ec int printf(const char *format, ...); \u003c/code\u003e C 中使用可变参数需要引入头文件 `st\u0026hellip;","title":"可变参数","type":"posts"},{"content":"\r参考 #\rRvalue References and Move Semantics in C++11 - Cprogramming.com\n认识C++移动语义与右值引用 - 知乎\n","date":"10 November 2024","externalUrl":null,"permalink":"/posts/c++%E6%8B%BE%E9%81%97/%E7%A7%BB%E5%8A%A8%E8%AF%AD%E4%B9%89%E4%B8%8E%E5%8F%B3%E5%80%BC%E5%BC%95%E7%94%A8/","section":"","summary":"","title":"移动语义与右值引用","type":"posts"},{"content":"大创要做一个基于两个特征矩阵的信号分割与分类（不知道该不该这么描述），精确度要求不高，但对实时性要求比较高。我想到了借鉴 YOLO 来解决这个问题，所以顺便就来读一下 YOLO 初代的论文，太复杂了猪脑是理解不能的。\nSkimming #\r摘要 #\rYOLO 做的活是 object detection。有如下特点：\n单 CNN 实现图像分割与分类，而不是两个阶段两个网络 推理快，能做到实时 45 fps 以上 比传统的 DPM 和 R-CNN 泛化性更好，准确性也是其他模型的大约两倍 佬就是佬，不需要什么花里胡哨的背景介绍，上来就是我们的模型吊打其他模型。\n介绍 #\r首先，YOLO 的推理过程和人眼很像。这应该是在暗示模型的名字由来（\n然后三大点：\nYOLO 很快。 YOLO 视野更广。推理图片是依靠图像全局信息，而不是滑动窗口那种局部信息。 YOLO 泛化很强。 原理 #\r这里得好好看，所以先跳过。\n对比其他网络 #\r对比了 DPM 和 R-CNN 等模型。除了这两个模型稍微认识以外，其他的都认不得。\n反正很强。\n原理 #\rOne-stage 如何实现 #\rYOLO 将一张图像分成了 $S$ 行 $S$ 列块方格。\n每一块方格负责预测：\n物体类别 $B$ 个预测框 (Bounding box)，以及对应置信度 参考下方图片。\n参考 #\r目标检测入门论文YOLOV1精读以及pytorch源码复现(yolov1) - 小小猿笔记 - 博客园\n","date":"8 November 2024","externalUrl":null,"permalink":"/posts/%E8%8A%9D%E5%A3%AB%E6%94%B6%E5%AE%B9%E6%89%80/%E8%AF%BB%E8%AE%BA%E6%96%87-yolo-v1/","section":"","summary":"大创要做一个基于两个特征矩阵的信号分割与分类（不知道该不该这么描述），精确度要求不高，但对实时性要求比较高。我想到了借鉴 YOLO 来解决这个问题，所以顺便就来读一下 YOLO 初代的论文，太复杂了猪\u0026hellip;","title":"读论文-YOLO v1","type":"posts"},{"content":"","date":"8 November 2024","externalUrl":null,"permalink":"/categories/%E8%8A%9D%E5%A3%AB%E6%94%B6%E5%AE%B9%E6%89%80/","section":"","summary":"","title":"芝士收容所","type":"categories"},{"content":"\rProg1-mandelbrot_threads #\r使用 std::thread 来绘制分形图像。\n默认策略 #\r默认策略是将图像分成高度相同的几块，每一块分给一个线程画。\n这样其实做不到负载均衡，因为每一块画的工作量是不同的。\n特别是 view1，很明显发现画中间部分的线程工作时间远高于两边的线程。 代码实现很朴实，均分然后画就好了。\n在 R7 5800x上（原生 8 核心 16 线程），画 view1：\n8 线程倍率：4.04x 16线程倍率：7.55x 都被 view1 中的画中间部分的线程拖后腿了。\nint startRow = args-\u0026gt;height / args-\u0026gt;numThreads * args-\u0026gt;threadId, numRows = args-\u0026gt;height / args-\u0026gt;numThreads; mandelbrotSerial( args-\u0026gt;x0, args-\u0026gt;y0, args-\u0026gt;x1, args-\u0026gt;y1, args-\u0026gt;width, args-\u0026gt;height, startRow, numRows, args-\u0026gt;maxIterations, args-\u0026gt;output ); 均衡策略 #\r让线程按行交错绘制图像。\n其实这个策略是在模拟随机分配任务。思想是将任务分成尽可能小的部分，然后让大家随机挑任务做。\n可以证明对长度为 $n$ 的数列 $a$（工作量），在其中随机取 $n/s$ 项（$s$就是线程数），其和的期望是相同的。\n代码实现是按行交错绘制，实现起来比较简单。\n对于 view1：\n8 线程：7.53x 16 线程： 11.48x 16线程反而缩水得很严重，主要原因应该是 8 线程时每个线程独享一个核心，基本做到了并行。但是 16 线程时就是两个线程争抢一个核心了，需要并发。\nint totHeight = args-\u0026gt;height; for(int line = args-\u0026gt;threadId; line \u0026lt; totHeight; line += args-\u0026gt;numThreads) { mandelbrotSerial( args-\u0026gt;x0, args-\u0026gt;y0, args-\u0026gt;x1, args-\u0026gt;y1, args-\u0026gt;width, args-\u0026gt;height, line, 1, args-\u0026gt;maxIterations, args-\u0026gt;output ); } 核心与线程 #\r问 ChatGPT 得知，CPU 中核心和线程大概是这样的：\n但也存在少量架构中线程有独立的 L1 cache。\n从高层次往低层次：\n系统级线程 - 逻辑处理器 - 物理内核\nProg3-mandelbrot_ispc #\rISPC 在 VSCode 中的配置 #\r这部分作业我挪到 WSL 上面做了，因为我的 Linux 机子处理器没有 AVX2 指令集。ISPC 只能在有这个指令集的机器上做。\n首先得保证有 ISPC 编译环境。\n然后，在 VSCode 上写 ISPC，要安装 ISPC 扩展。\n这个扩展还要求安装 C# 环境。\nDownload - Stable | Mono 按网页里的引导来配就行。Ubuntu 上一通 apt 就装好哩。\n最后，在 ISPC 插件设置中配置平台与 ISPC 编译器路径即可。我只改了蓝色的这两项，改完重启下 VSCode，插件就可以正常工作了。\nISPC 基础 #\r正式介绍 —— ISPC。\n实验文档说，ISPC 程序的每一个实例都是在 SIMD 单元里并行执行的。每一个实例都有两个隐含的变量：programIndex 和 programCount。前者是此实例的序号，后者是实例数。\n对于一个求向量和的代码：\nconst int TOTAL_VALUES = 1024; float a[TOTAL_VALUES]; float b[TOTAL_VALUES]; float c[TOTAL_VALUES] for(int i = 0; i \u0026lt; TOTAL_VALUES; i++) c[i] = a[i] + b[i]; 对应 ISPC 代码：\nexport sum1(uniform int N, uniform float* a, uniform float* b, uniform float* c) { for(int i = 0; i \u0026lt; N; i+= programCount) { c[programIndex + i] = a[programIndex + i] + b[programIndex + i]; } } export 使这个函数能直接被 C/C++ 代码调用 uniform 标识的参数表示对所有实例都相同\n可以看到，每个实例负责相邻的 N 个分量的求和。\n但是，ISPC 并不希望你详细到指定每个实例干什么工作。不该以“每个实例负责相邻的 N 个分量的和” 设计程序，而是以“求和的工作可以分解成每个分量求和的工作” 来设计程序。如下：\nexport sum2(uniform int N, uniform float* a, uniform float* b, uniform float* c) { foreach (i = 0 ... N) { c[i] = a[i] + b[i]; } } 通过 ISPC 的 foreach 来实现。\n大任务分解成每个分量求和的小任务时，这些小任务之间是互不影响的，所以执行的顺序也没有要求。我们在 sum1 中将相邻的分量放在一个实例中求和因此没有任何必要。所以通过 foreach 让 ISPC 自己决定小任务执行的顺序就行，程序会变得简洁一些。\nProg4- sqrt #\rTask1 #\r运行一下 sqrt 的代码。\n[sqrt serial]: [613.685] ms [sqrt ispc]: [127.356] ms [sqrt task ispc]: [9.783] ms (4.82x speedup from ISPC) (62.73x speedup from task ISPC) 和 prog3 类似，ISPC 理论 8 倍加速和 task 的 threads * 8 倍加速都没达到。应该也是负载均衡的问题。我们在 task2 里继续探索。\nTask2 #\r任务2要求通过修改输入的 value 数组，来实现最大的和最小的加速比。\n并行任务中，最大的两个开销是 (1) 运算开销 和 (2) 调度开销。前者占比越大加速比越大。后者为 0 时基本可以达到理论加速比。\n所以 value 数组设置为 1 和 2.999，可以实现运算开销占比最大化和最小化。\n设置为 1：\n[sqrt serial]: [10.802] ms [sqrt ispc]: [5.868] ms [sqrt task ispc]: [6.237] ms (1.84x speedup from ISPC) (1.73x speedup from task ISPC) 可以看到，加速比小了很多。\n设置为 2.999：\n[sqrt serial]: [1306.762] ms [sqrt ispc]: [188.561] ms [sqrt task ispc]: [15.588] ms (6.93x speedup from ISPC) (83.83x speedup from task ISPC) ","date":"8 November 2024","externalUrl":null,"permalink":"/posts/cs149-%E5%B9%B6%E8%A1%8C%E8%AE%A1%E7%AE%97/asst1/","section":"","summary":"使用 \u003ccode\u003estd::thread\u003c/code\u003e 来绘制分形图像。 默认策略是将图像分成高度相同的几块，每一块分给一个线程画。 这样其实做不到负载均衡，因为每一块画的工作量是不同的。 特别是 view1，很明显发现画\u0026hellip;","title":"Asst1","type":"posts"},{"content":"","date":"8 November 2024","externalUrl":null,"permalink":"/categories/cs149-%E5%B9%B6%E8%A1%8C%E8%AE%A1%E7%AE%97/","section":"","summary":"","title":"CS149-并行计算","type":"categories"},{"content":"\r需求 #\r校园网 128 位前缀的 IPV6 地址做 NAT6 IPV6 访问 PT 站 其他功能，比如魔法 网络环境是南京大学鼓楼校区校园网。仙林应该是差不多的。\n设备是小米路由器 4A v2。这个设备导致我装 Openwrt 的过程相当坎坷 TAT，再也不贪便宜买低端设备了。\n刷 Openwrt #\rBreed #\rBreed 是一种 bootloader，路由器会先引导至 Breed 后再引导你刷的其他系统。这样就不怕系统刷坏变砖了。\n刷 Breed 的教程很多，这里不再赘述。（刷一次基本一劳永逸了，所以不太记得怎么刷）\n自编译 Openwrt #\r你也可以选择在线编译 Openwrt 的方案，比如 Github Action 、OpenWrt Firmware Selector 和 openwrt.ai。\n我之前直接使用了别人编译好的系统，但存在许许多多的问题导致 IPV6 配不起来，故尝试了自己编译，也还算有趣。抖m指数++。\n编译的环境最好选 Linux 或者 WSL。常用的包和依赖得备齐，并且最好全程有魔法，否则很难编译成功。\n首先拉取 openwrt 源码。\ngit clone https://github.com/openwrt/openwrt 拉取下来的 main 分支是 snapshot 版本，建议还是选择稳定版，否则有些软件包装不了。写作本文时最新版为 23.05.5，对应 branch 为 openwrt-23.05，下文以此为准。\ngit checkout openwrt-23.05 如果你想从其他版本构建，比如 LEDE 或者老版本 Openwrt，可以参考小米4A千兆版V2刷自己编译的OpenWRT以及IPV6设置（包括中继与NAT6） - 哔哩哔哩\ncd 到拉取下来的目录中运行：\ngit clone https://github.com/kenzok8/small-package package/small-package 这条命令把一些常用的软件包拉了下来，便于我们编译时选择。\n然后在仓库目录中运行下面两条命令，可能会花一点时间，取决于你的网络：\n./scripts/feeds update -a ./scripts/feeds install -a 过程中可能会提示缺少依赖，注意看下脚本 log，把缺的东西装上。\n然后我们开始配置 config：\nmake menuconfig 会弹出以下界面：\n前三项选成图中选项。其他的就是自由发挥了，根据你的需求来。这里有 LuCI 软件包的插件对照表rk3568 m68s openwrt插件对照表（自己备用）-OPENWRT专版-恩山无线论坛\nmenuconfig 在使用上只要注意有些地方可以用 / 键来搜索，和 vim 一样。\n并且注意一下选择软件包时前面的 \u0026lt; \u0026gt; , \u0026lt;*\u0026gt; 和 \u0026lt;M\u0026gt;：\n\u0026lt; \u0026gt; 表示不安装这个包 \u0026lt;*\u0026gt; 表示将这个包以系统核心组件安装。会直接将软件包安装到固件里面。 \u0026lt;M\u0026gt; 表示将这个包编译成模块，需要后续在 openwrt 中安装。 建议直接安装到固件中，后续是可以删的，并且免得装了系统还要装一大堆包。\n顺带一提，我的 config 如下：\nBase system dnsmasq-full：完全版 dnsmasq，因为要用 IPV6。记得把基础版 dnsmasq 删了。 Kernel modules Network Support kmod-tcp-bbr：TCP 阻塞控制 LuCI Collections luci：luci 图形界面整合包 Applications luci-app-adguardhome： 去广告 + DNS luci-app-npc：内网穿透，类似 frpc luci-app-passwall2：富强民主文明和谐 luci-app-smartdns：聪明dns Network UDPspeeder Utilities Editors vim：ssh 改东西的时候方便 config 配置好后，选到底下那排 Save，以 .config 保存。\n接着正式开始编译。建议使用特殊手段来优化网络，能快不少。\nmake download -j8 make V=s -j1 第一个 make 是下载对应软件包，直接上八核伺候。\n第二个是编译固件，第一次编译建议只用一个核心，否则并行起来日志顺序都是乱的，不方便看报错。\n编译的时间一般要半个小时以上。5800x 第一次编译大概花了 20 多分钟。但是增量编译就很快了，几分钟。\n编译完成后，在 target/\n刷入路由器 #\r拔掉路由器电源，按住 reset 键插上电，等三秒以上再松，访问 192.168.1.1 就能进入 Breed 页面。\n我们在固件备份中把系统和 eeprom.bin 备份一下。\n（图片引用自小米路由R4A千兆版安装breed+OpenWRT教程以及救砖（全脚本无需硬改） - 哔哩哔哩） 然后就是刷入固件了。\n但这一步中，小米路由器 4A v2 有一个大坑。不能直接用 breed 的固件更新刷固件。因为这个路由器的闪存布局比较独特，要把系统写到 0x180000 地址才能正常启动。如果你用 breed 的固件更新里刷固件，并且闪存布局是 0x50000 的话，路由器会无限重启。\n参考小米路由器 4A千兆版 V2 新版硬件安装OpenWRT - 知乎就好。十分感谢这位仁兄。\n开启 NAT6 #\r参考 #\r小米路由R4A千兆版安装breed+OpenWRT教程以及救砖（全脚本无需硬改） - 哔哩哔哩\n小米4A千兆版V2刷自己编译的OpenWRT以及IPV6设置（包括中继与NAT6） - 哔哩哔哩\n小米路由器 4A千兆版 V2 新版硬件安装OpenWRT - 知乎\nrk3568 m68s openwrt插件对照表（自己备用）-OPENWRT专版-恩山无线论坛\n","date":"3 November 2024","externalUrl":null,"permalink":"/posts/%E6%9C%89%E6%84%8F%E6%80%9D%E7%9A%84%E6%8A%98%E8%85%BE/%E5%B0%8F%E7%B1%B3%E8%B7%AF%E7%94%B1%E5%99%A8-4av2-%E5%88%B7-openwrt-%E5%B9%B6%E5%BC%80%E5%90%AF-nat6/","section":"","summary":"网络环境是\u003ccode\u003e南京大学鼓楼校区校园网\u003c/code\u003e。仙林应该是差不多的。 设备是\u003ccode\u003e小米路由器 4A v2\u003c/code\u003e。这个设备导致我装 Openwrt 的过程相当坎坷 TAT，再也不贪便宜买低端设备了。 Breed 是一种 \u0026hellip;","title":"小米路由器 4Av2 刷 Openwrt 并开启 NAT6","type":"posts"},{"content":"","date":"3 November 2024","externalUrl":null,"permalink":"/categories/%E6%9C%89%E6%84%8F%E6%80%9D%E7%9A%84%E6%8A%98%E8%85%BE/","section":"","summary":"","title":"有意思的折腾","type":"categories"},{"content":"\rk-NN #\r算法流程 #\r对测试样本，找训练样本中最近的 $k$ 个，这 $k$ 个样本中标签最多的就是测试样本的类。\nk 的取值 #\rk 一般取奇数值，避免平局 k 取不同的值，分类结果可能不同 k 值较小时，对噪声敏感，整体模型变得复杂，容易过拟合 k 值较大时，对噪声不敏感，整体模型变得简单，容易欠拟合 变种 #\r最邻近分类器 #\rk-NN 的 $k=1$ 的特殊情况。\n","date":"25 October 2024","externalUrl":null,"permalink":"/posts/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/k-%E9%82%BB%E8%BF%91%E5%88%86%E7%B1%BB%E5%99%A8/","section":"","summary":"对测试样本，找训练样本中最近的 $k$ 个，这 $k$ 个样本中标签最多的就是测试样本的类。 k-NN 的 $k=1$ 的特殊情况。","title":"K 邻近分类器","type":"posts"},{"content":"\rtypedef #\r字面意思，给类型取别名。\n和 define 的区别 #\rdefine 可以替换任何东西，比如常量、编译开关等\ndefine 在编译之前的预处理阶段生效，typedef 在编译阶段生效。\ntypedef可以只在某个作用域内生效。\nint main() { typedef int size_t; size_t s = 3; fun(); } int fun() { size_t t = 2; // ERROR } 对指针的修饰不同 含 const 时，两者不等价 TODO\n类型别名 #\rtypedef unsigned int size_t 结构体别名 #\rtypedef struct person{ char name[128]; }Person; Person a; 函数指针别名 #\rtypedef void*(*Fun) sizeof #\rsizeof 有两种。一种带括号的，另一种不带。\nsizeof 无括号 #\r返回所给类型的字节数。后面只能跟类型名。\nsizeof() #\r返回括号中变量所占字节数。\n可以理解为在识别了这个变量的类型后，再使用无括号的 sizeof 返回这个类型占的字节数。\n注意：\n指向数组首元素的指针传入时，只会返回 4。因为传入的是指针变量而不是数组变量（e.g. int* 和 int[5]） ","date":"20 October 2024","externalUrl":null,"permalink":"/posts/c++%E6%8B%BE%E9%81%97/%E5%85%B3%E9%94%AE%E5%AD%97/","section":"","summary":"字面意思，给类型取别名。 ```cpp int main() { typedef int size_t; size_t s = 3; fun(); } int fun() { size_t t = 2\u0026hellip;","title":"关键字","type":"posts"},{"content":"\r写在前面 #\r写这部分是为了：\n读懂复杂且恶心的类型声明，比如 void (*signal(int, void (*fp)(int)))(int); 考试 记住要：\n不写这种不符合规范，并且恶心他人的声明 多用 using 以及 STL 封装好的类型，适度用 typedef 对恶心的写法说 no 推荐这个网站，能帮你把 C 类型声明翻译成自然语言：\ncdecl: C gibberish ↔ English\n变量声明说明符 #\r本文中，我们只关心如下几种说明符，因为这几种说明符是最困难的部分：\n*: 指针 []: 数组 (): 括号（改变声明优先级）或者 函数指针 \u0026amp;: 引用 优先级 #\r括号括住的部分 \u0026gt; 后缀说明符 \u0026gt; 前缀说明符 读声明 #\r优先级规律总结出来其实就是 右左法则，或者叫 clockwise/spiral Rule。\n法则内容如下：\n从唯一的未定义的标识符开始 #\r声明语句中，有且仅有一个之前没定义过的标识符。我们就从这个标识符开始。\nint ((*fp)[MAXN])(int x, int y); 上例就是 fp。\n先看右边的声明符，再看左边 #\r因为后缀说明符优先级更高，所以先看右边。\n将看到的声明符转译为英文 #\r看到了哪个声明符，就将如下列出的翻译模板加到我们当前的翻译栈中。\n指针 / 引用：a pointer / reference to\n数组：an array of\n函数：a function passing (params) returning a\n遇到非函数指针的括号就换方向 #\r意思就是必须将当前括号里面的声明处理完毕才能跳出去。这是为了保证括号的优先级。\n参考资料 #\r如何解释复杂的 C/C++ 声明 - 知乎\nc 语言中的复杂声明_c++ 数组复杂声明 读法-CSDN博客\n复杂的指针_复杂的指针问题-CSDN博客\nClockwise/Spiral Rule\nparsing - C isn\u0026rsquo;t that hard: void ( *( *f[] ) () ) () - Stack Overflow\n📝笔记：使用Clockwise/Spiral Rule技巧轻松读懂变量/函数声明 | RealCat\ncdecl: C gibberish ↔ English\n","date":"13 October 2024","externalUrl":null,"permalink":"/posts/c++%E6%8B%BE%E9%81%97/%E7%B1%BB%E5%9E%8B%E8%A7%A3%E9%87%8A/","section":"","summary":"写这部分是为了： 记住要： 推荐这个网站，能帮你把 C 类型声明翻译成自然语言： 本文中，我们只关心如下几种说明符，因为这几种说明符是最困难的部分： ```text 括号括住的部分 \u0026gt; 后缀说明符 \u0026gt;\u0026hellip;","title":"类型解释","type":"posts"},{"content":"\r前言 #\r在以前打竞赛的时候，基本都是用字符数组配合string.h里的函数去处理字符串。现在开始系统地接触C++，所以来记录一下string类的知识。\n简介 #\rstring 是 C++ 风格的字符串类，也是一种STL容器(根据CppReference说法，string是唯一的伪容器)。相比于 C 风格的字符串 char[] ，string 支持自动内存管理，并且拥有很多方便的函数。\n头文件：string\n构造 #\r一般构造 #\rstd::string(const char* s) std::string(const string\u0026amp; s) 传入一个 C 字符串或者字符串类，变成 C++ string类。没什么好说的。\n特殊构造 #\r直接赋值string str = \u0026quot;...\u0026quot; 直接将 C 字符串赋值或者类型转换。\nstd::string(size_t n, char c) 构造一个 n 个 c 的字符串。也就是将 c 重复 n 次。\n属性 #\r长度 #\r优先 string.length()。\n其他诸如 string.size() 和 strlen(const \u0026amp;string)。\n是否空 #\r和其他 STL 容器一样，判断 string 是否为空：\nstring.empty()\n访问与遍历 #\r索引 #\rstr[i] 直接得到对应字符。\n迭代器 #\rstring.begin(), string.end() 得到头尾 iterator。\nForeach #\r和 Java 一毛一样。你乐意用 auto 也行，反正元素就是char。\nfor(char c : str) 常用 #\r修改 #\r修改元素 #\r修改元素用索引、迭代器这些都行，或者下面的 replace。\nstr.insert(pos, str2)\n在索引为pos的地方插入str2。\n就是说，插入的str2的第一个元素在修改后的str的pos处。\n修改子串 #\rstr.replace(pos, len, str2)\npos 索引(0开始)，长度为 len 的子串替换成 str2。\nstr.erase(pos, len)\n删除 pos 开始长度为 len 的子串。\n连接 #\r+\n直接+号运算就行。\nstr.append(str2)\n这个不用说了。\n查找 #\rstr.find(str2)\n找 str 中 str2 的索引。找不到返回 -1。\nstr.rfind(str2)\n反着找。\n截取子串 #\rstr.substr(pos, len)\n注意！！！和 Java 不一样！！！\n截取 pos 开始，长度为 len 的子串。\n转数字 #\rstoi(str)：int stof(str)：float stod(str)：double 还有很多，按需取用。 大小写 #\rtoupper(str) 和 tolower(str)。\n","date":"12 October 2024","externalUrl":null,"permalink":"/posts/c++%E6%8B%BE%E9%81%97/string/","section":"","summary":"在以前打竞赛的时候，基本都是用字符数组配合\u003ccode\u003estring.h\u003c/code\u003e里的函数去处理字符串。现在开始系统地接触C++，所以来记录一下\u003ccode\u003estring\u003c/code\u003e类的知识。 \u003ccode\u003estring\u003c/code\u003e 是 C+格的字符串类，也是一种\u0026hellip;","title":"String","type":"posts"},{"content":"\r引用 #\r引用和指针 #\r以我的粗浅且可能有很大错误的理解，引用就是有着一些限制、有一些封装的指针，这些限制在编译器层面解决，底层就是以指针形式实现。\n限制在如下几点：\n引用创建时需要初始化 引用在初始化后无法再改变指向 所以不存在 const int\u0026amp; 引用带来的方便：\n引用的元素可以直接按名访问，不需要解指针 指针 #\r指针是指向一块内存首地址的变量。指针的类型提供了对于这个首地址该如何解释的信息。\n智能指针 #\rTODO：目前是从 YDJSIR 笔记中复制粘贴的\n通过将一些需要的信息进行封装的方法，来保证不管出现什么异常，在退出相应操作部分时，自动调用对象的析构函数来保证不会出现内存泄漏的问题。\n同样的还有句柄类(C++ 异常中有)\ntemplate \u0026lt;class T\u0026gt; class auto_ptr{ public: auto_ptr(T *p=0):ptr(p) {} ~auto_ptr() { delete ptr; } T* operator-\u0026gt;() const { return ptr;} T\u0026amp; operator *() const { return *ptr; } private: T* ptr; }; //结合智慧指针使用 void processAdoptions(istream\u0026amp; dataSource){ while (dataSource){ auto_ptr\u0026lt;ALA\u0026gt; pa(readALA(dataSource)); pa-\u0026gt;processAdoption();//只要对象结束，就会自动delete } } 函数指针 #\r函数指针能够像传递参数一样传递函数。并且也便于我们实现多态。\n对于函数指针的简单使用，我还是持开放态度的。但是众所周知，函数指针是能够复杂到令人呕吐的程度的。这种情况还是尽可能不要用函数指针了，要不就用 typedef 定义得好看点。不要恶心自己的同时还恶心他人……\n定义函数指针 #\rint (*fp)(int); fp 就可以存放返回值为 int，参数为一个 int 的函数了。\n可以这样理解：fp 是标识符，*fp 中的 * 在说这个变量是个指针，最前面的 int 和后面括号中的 (int) 说明了这是函数指针，并指明了参数和返回值。\nint func(int a); // 写法1：直接赋值 fp = func; // 写法2：取地址再赋值 fp = \u0026amp;func; 对 fp 的赋值，两种写法均可。写法1 是写法2 的语法糖。\n调用 #\r// 写法1：直接调用 fp(1); // 写法2：解引用后再调用 (*fp)(1); 既可以直接调用，也可以解引用后再调用。\nChatGPT 说直接调用的写法实际上是个 Syntax sugar，编译器会将直接调用改成解引用后再调用的写法。也就是写法1 编译后和写法2 无异。这个说法令人信服，毕竟直接调用的行为本质上是对一个指针变量也就是一个地址进行调用，这是完全没有意义的。\n作为参数传递 #\rint foo(int arg1, int (*fp)(int)) { result = fp(arg1); } 写法和定义类似。这里函数指针作为参数传递的一大重要作用是可以实现多态。\n使用 typedef 简化函数指针 #\rtypedef int (*FP)(int) FP fp = func； fp(1); typedef 之后， FP 就是这类函数指针的类型别名了。\n这 typedef 的写法，评价为纯纯的答辩。但是这样简化之后，再使用这个函数指针类型就方便了。\n深入赤石 #\r以下内容相对复杂，建议浅尝辄止。实际生产中最好不要使用太多复杂的函数指针。\n函数指针数组 其实，函数指针数组还不错。初见函数指针数组还是操作系统实验中，使用函数指针存放信号处理函数。\nvoid (*sigaction[SIGNAL_NUM](int, struct proc *)); // typedef 防赤石 typedef void (*sigaction_ptr)(int, struct proc *); sigaction_ptr[SIGNAL_NUM]; 写法还是相对清晰的。可以类比指针数组的写法：\nchar *str_list[STR_NUM]; 函数指针作为返回值 void (*(*f(int)))(int, int) 数组 #\r只要时刻记住，数组是存放在连续空间上的一系列数据。我们想以几维访问都无所谓，只要保证不越界就行。\n一维数组 #\r没什么好说的，搬一些数组访问的等价式。说白了就是一些语法糖。\na[i] == *(a + i) \u0026amp;a[0] = a 二维数组 #\r同样搬等价：\nint b[MAXN][10]; int *q; b[i][j] == *(b + i * 10 + j) // 第二维大小在这起作用 == q[i * 10 + j] // 降维操作，按一维访问 升维降维 #\r我重新理解了这部分。升维降维，归根结底还是逃不出数组的本质：一块连续的内存。\n对一块长度为 LEN 字节的数组 a ：\n我们如何去解释这块内存中的每个元素，决定了我们遍历的总次数，也就是元素个数。\nbyte_t *a = malloc(LEN); // 解释为 char，就遍历 LEN 次 char *p_char = (char *) a; for(int i = 0; i \u0026lt; LEN; i++) char element = p_char[i]; // 解释为 int，就只要遍历 LEN / 4 次 int *p_int = (int *) a; for(int i = 0; i \u0026lt; LEN / 4; i++) int element = p_int[i]; // 解释为 char[10]，就要遍历 LEN / 10 次 char (*p_char10)[10] = (char (*)[10]) a; for(int i = 0; i \u0026lt; LEN / 10; i++) char *element = p_char5[i]; 我们决定好了元素解释方法后，总次数确定了。假设总次数为 t ，我们想以几维访问就以几维访问，只要和逻辑相符就行。\n同时，用 typedef 或者 using 将元素的类型抽象出来会简化很多工作。\n参考资料 #\rYDJSIR 的 C++ 笔记\nCPL-2023\n万字长文系统梳理一下C++函数指针 - 知乎\nC++ 函数指针 \u0026amp; 类成员函数指针 | 菜鸟教程\n","date":"12 October 2024","externalUrl":null,"permalink":"/posts/c++%E6%8B%BE%E9%81%97/%E6%8C%87%E9%92%88%E5%BC%95%E7%94%A8%E4%B8%8E%E6%95%B0%E7%BB%84/","section":"","summary":"以我的粗浅且可能有很大错误的理解，引用就是有着一些限制、有一些封装的指针，这些限制在编译器层面解决，底层就是以指针形式实现。 限制在如下几点： 引用带来的方便： 指针是指向一块内存首地址的变量。指针的\u0026hellip;","title":"指针、引用与数组","type":"posts"},{"content":"\r前言 #\rSTL 有五大组件：\n容器（Container），数据结构； 迭代器（Iterator），提供了一种顺序访问容器中对象的方法。 算法（Algorithm），是用来操作容器中的数据的模板函数。 仿函数（Functor），就是使一个类的使用看上去象一个函数，就是类中实现一个operator()。 适配器（Adaptor），对原有的容器进行包装，给换一套接口。 容器 #\r序列容器 #\r序列容器实现能按顺序访问的数据结构。\n有如下容器：\nvector：动态数组 deque：双端队列 list：双向链表 array：C 风格的固定大小的数组 C++11 forward_list：单向链表。性能比 list 略好，基本和 C 中的链表无异 C++11 inpalce_vector：可动态调整大小的固定容量原位连续数组 C++26 一般操作 #\r构造 #\r省略返回类型以及一些无关紧要的参数类型。\n()：默认无参数构造 (\u0026amp;\u0026amp; other)：拷贝构造 (it1, it2)：从另一个 vector 的迭代器构造，得到子 vector (count, T element)：含 count 个 element 赋值 #\r赋值号 assign 函数。和构造函数参数是一致的。 swap 交互两个容器。 元素访问 #\roperator[]。数组的访问方式。可以访问任意下标的元素。 at(index)。访问下标 index 处的元素。 元素操作 #\rpush_front(T e) push_back(T e)：头尾部加入元素 pop_back() pop_front()：尾部删除 insert(it, T e) / insert(it, count, T e)：it 处插入一个或多个 e erase(it) / erase(it1, it2)：it 处删除 / [it, it2) 处删除 clear()：清空 说明 #\rvector #\r没有头部加入和删除元素。 insert，erase 和 clear 复杂度 $O(n)$\ndeque #\r列出的函数都有。\nlist #\rremove(T e)：移除和 e 相等的元素 关联容器 #\r关联容器实现能快速查找（$O(log n)$ 复杂度）的有序数据结构。\n有如下容器：\nset：集合 multiset：多重集合 map：映射 multimap：多重映射 相关操作 #\rset, map 大部分插入、删除与搜索都是 $O(logn)$ 的。\n构造 #\r()：默认无参构造 \u0026lt;key, comp\u0026gt;()：自定义仿函数 comp。默认为 std::less 对 set/multiset\n(\u0026amp;\u0026amp;)：移动构造 (it1, it2)：从序列容器构造 (int first, int last)：构造 first 到 last 的数字集合。左闭右开 赋值 #\r只有赋值号和 swap。\n元素访问 #\r仅限 map\noperator[] 和 at() 元素查找 #\rfind(T\u0026amp; key)：找到为 key 的第一个元素，返回迭代器。 count(T\u0026amp; key)：返回 key 的数目。对于 set 和 map 只会返回 0 和 1。 equal_range(T\u0026amp; key)：找到一个 range，之中每一个元素都等于 key。返回 range 首尾迭代器组成的 pair。 lower_bound(T\u0026amp; key)：找到第一个不小于 key 的元素的迭代器。（也就是包含自身） upper_bound(T\u0026amp; key)：找到第一个大于 key 的迭代器。（也就是不包含自身） 元素操作 #\rinsert emplace：插入元素 clear：清空 erase(T\u0026amp; key) erase(it)：通过元素或者迭代器删除元素 参考 #\rC++ STL 教程 | 菜鸟教程\nCppReference\n","date":"12 October 2024","externalUrl":null,"permalink":"/posts/c++%E6%8B%BE%E9%81%97/stl/","section":"","summary":"STL 有五大组件： 序列容器实现能按顺序访问的数据结构。 有如下容器： 省略返回类型以及一些无关紧要的参数类型。 没有头部加入和删除元素。 insert，erase 和 clear 复杂度 $O(n\u0026hellip;","title":"STL","type":"posts"},{"content":"","date":"8 October 2024","externalUrl":null,"permalink":"/categories/%E7%AE%97%E6%B3%95%E4%B8%8E%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/","section":"","summary":"","title":"算法与数据结构","type":"categories"},{"content":"本专题(算法与数据结构)主要用以复习与回忆，内容量少且相当不全面。\n写这个专题的主要原因是刷力扣的时候唤起了曾经竞赛的回忆，借博客给这些陈旧的知识重新打包装好，顺便应对以后保研或者应聘的机试。当然，能学些以前不会的知识自然是最好的。\n主要内容参考 OI Wiki，内容分类也是相同的方式。\n如果要从0开始学还是去看 Wiki 或者别的教程罢。这样一方面能减少写文章的压力，另一方面能学了不至于白学。\n已更新 #\r数据结构 #\r单调队列 单调栈 更新计划 #\r基本是力扣\n","date":"8 October 2024","externalUrl":null,"permalink":"/posts/%E7%AE%97%E6%B3%95%E4%B8%8E%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E4%B8%93%E9%A2%98%E5%AE%9A%E4%BD%8D/","section":"","summary":"本专题(算法与数据结构)主要用以复习与回忆，内容量少且相当不全面。 写这个专题的主要原因是刷力扣的时候唤起了曾经竞赛的回忆，借博客给这些陈旧的知识重新打包装好，顺便应对以后保研或者应聘的机试。当然，能\u0026hellip;","title":"专题定位","type":"posts"},{"content":" 数据结构篇\n省流 #\r单调队列：获得 区间(滑动窗口)的 最值\n单调栈：获得 某元素 周围 第一个 大于或者小于它 的元素\n实际运用多为以上两种情况，但仍需活学活用，不能被上面的两种情况限制。\n细说 #\r单调队列 #\r比喻 #\r之前在力扣评论区刷到过如下比喻：\n公司的所有员工按年龄排列成一个单调的队列。\n公司将不断招入年轻员工。如果年轻员工比某些老员工能力强，那就毫不犹豫踢掉这些老员工(补药啊)。\n同时，踢掉大于35岁的老员工，无论能力多强都踢掉。\n这个比喻就把单调队列的出入队概括完了，很好理解。\n为什么 #\r单调队列怎么做到通过维护一个队列，队头刚好是所求区间上的最大值呢（最小值同理，以下例子为最大值）？\n首先，很容易明白的一点，就是这个区间的最大值一定能留在队头。\n我们担心的是，这个最大值一旦离开区间了，谁来当二把手呢？\n我们想到可以搞个二把手候选人队列，有可能当二把手的元素都进来，从大到小排着，老大挂了就上老二。\n那为什么要让能力强的新人把比他弱的老东西踢掉呢？因为新人能活最久，并且当二把手的优先级也高于老东西，那这些老东西一定是不可能当二把手的，不符合我们队列的要求，所以直接踢掉。\n单调栈 #\r单调栈也完全可以通过上面的比喻来理解。但是不能踢35岁老员工了，单调栈是一个尊重老人的公司。\n获得 某元素 周围 第一个 大于或者小于它 的元素 是什么意思呢？\n当一个新人比一堆老员工强的时候，这些老员工全会被踢。所以，这个新人就是第一个比这些老员工强的人。换句话说，新入栈的元素是第一个比 因为这个元素而退栈的元素 大的元素。这句话很绕，慢点读别噎着了。\n但这样我们只能做一个方向。所以得维护两个单调栈，就能得到每个元素“周围”的满足要求的元素了。\n练练手 #\r单调队列 #\r力扣-滑动窗口最大值\nP2698 [USACO12MAR] Flowerpot S - 洛谷 | 计算机科学教育新生态 (luogu.com.cn) - 此题甚妙，有点难\n单调栈 #\rP5788 【模板】单调栈 - 洛谷 | 计算机科学教育新生态 (luogu.com.cn)\nP1901 发射站 - 洛谷 | 计算机科学教育新生态 (luogu.com.cn)\n","date":"7 October 2024","externalUrl":null,"permalink":"/posts/%E7%AE%97%E6%B3%95%E4%B8%8E%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E5%8D%95%E8%B0%83%E9%98%9F%E5%88%97--%E5%8D%95%E8%B0%83%E6%A0%88/","section":"","summary":"单调队列：获得 区间(滑动窗口)的 最值 单调栈：获得 某元素 周围 第一个 大于或者小于它 的元素 实际运用多为以上两种情况，但仍需活学活用，不能被上面的两种情况限制。 之前在力扣评论区刷到过如下比\u0026hellip;","title":"单调队列 \u0026 单调栈","type":"posts"},{"content":"\r基本思想 #\r决策树就是一颗 if-else 树。树的每一个结点代表一个决策（测试），同时也代表了这个决策所对应的一个样本空间。我们的目标就是通过多次产生 if-else 分支，尽可能地让决策树的叶子结点只包含相同标签的样本。\n既然是一棵树，我们就从递归建树的角度来理解决策树的基本思想。\n基础 #\r决策树的根节点代表了整个样本空间，没有任何划分或决策。\n下图的例子只有连续属性，将就看吧。\n递归 #\r假设我们在某一结点下。只考虑这个结点所代表的子样本空间。\n建树就是要加深树的深度，即产生 if-else 分支。具体来说就是在当前的样本空间中插入决策边界，划分出的多个新的样本空间就是儿子们的样本空间。\n我们每次递归只选择样本的某一个属性进行划分。\n离散属性 #\r将这个属性的每一个取值都划出一个空间。\n假如这个属性$a$取值集合是$D={x, y, z}$，我们就划出三个空间，对应这三个取值。这样这个结点下就生出了三棵子树。if-else如下：\nif(a == x) { SubTree1; }else if(a == y) { SubTree2; }else { SubTree3; } 连续属性 #\r基本方法就是将连续属性变成离散属性。常用的方法是二分法。\n对连续属性$A$，取合适的值$x$。通过如下函数，我们能得到一个离散属性$B=\\{X, Y\\}$。\n$$\rb=f(a)=\\left\\{\r\\begin{aligned}\rX, a\\le x \\\\\rY, a\\gt x\r\\end{aligned}\r\\right.\r$$取合适的值一般会取中位数。\n如上图，我们横着插了一条决策边界，这条边界代表如下决策：\nif(x \u0026lt;= 0.0596) { LeftSubTree; } else { RightSubTree; } 停止条件 #\r只要当前结点的样本空间只存在一类标签的样本，我们就停止递归此结点。 这样会导致十分严重的过拟合。解决方法看后面。\n当前属性集为空, 或是所有样本在所有属性上取值相同，无法划分 当前结点包含的样本集合为空，不能划分 取最优划分属性 #\r我能想到三种取决策边界的方法。\n随便取 #\r没错，随机永远是你大爷。我们随机取一个属性进行划分。\n只要递归次数够多，一定能到达停止条件。只是这样建出来的树可能够让大半个中国在树底下乘凉了。\n信息增益 #\rID3 决策树\n假定当前样本集合$D$中第$k$类样本所占的比例为$p_k$ 定义信息熵如下：\n$$Ent(D)=-\\sum_{k=1}^{|y|}p_klog_2p_k$$ 信息熵是度量样本集合“纯度”最常用的一种指标\n说人话，样本集合越杂，信息熵越大。\n假设离散属性$a$的取值集合为$\\{a^1,a^2,...,a^V\\}$，$D^v$是$D$中在$a$上取值等于$a^v$的样本集合。 由此定义以属性$a$对$D$进行划分的信息增益为：\n$$\rGain(D,a)=Ent(D)-\\sum_{v=1}^{V}\\frac{|D^v|}{|D|}Ent(D^v)\r$$可以看到，信息增益就是以属性$a$划分前后的信息熵差值来定义的。而划分后的信息熵是按样本数为权重求和来的。\n信息增益越大，说明以这个属性划分后信息熵减小得越多，划分后的子样本空间最纯。所以我们对所有属性中增益最大的进行划分就好了。\n增益率 #\rC4.5 决策树\n只有一页 PPT。\n增益率是对信息增益的补充。\n基尼指数 #\rCART 决策树\n基尼指数本质反映了从$D$中随机抽取两个样例，其类别标记不一致的概率。\n定义如下：\n$$\r\\begin{equation}\r\\begin{aligned}\rGini(D) \u0026= \\sum^{|y|}_{k=1}\\sum_{k^{'}\\neq k}p_kp_{k^{'}} \\\\\r\u0026= 1-\\sum^{|y|}_{k=1}p_k^2 \\\\\r\u0026= 1-\\sum^{|y|}_{k=1}(\\frac{|D^k|}{|D|})^2\r\\end{aligned}\r\\end{equation}\r$$其中，$p_k$是样本点属于第$k$类的概率，$D^k$是样本集合$D$中属于第$k$类的样本子集。\n而属性$a$划分下的基尼指数为：\n$$\rGini\\_index(D,a)=\\sum_{v=1}^{V}\\frac{|D^v|}{|D|}Gini(D^v)\r$$即按样本数对基尼指数加权平均求和。同样地，我们取$Gini\\_index$最小那个属性就行了。\n剪枝 #\r前面说了，决策树的停止条件之一是叶子只包含一类标签的样本，而这样会导致很强的过拟合，在训练集上也会达到 100%的正确率。所以我们需要剪枝来增强泛化性能。\n预剪枝 #\r及早停止树的生长\n限制树的高度 #\r这个很好理解。结点一旦长到一定高度了，就直接不让它继续往下长了。\n评估法 #\r我随便起的名字。\n思路是每次生长的时候，评估生长后的决策树在验证集上的表现。然后根据一定的策略决定是否继续生长下去。\n比如，如果生长后验证集准确率降低了，我就不让树继续长了；否则，树就可以继续长。\n其他 #\r剪枝这个东西，可操作空间相当大。根据实际任务去选择合适的剪枝方案才是可行之法。同时，不同的剪枝方法也可以相互融合，生成效果更好的剪枝。\n后剪枝 #\r随后删除或折叠信息量很少的结点\n评估法 #\r还是评估法，没想到吧！\n思路是将已经长好的结点收缩。\n详细一点：\n我们考虑要剪枝的结点$k$，以$k$为根节点的子树有叶子$\\{l_1, l_2, l_3...l_n\\}$\n从 1 到 n，将这棵子树坍缩成叶子，并根据验证集评估整颗决策树。\n选择评估结果最好的叶子，再决定是否剪枝即可。\n中间涉及的一些策略很含糊，因为这是根据实际去替换的部分。\n对比 #\r时间开销 预剪枝：测试时间开销降低，训练时间开销降低\n后剪枝：测试时间开销降低，训练时间开销增加\n过/欠拟合风险 预剪枝：过拟合风险降低，欠拟合风险增加\n后剪枝：过拟合风险降低，欠拟合风险基本不变\n泛化性能 后剪枝 通常优于 预剪枝\n其他 #\r连续值和离散值 #\r连续值 -\u0026gt; 离散值 一般而言，可以用二分法。\n即取属性值的中位数$med$，对于取值小于$med$的归为一号类，其他归为二号类。\n离散值 -\u0026gt; 连续值 离散值编号就行。\n代码实现 #\r我们来通过 Python 实现一个决策树。这个决策树是将所有属性视作连续值，并且使用二分法，所以建出来是二叉树。\n完全是我闭门造车实现的，只是借鉴了sklearn的api，具体实现应该十分不标准，请勿过度参考！\n结点类 #\r既然是一颗树，我们先来定义树的结点类。\nclass Node: def __init__(self, ind, splitter, label): self.ind = ind self.splitter = splitter self.lson = None self.rson = None self.label = label def test(self, x): if self.lson is None or self.rson is None: return self.label if x[self.ind] \u0026lt; self.splitter: return self.lson.test(x) else: return self.rson.test(x) 初始化函数中：\nind：结点负责的属性编号 splitter：结点对ind号属性做决策的决策边界。小于splitter到左子树，否则柚子树。 label：此结点的类别标记。表示决策做到这个结点时将样本认定为哪个类。 test函数：输入样本x，输出预测类编号。\n决策树类 #\r接下来，写一个决策树类。负责管理Node，并向外提供接口。\nclass MyDecisionTree: def __init__(self, criterion=\u0026#39;gini\u0026#39;, max_depth=255): # criterion self.criterion = Criterion() if criterion == \u0026#39;gini\u0026#39;: self.criterion = Gini() if criterion == \u0026#39;entropy\u0026#39;: self.criterion = Entropy() if criterion == \u0026#39;random\u0026#39;: self.criterion = Random() # depth self.max_depth = max_depth def fit(self, x, y): self.root = self.build(x, y, 0) def score(self, x, y): acc = 0 for i in range(len(y)): tar = self.root.test(x[i]) if tar == y[i]: acc += 1 print(f\u0026#34;Accuracy: {acc * 1.0 / len(y)}\u0026#34;) def build(self, x, y, depth): if depth \u0026gt;= self.max_depth: return None clazz_count = len(np.unique(y)) if clazz_count == 0: return None if clazz_count == 1: return Node(0, 0, np.unique(y)[0]) ind, splitter = self.criterion(x, y) node = Node(ind, splitter, np.argmax(np.bincount(y))) l_rows = np.where(x[:, ind] \u0026lt;= splitter)[0] r_rows = np.where(x[:, ind] \u0026gt; splitter)[0] node.lson = self.build(x[l_rows], y[l_rows], depth + 1) node.rson = self.build(x[r_rows], y[r_rows], depth + 1) return node 初始化函数可以选择取划分属性的标准、树的最大深度。 fit: 在输入的数据集上进行训练 score：在输入的数据集上进行测试 _build：递归建树。包含了停止条件的检查以及划分属性的选择。 选取属性策略 #\r基于Criterion父类实现了Gini、Entropy和Random的属性选取策略。\n使用了二分法，将样本属性的中位数作为分类边界。所以Gini和Entropy中的$\\frac{|D^v|}{|D|}$可以认为是$\\frac{1}{2}$。\nclass Criterion: def __call__(self, x, y) -\u0026gt; tuple[int, int]: pass class Gini(Criterion): def __call__(self, x, y) -\u0026gt; tuple[int, int]: median = np.median(x, axis=0) ind, gini_min = 0, 1 for i in range(x.shape[1]): l_rows = np.where(x[:, i] \u0026lt;= median[i])[0] r_rows = np.where(x[:, i] \u0026gt; median[i])[0] gini_i = 0.5 * (Gini.clac_gini(y[l_rows]) + Gini.clac_gini(y[r_rows])) if gini_i \u0026lt; gini_min: ind = i gini_min = gini_i return ind, median[ind] def clac_gini(y): uy, counts = np.unique(y, return_counts=True) probabilities = counts / counts.sum() gini = 1 - np.sum(probabilities ** 2) return gini class Entropy(Criterion): def __call__(self, x, y) -\u0026gt; tuple[int, int]: median = np.median(x, axis=0) ind, gain_max = 0, 0 for i in range(x.shape[1]): l_rows = np.where(x[:, i] \u0026lt;= median[i])[0] r_rows = np.where(x[:, i] \u0026gt; median[i])[0] gain_i = Entropy.clac_entropy(y) - 0.5 * (Entropy.clac_entropy(y[l_rows]) + Entropy.clac_entropy(y[r_rows])) if gain_i \u0026gt; gain_max: ind = i gain_max = gain_i return ind, median[ind] def clac_entropy(y): uy, counts = np.unique(y, return_counts=True) probabilities = counts / counts.sum() ent = - np.sum(probabilities * np.log2(probabilities)) return ent import random class Random(Criterion): def __call__(self, x, y) -\u0026gt; tuple[int, int]: ind = random.randint(0, x.shape[1] - 1) median = np.median(x[:, ind]) return ind, median 使用与测试 #\r在breast cancer数据集上做测试。\nds = datasets.load_breast_cancer() x = np.array(ds.data) y = np.array(ds.target) x_train, x_test, y_train, y_test = train_test_split(x, y, test_size=0.2, shuffle=True) 借鉴了sklearn的api，所以使用方法基本是一致的。\ntree = MyDecisionTree(criterion= \u0026#39;gini\u0026#39;, max_depth=20) tree.fit(x_train, y_train) tree.score(x_train, y_train) tree.score(x_test, y_test) Output:\nAccuracy: 0.978021978021978\rAccuracy: 0.9473684210526315 效果还不错。\n后记 #\r还有很多东西可以实现，比如剪枝、计算熵和基尼指数的矩阵加速、属性贡献率等等。但是我懒得在这里花太多时间了，毕竟就算用到也不需要知道原理，我也不是搞机器学习的是吧。\n","date":"30 September 2024","externalUrl":null,"permalink":"/posts/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/%E5%86%B3%E7%AD%96%E6%A0%91/","section":"","summary":"决策树就是一颗 \u003ccode\u003eif-else\u003c/code\u003e 树。树的每一个结点代表一个决策（测试），同时也代表了这个决策所对应的一个样本空间。我们的目标就是通过多次产生 \u003ccode\u003eif-else\u003c/code\u003e 分支，尽可能地让决策树的叶子结点只\u0026hellip;","title":"决策树","type":"posts"},{"content":"\r日益增长的博客需要 #\r写博客这件事，从初三开始打竞赛就已经提上日程了。当时很草率地创建了一个洛谷博客，然后一篇文章都没有www。后来又存在各种阻力，例如高中的学业压力、只有周末接触电子设备的机会。但对博客与日俱增的需求的动力也在对冲这些阻力。从一开始只是希望总结竞赛算法，到现在的记录学业、技术、生活等等方面的需求。于是在大三开学刚转完专业能够摸鱼之际，我真正开始着手于部署一个能暂且满足以上需要的博客。\n博客搭建初期探索 #\r自建、自部署博客 #\r为什么会考虑自己搭建博客框架、自己部署，原因如下：\n有一台 阿里云ECS，宿舍有一台小服务器。可以锻炼部署能力，发扬折磨精神。顺便玩一下之前没怎么接触过的 Nginx 系统性地修补我支离破碎的前端知识，磨练后端技术，增加项目经历。以后干不下去了可以搞开发。 自建博客对日后变化的需求友好，可以随时迭代满足需要。而且能保证满足审美。 这几个原因看着很踏实，但是当我一开始写了我才发现自己根本没有这个时间和精力。光这一点便难以支撑了😭。\n日后对这一方案的评价：可以像 jyy wiki 写纯html没css的博客。但还是需要一点时间。\nWordPress #\r上一方案破产之后，我转而尝试他人已经写好的框架。要说这个世界上最著名的自建网站框架，WordPress肯定是首屈一指的，于是我在宿舍的小服务器上搭建了WordPress，过程还是很简单的，网上教程多如牛毛。\n于我而言，WordPress的优点有三：\n搭建方便。尤其是用 Docker，起两个容器就行了 美化方便。WordPress主题数不胜数，并且很多主题可以在后台用GUI自定义一些元素。 管理方便。WordPress后台功能齐全，界面还说的过去。 缺点也有几个：\n如果要开https，得每三个月续一次证书（虽然有工具可以自动化） 功能太多了，图形界面用起来压力很大。想尽量简洁和轻量 服务器反向代理时，我无法解决跨域请求资源的问题，我太菜了🤡 总之，用起来哪哪都有一点不舒服。但是我感觉WordPress这个框架整体还是相当强大的，用不下去的主要原因除了上述缺点，更多的是我当时不太愿意深入研究这个框架。说不定我以后会用WordPress。\n静态博客框架 #\r上面两个方案都是自部署的方案。除此之外便是托管部署了，比如 Vercel 和 Github Pages 这种。我真正愿意考虑这个方案的一大契机，是我的很多优秀学长的博客都是这个方案搭建的，而且看起来效果相当好。\n学长普遍是 Hexo 框架 + Github Pages 搭建。我也照做。当我在查阅 Hexo 框架的文档和资料时，了解到了另一个叫Hugo的框架。\n经过对比，我选择了Hugo框架。Hugo框架是基于Go语言实现的，比Hexo的Node.js编译快很多。但是于我而言最主要的原因还是我在Hugo的官方主题库里找到了心仪的主题BLowFish。\n最后，我习惯Typora编写文本，所以顺便配了阿里云oss做图床。再结合一些其他的需求，我目前的方案总结如下（PPT画的，不要在意拼写检查）：\n顺便一提，这样的技术栈图我还蛮喜欢的\n使用Hugo搭建博客 #\r基本信息配置 #\r基本信息配置主要在hugo.toml这个文件里。我的主题还有诸如params.toml、menus.zh-cn.toml等配置文件。所以这都根据具体主题而定。不过基本按照Hugo文档、主题提供的文档以及自己稍微理解一下就能顺利配置博客的基本信息了。我后面主要介绍一些难点和进阶的部分。\n内容目录结构 #\r可以参考Content organization | Hugo (gohugo.io)\n这部分是我比较诟病这类静态网页框架的一点，你的文章结构必须按照静态网页url里的结构来组织。比较正规的文件结构是这样的：\n","date":"28 September 2024","externalUrl":null,"permalink":"/posts/%E5%BB%BA%E8%AE%BE%E5%8D%9A%E5%AE%A2%E6%96%B0%E5%BE%81%E7%A8%8B/%E5%8D%9A%E5%AE%A2%E5%88%9D%E6%AD%A5%E6%90%AD%E5%BB%BA%E9%81%93%E8%B7%AF/","section":"","summary":"写博客这件事，从初三开始打竞赛就已经提上日程了。当时很草率地创建了一个洛谷博客，然后一篇文章都没有www。后来又存在各种阻力，例如高中的学业压力、只有周末接触电子设备的机会。但对博客与日俱增的需求的动\u0026hellip;","title":"博客初步搭建道路","type":"posts"},{"content":"","date":"28 September 2024","externalUrl":null,"permalink":"/categories/%E5%BB%BA%E8%AE%BE%E5%8D%9A%E5%AE%A2%E6%96%B0%E5%BE%81%E7%A8%8B/","section":"","summary":"","title":"建设博客新征程","type":"categories"},{"content":"\r起因 #\r由于手贱不小心删了Ubuntu自带的Python，服务器上的Ubuntu Server炸了。。。只能重新装一遍系统。但是我懒得做启动U盘了，所以索性直接在VMware里把系统给装起来。\n创建虚拟机并挂载物理磁盘 #\r只需要先下好你要装的系统的映象就行。然后把要装系统的硬盘装到你的电脑上。 还有很重要的一点，VMware一点要以管理员身份启动！不然Windows不让加物理磁盘！\n首先随便创建一个虚拟机，配置选自定义。\n在安装来源这里选稍后安装操作系统，或者直接选系统映象。\n安装位置随便选一个地方就行，反正等会就给他删掉了。我直接放桌面。\n内存、网络正常选就行。 I/O控制器选VMware推荐的LSI Logic，其他的应该也没差。\n虚拟磁盘类型选SATA或者NVMe，取决于你的物理磁盘是哪种类型的。我装在机械硬盘上，所以选SATA。\n然后重要的来了，使用哪个磁盘这里选择使用物理磁盘。\n这里如果没有用管理员身份启动VMware就会出问题：\n然后就是选哪个PhysicalDrive的问题。这个只需要右键此电脑-管理-磁盘管理里面看就行。\n可以看到磁盘0、磁盘1和磁盘2。这就对应着PhysicalDrive的编号。然后选择使用整个磁盘。 磁盘分区信息放桌面那里就行了。\n安装Ubuntu Server #\r创建好虚拟机之后，如果你之前创建虚拟机的时候没有选择映象的话，在虚拟机设置里面的CD/DVD中把映象选上去。然后启动时连接记得打开，不然\n然后在硬盘一项中点击高级，模式选择独立-永久\n然后就是正常的安装流程了。基本会一点英文就能顺利通过啦~\n","date":"27 September 2024","externalUrl":null,"permalink":"/posts/%E6%9C%89%E6%84%8F%E6%80%9D%E7%9A%84%E6%8A%98%E8%85%BE/%E4%BD%BF%E7%94%A8vmware%E7%BB%99%E7%89%A9%E7%90%86%E7%A1%AC%E7%9B%98%E8%A3%85%E7%B3%BB%E7%BB%9F/","section":"","summary":"由于手贱不小心删了Ubuntu自带的Python，服务器上的Ubuntu Server炸了。。。只能重新装一遍系统。但是我懒得做启动U盘了，所以索性直接在VMware里把系统给装起来。 只需要先下好你\u0026hellip;","title":"使用VMware给物理硬盘装系统","type":"posts"},{"content":"linux新增磁盘或增加磁盘容量后，如何进行扩容 - 知乎 (zhihu.com)\n有时间补一下我是怎么操作的。\n","date":"6 September 2024","externalUrl":null,"permalink":"/posts/%E6%9C%89%E6%84%8F%E6%80%9D%E7%9A%84%E6%8A%98%E8%85%BE/linux%E6%A0%B9%E7%9B%AE%E5%BD%95%E6%89%A9%E5%AE%B9/","section":"","summary":"有时间补一下我是怎么操作的。","title":"Linux根目录扩容","type":"posts"},{"content":"","date":"4 September 2024","externalUrl":null,"permalink":"/categories/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0/","section":"","summary":"","title":"操作系统设计与实现","type":"categories"},{"content":"\r开机-实模式到保护模式 #\r实模式到保护模式这个过程已经接触过很多次了。最早从软院OS实验的例行检查里背过相关内容，然后便不无意外地忘掉了。这次在OSDI课上又涉及到了这部分内容，趁此机会重温一下并写一个通俗易懂的笔记，以便以后查阅(可能并不会)。\n实模式 #\r摆龙门阵 #\rIntel为了兼容8086搞出来的玩意，在8、90年代很有用，但是对于现在来说还是太old-school了，所以新的UEFI启动方式已经渐渐取代了原来的BIOS，尽管我的装机U盘上的PE系统还保留了Legacy启动。\n这里还有个UEFI和BIOS的区别 - 知乎专栏，有时间再看。\n我想，实模式作为入门OS的很大原因在于UEFI比较复杂，大学计算机课程只能以BIOS为框架进行教学，所以绕不开这个实模式到保护模式的转换。并且这个转换的过程能体现操作系统内存虚拟化的很多芝士，比如段页式内存管理。所以这一部分内容的理解还是有助于成为操作系统领域大神的www。\n实模式小介绍 #\r摘自课程助教编写的实验文档\n在QEMU中，i386为了保持向后兼容性，一开机并不是我们熟悉的保护模式，而是实模式。\n实模式简单来说就是一个16位的CPU，和保护模式相比，最主要有三点区别：\n一是寄存器\n不一样，实模式里只会用我们熟悉的寄存器的低16位，所以名字就少了前缀“E”，具体地有：\n通用寄存器（16 位）：AX，BX，CX，DX，SP，BP，DI，SI 段寄存器（16 位）：CS，DS，SS，ES 状态和控制寄存器（16 位）： FLAGS，IP 二是寻址方式不一样，在实模式里，虽然有段寄存器，但没有保护模式里的段表，更没有页表，物理地址就是 (段寄存器\u0026laquo;4) + 偏移地址 。段寄存器16位，偏移地址也是16位，所以寻址空间就是2^20=1MiB。\n三是中断处理不一样，不过我们现在也不关心这个东西，有兴趣的话可以去搜索一下实模式的中断向量表，现在只需要大概知道中断都是由BIOS代办的就行了。\nBIOS执行过程以及两个模式 #\r启动的第一条指令地址是0xffff0。这个地址是BIOS ROM地址的最后，指令跳到ROM稍微靠前的地址[CS:IP] 0f000:E05Bh。这个地址开始执行BIOS POST。\n这里会立马发生很重要的一个转换，就是从实模式转成保护模式。\n原因是POST需要在保护下执行，否则实模式那点空间不够。\n自检完后通过INT 19h开始自举。\n自举就是依次把每个磁盘的0扇区加载到0x7c00然后看是不是MBR，即看扇区尾巴是不是0x55和0xaa，是的话自举滴任务就完成辣！\n其实还没有，自举谢幕前还要进行重要的一步，就是转换回实模式。\n原因是要向后提供兼容。不是i386之前的架构的请自觉转到保护模式。\n总结为如下图：\n实模式到保护模式 #\r这部分是写本文最主要的目的，所以单独拉一个标题来写。\n实模式到保护模式主要是两步：设置段表GDT，再将CR0寄存器最低位置1。\n现在先只涉及GDT，LDT不管。\n保护模式的寻址怎么实现 #\r保护模式比实模式牛的地方之一就是实现了段式内存管理。我们都知道段式内存管理本质就是个二维寻址。\n保护模式下的寻址方式如下：\n$$逻辑地址 = 段选择子_{16bits} \\implies 段基址_{32bits} + 段内偏移_{32bits}$$段选择子，可以根据字面意思理解记忆，就是记录选择了哪个段的东西。它存放在段寄存器中。\n所以怎么从段选择子拿到段基址呢？这就要靠**段表**了。\n段表细节见后面小标题，这里只需要知道通过段选择子能找到段表中正确的项，而这个项(有名字，叫段描述符)含有我们想要的很多信息，主要就是段基址。\n实验中提到了\u0026quot;扁平模式\u0026quot;，即将段基址全置0，这样偏移量就直接是逻辑地址了。\n这样就实现了保护模式的寻址。\n段表 #\r段表是个一位线性表。表项是前面说的段描述符，一个段描述符有64位，下面粗略说一下段描述符有哪些信息。\n段基址：最主要的信息之一。占32位。 段限长：段的长度，保证内存访问不会越界。也比较重要，占20位。 其他控制位。包括段限长粒度、特权位等。 详细来说，如下\nDESCRIPTORS USED FOR APPLICATIONS CODE AND DATA SEGMENTS\r31 23 15 7 0\r+-----------------+-+-+-+-+---------+-+-----+-+-----+-+-----------------+\r| | | | |A| | | | | | | |\r| BASE 31..24 |G|X|O|V| LIMIT |P| DPL |S| TYPE|A| BASE 23..16 | 4\r| | | | |L| 19..16 | | | | | | |\r|-----------------+-+-+-+-+---------+-+-----+-+-----+-+-----------------|\r| | |\r| SEGMENT BASE 15..0 | SEGMENT LIMIT 15..0 | 0\r| | |\r+-----------------------------------+-----------------------------------+\rA - ACCESSED\rAVL - AVAILABLE FOR USE BY SYSTEMS PROGRAMMERS\rDPL - DESCRIPTOR PRIVILEGE LEVEL\rG - GRANULARITY\rP - SEGMENT PRESENT 具体大致看一下就行了，毕竟真要用到也不会有人记得清的。\n另外，这个段表的访问也大有学问。段表的基址和长度放在一个叫GDTR的寄存器里。\nGDT REGISTER\r+--------------------------------+---------------+\r| GDT BASE | GDT LIMIT |\r+--------------------------------+---------------+\r47 15 0 段选择子 #\r以下内容直接copy于实验手册\n15 3 1 0\r+-------------------------+-+---+\r| |T| |\r| INDEX | |RPL|\r| |I| |\r+-------------------------+-+---+\rTI - TABLE INDICATOR, 0 = GDT, 1 = LDT\rRPL - REQUESTOR\u0026#39;S PRIVILEGE LEVEL TI位表示该段选择子为全局段（查GDT）还是局部段（查LDT），实验中只会用到前者，RPL表示该段选择子的特权等级，13位Index表示描述符表中的编号（下标）。\n结合虚拟地址、段选择符和段表的相关概念，在分段机制中，将虚拟地址转换成线性地址（此时即为物理地址）的过程可描述如下：\n根据段选择子中的TI位选择GDT或LDT（总是GDT）； 根据段选择子中的index部分到GDT中找到对应位置上的段描述符； 读取段描述符中的base部分，作为32位段基址（总是0），加上32位段内偏移量获取最终的物理地址。 总结 #\r这部分内容最重要的就是为什么需要保护模式、保护模式下的寻址以及段表和段选择子是什么东西。这部分搞懂了基本就没什么问题了。\n在OS设计与实现的实验里这部分比较简单，概念搞清楚几行代码就搞定了。\n","date":"4 September 2024","externalUrl":null,"permalink":"/posts/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0/%E5%AE%9E%E6%A8%A1%E5%BC%8F%E5%88%B0%E4%BF%9D%E6%8A%A4%E6%A8%A1%E5%BC%8F/","section":"","summary":"实模式到保护模式这个过程已经接触过很多次了。最早从软院OS实验的例行检查里背过相关内容，然后便不无意外地忘掉了。这次在OSDI课上又涉及到了这部分内容，趁此机会重温一下并写一个通俗易懂的笔记，以便以后\u0026hellip;","title":"实模式到保护模式","type":"posts"},{"content":"\r内网穿透折腾记录 #\r还是草稿，以后有时间写\n在宿舍里搞了一台ubuntu server折腾用。想在校园网的特殊环境下实现外网访问内网的需求，从而能随时使用个人博客与code server等服务。\n以下为我在大二开学诞生这个需求，直到大三开学才基本实现的一整年的折腾过程的记录。由于计算机网络方面的知识十分浅薄（日常吐槽计网），文章中可能会出现十分多不专业的内容，欢迎各位大佬勘误与科普。同时也给正在折腾的朋友们一些十分不严谨的参考。\nFirst try #\r使用第三方frp/ngrok方案。\n这个方案源自于和朋友联机minecraft的经历。Minecraft服务器架设在内网端口，但可以通过一些frp服务来暴露到一个域名上，从而通过这个域名就能访问到mc服务器。\n对于其他的内网服务，这个方案基本也是可行的。好了问题解决了，这篇文章可以结束了。\n并不能。这种方案太不优雅了。临时使用的话现成frp或ngrok很不错。\n但是，使用现成frp缺点很多无法忍受：\n极小的带宽。一般免费隧道带宽只有3M以内，付费也就10M封顶。如果是好几个人一起玩mc或者传个文件啥基本就爆了。 限流量。之前用的好几个frp的流量都有每日签到领取，这个太难绷了。 随机域名/定死的顶级域名。没法用自己的域名，这个接受程度因人而异。 安全问题。数据都要走服务商那里转发，如果服务商被hack了就相当于裸奔了，不安全。 隧道数限制、校园网拦截等等 frp用了一两天后我直接关隧道跑路了，还是寻求其他方案吧。\nSecond try: #\r这次的方案转向了一个更加普遍的方案，就是直接通过某种方法拿到本机的公网IP。\n这种方案对于家里宽带有公网IPv4的十分方便且自由。但现在运营商基本不给公网ip了，所以IPv4基本走不通。\n但是，号称每一粒沙子都能分到地址的IPv6似乎就宽松很多了。如果能拿到服务器的IPv6地址，再绑个ddns，似乎基本就能实现我们的需求。\n开干。但是经历了九九八十一难，最终还是没能成功。\n第一难是路由器。我的路由器型号是Redmi 4A，官方的固件虽说能拿到IPv6的IP，但是没法关闭防火墙放行IPv6的出站流量。所以我给路由器刷了一个openwrt。\n第二难是openwrt。由于之前没接触过刷机，所以在找刷机包和编译上花了很多时间。最后还是用了大佬做好的刷机包。还好这个过程有breed防砖，不然路由器已经死了一百遍了。\n第三难是校园网IPv6分配。openwrt中获取到IPv6地址了，但是校园网的v6地址是/128的，也就是说真的只分配了一个地址，没法组子网。这个地址直接分给路由器了，路由器下的内网设备如果要以IPv\n6向外提供服务，就只能通过NAT6。这个NAT6难搞得一比，主要原因是路由器存储空间太小了，没法安装直接配置NAT6的插件。\n最后在这一步放弃了，因为在一次测试中突然发现了校园网是个大内网，你的路由器能上行不代表校园网中层层墙能让你上行……\n还有一个大问题。IPv6的站点只能由支持IPv6的设备访问，而就目前IPv6的普及情况……估计半数以上的情况都访问不了。\nThird try #\r第二次尝试失败后，由于学业繁忙，折腾的进程陷入停滞……\n转机在软工II课上，我为课程项目的后端购买了一个阿里云ECS。使用ecs一段时间后，我突然想到，能不能将ecs的公网IP，用在我的内网服务上呢？\n答案是肯定的。这种利用云服务器实现内网穿透的方案就是代理。\n出问题辣 #\r通过公网服务器端口访问内网服务时，如果内网服务是像wordpress这种比较复杂的网页，就会发生一系列错误的重定向。\n以我的wordpress博客举例，访问websiteIP:port的链接后，wp会返回301重定向，这个重定向会转到一系列链接\nReference #\r如何用阿里云实现内网穿透？如何在外网访问家里内网设备？-阿里云开发者社区 (aliyun.com)\nffdfgdfg/nps - Docker Image | Docker Hub\n","date":"1 September 2024","externalUrl":null,"permalink":"/posts/%E6%9C%89%E6%84%8F%E6%80%9D%E7%9A%84%E6%8A%98%E8%85%BE/nps%E6%8A%98%E8%85%BE%E8%AE%B0%E5%BD%95/","section":"","summary":"在宿舍里搞了一台ubuntu server折腾用。想在校园网的特殊环境下实现外网访问内网的需求，从而能随时使用个人博客与code server等服务。 以下为我在大二开学诞生这个需求，直到大三开学才基\u0026hellip;","title":"NPS折腾记录","type":"posts"},{"content":"\r评价指标 #\r混淆矩阵、精度矩阵 #\r精度矩阵是二分类下的混淆矩阵\n精度矩阵下的名词 #\rTRUE/FALSE: 预测结果与实际相符/不符\nPOSITIVE/NEGATIVE: 预测为真(阳性)/假(阴性)\n算术指标 #\rAccuracy 精度\n预测正确的比例 Sensitivity 敏感率\n同查全率 Specificity 特异率\n阴性里预测正确的比例 Precision 查准率\n预测为阳性中真的阳了的比例 Recall 查全率\n所有阳性中预测出来的比例 统计学基本概念 #\r距离度量函数 #\r对于两个样本 $x_i,x_j\\in R^d$\n欧式距离 $d(x_i, x_j)= \\sqrt{(x_i-x_j)^T(x_i-x_j)}=||x_i-x_j||_2$ 曼哈顿距离 $d(x_i, x_j)=||x_i-x_j||_1$ 切比雪夫距离 $d(x_i, x_j)=||x_i-x_j||_\\infty$ 余弦距离 $d(x_i, x_j)=\\frac{x_i^Tx_j}{||x_i||\\ ||x_j||}$ 马式距离 $d(x_i, x_j)=\\sqrt{(x_i-x_j)^TM(x_i-x_j)}$ ","date":"16 August 2024","externalUrl":null,"permalink":"/posts/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/%E6%A6%82%E8%A6%81/","section":"","summary":"精度矩阵是二分类下的混淆矩阵 \u003ccode\u003eTRUE\u003c/code\u003e/\u003ccode\u003eFALSE\u003c/code\u003e: 预测结果与实际相符/不符 \u003ccode\u003ePOSITIVE\u003c/code\u003e/\u003ccode\u003eNEGATIVE\u003c/code\u003e: 预测为真(阳性)/假(阴性) 对于两个样本 $xjin R^d$","title":"概要","type":"posts"},{"content":"","date":"14 August 2024","externalUrl":null,"permalink":"/categories/%E9%9A%8F%E8%AE%B0/","section":"","summary":"","title":"随记","type":"categories"},{"content":"\rMock和@Test注解 #\r@Test注解一定要是import org.junit.Test！如果是org.junit.jupiter.api.Test会导致Mock的对象全部为null\n","date":"14 August 2024","externalUrl":null,"permalink":"/posts/%E9%9A%8F%E8%AE%B0/%E9%9A%8F%E8%AE%B0/","section":"","summary":"@Test注解一定要是\u003ccode\u003eimport org.junit.Test\u003c/code\u003e！如果是\u003ccode\u003eorg.junit.jupiter.api.Test\u003c/code\u003e会导致Mock的对象全部为\u003ccode\u003enull\u003c/code\u003e","title":"随记","type":"posts"},{"content":"","date":"23 June 2024","externalUrl":null,"permalink":"/categories/%E6%AF%9B%E6%A6%82/","section":"","summary":"","title":"毛概","type":"categories"},{"content":"\r毛概复习-甘季国 #\r导论 #\r马克思主义中国化时代化的内涵 #\r马克思主义中国化时代化，就是\n立足中国国情和时代特点，坚持把马克思主义基本原理同中国具体实际相结合、同中华优秀传统文化相结合，深入研究和解决中国不同历史时期的实际问题，真正搞懂面临的时代课题，不断吸收新的时代内容，科学回答时代提出的重大理论和实践课题，创造新的理论成果。 马克思主义中国化时代化理论成果及其关系 #\r成果 #\r在马克思主义中国化时代化的历史进程中，产生了毛泽东思想、邓小平理论、“三个代表”重要思想、科学发展观、习近平新时代中国特色社会主义思想\n关系 #\r马克思主义中国化时代化的理论成果是一脉相承又与时俱进的关系。\n一方面，毛泽东思想所蕴含的马克思主义的立场、观点和方法，为中国特色社会主义理论体系提供了基本遵循。\n另一方面，中国特色社会主义理论体系在新的历史条件下进一步丰富和发展了毛泽东思想。\n毛泽东思想和中国特色社会主义理论体系，都是马克思列宁主义在中国的运用和发展，都以独创性的理论成果丰富和发展了马克思主义的理论宝库。\n毛泽东思想、邓小平理论、“三个代表”重要思想、科学发展观、习近平新时代中国色社会主义思想同马克思列宁主义一起，都是党和国家必须长期坚持的指导思想，是全国各族人民团结奋斗的共同思想基础。\n第二章 新民主主义革命理论 #\r新民主主义革命的总路线 #\r新民主主义革命总路线：无产阶级领导的、人民大众的、反对帝国主义、封建主义和官僚资本主义的革命。\n反映了中国革命的基本规律，指明了中国革命的对象、动力、领导力量、性质和前途，是新民主主义革命的指导路线。\n新民主主义的基本纲领 #\r政治纲领：推翻帝国主义和封建主义的统治，建立一个无产阶级领导的、以工农联盟为基础的、各革命阶级联合专政的新民主主义的共和国。 经济纲领：没收封建地主阶级的土地归农民所有，没收官僚资产阶级的垄断资本归新民主主义的国家所有，保护民族工商业。 文化纲领：新民主主义文化，就是无产阶级领导的人民大众的反帝反封建的文化，即民族的科学的大众的文化。 新民主主义革命的道路 #\r农村包围城市、武装夺取政权的革命道路\n内容：\n土地革命是中国革命的基本内容； 武装斗争是中国革命的主要形式，是农村根据地建设和土地革命的强有力保证； 农村革命根据地是中国革命的战略阵地，是进行武装斗争和开展土地革命的依托 新民主主义革命的三大法宝 #\r统一战线 武装斗争 党的建设 关系：\n统一战线和武装斗争是中国革命的两个基本特点，是战胜敌人的两个基本武器。 统一战线是实行武装斗争的统一战线，武装斗争是统一战线的中心支柱 党的建设则是掌握统一战线和武装斗争这两个武器的基本保障。 新民主主义革命理论的意义 #\r新民主主义革命理论，揭示了近代中国革命发展的客观规律，解决了中国革命的一系列理论问题，科学地回答了中国革命向何处去的问题，以及中国革命的发展阶段问题，极大地丰富了马克思主义的理论宝库。 在新民主主义革命理论的指导下，党团结带领人民经过浴血奋战，完成了新民主主义革命，于1949年建立了中华人民共和国，实现了民族独立、人民解放。 中国新民主主义革命的伟大胜利，是20世纪继俄国十月革命以后改变世界面貌的伟大历史事件，也极大改变了世界政治格局，鼓舞了全世界被压迫民族和被压迫人民争取解放的斗争，极大地增强了他们反对帝国主义斗争的信心，增强了世界人民争取和平的力量。 第三章 社会主义改造理论 #\r新民主主义社会是一个过渡性的社会 #\r从中华人民共和国成立到社会主义改造基本完成，是我国从新民主主义到社会主义的过渡时期。这一时期，我国社会的性质是新民主主义社会。新民主主义社会不是一个独立的社会形态，而是由新民主主义向社会主义转变的过渡性社会形态。\n党在过渡时期的总路线及其依据 #\r从中华人民共和国成立，到社会主义改造基本完成，这是一个过渡时期。党在这个过渡时期的总路线和总任务，是要在一个相当长的时期内，逐步实现国家的社会主义工业化，并逐步实现国家对农业、对手工业和对资本主义工商业的社会主义改造。\n现实依据\n经过1949年到1952年三年的努力，我国已经有了相对强大和迅速发展的社会主义国营经济，为党提出向社会主义过渡的总路线提供了物质基础。\n土地改革完成后，为发展生产、抵御自然灾害，广大农民具有走互助合作道路的要求。\n新中国成立初期，党和国家在合理调整工商业的过程中，出现了加工订货、经销代销、统购包销、公私合营等一系列从低级到高级的国家资本主义形式。\n当时的国际形式有利于中国向社会主义过渡。\n社会主义基本制度的确立及其理论根据 #\r确立\n1956年底，我国对农业、手工业和资本主义工商业的社会主义改造基本完成，农业、手工业个体所有制基本上转变成为公有制。 随着社会主义改造的进行，我国的人民民主政治建设也在有步骤地向前推进。 伴随着社会经济制度和社会经济结构的根本变化，我国社会的阶级关系也发生了根本的变化。 理论\n一方面，中国可以在没有实现工业化的情况下进入社会主义，社会主义基本制度的确立正是为了推进中国的工业化、现代化建设; 另一方面，由于经济文化还比较落后，中国的社会主义还只能是初级阶段的社会主义。不经过社会生产力的极大发展,是不可能超越这个阶段的 确立社会主义基本制度的重大意义 #\r社会主义基本制度的确立，为当代中国一切发展进步奠定了制度基础。社会主义制度的建立极大地提高了工人阶级和广大劳动人民的积极性、创造性，极大地促进了我国社会生产力的发展 我国社会生产力的发展，初步显示了社会主义的优越性 实现中华民族伟大复兴，必须建立符合我国实际的先进社会制度 中国社会主义基本制度的确立，使占世界人口 1/5的东方大国进入了社会主义社会，这是世界社会主义发展史上又一个历史性的伟大胜利 社会主义基本制度的确立，是以毛泽东同志为主要代表的中国共产党人对一个脱胎于半殖民地半封建的东方大国如何进行社会主义革命问题的系统回答和正确解决，是马克思列宁主义关于社会主义革命理论在中国的正确运用和创造性发展的结果 第四章 社会主义建设道路初步探索的理论成果 #\r初步探索的重要理论成果 #\r调动一切积极因素为社会主义事业服务\n正确认识和处理社会主义社会矛盾的思想\n走中国工业化道路的思想\n初步探索的意义和经验教训 #\r意义\n巩固和发展了我国的社会主义制度 为开创中国特色社会主义提供了宝贵经验、理论准备、物质基础 丰富了科学社会主义的理论和实践 教训(怎么做)\n必须把马克思主义与中国实际相结合，探索符合中国特点的社会主义建设道路 必须正确认识社会主义社会的主要矛盾和根本任务，集中力量发展生产力 必须从实际出发进行社会主义建设，建设规模和速度要与国力相适应，不能急于求成 必须发展社会主义民主，健全社会主义法制 必须坚持党的民主集中制和集体领导制度，加强执政党建设 必须坚持对外开放，借鉴和吸收人类文明成果建设社会主义，不能关起门来搞建设 第六章 邓小平理论 #\r邓小平理论首要的基本的理论问题 #\r什么是社会主义，怎样建设社会主义\n强调解放和发展生产力在社会主义社会发展中的重要地位，纠正了过去关于发展生产力的一些错误观念，反映了中国社会主义整个历史阶段尤其是初级阶段特别需要注重生产力发展的迫切要求，并明确了社会主义基本制度建立后还要通过改革进一步解放生产力 强调“消灭剥削，消除两极分化，最终达到共同富裕”，从生产关系和发展目标角度认识和把握社会主义本质 邓小平理论的精髓 #\r解放思想、实事求是\n邓小平理论的主要内容 #\r社会主义初级阶段理论和党的基本路线 #\r第一，我国社会已经是社会主义社会。我们必须坚持而不能离开社会主义。第二，我国的社会主义社会还处在初级阶段。我们必须从这个实际出发，而不能超越这个阶段。 党的基本路线：领导和团结全国各族人民，以经济建设为中心，坚持四项基本原则，坚持改革开放(一个中心，两个基本点)，自力更生，艰苦创业，为把我国建设成为富强、民主、文明的社会主义现代化国家而奋斗 四项基本原则：坚持社会主义道路、坚持人民民主专政、坚持共产党的领导、坚持马列主义毛泽东思想 社会主义根本任务和发展战略理论 #\r社会主义的根本任务是发展生产力 三步走 的发展战略 到1990年，实现国民生产总值比1980年翻一番，解决人民的温饱问题 到20世纪末，使国民生产总值再增长一1倍，人民生活达到小康水平 到21世纪中叶，人均国民生产总值达到中等发达国家水平，人民生活比较富裕，基本实现现代化。 社会主义改革开放和社会主义市场经济理论 #\r改革是社会主义社会发展的直接动力 一是计划经济和市场经济不是划分社会制度的标志，计划经济不等于社会主义，市场经济也不等于资本主义； 二是计划和市场都是经济手段，对经济活动的调节各有优劣，社会主义实行市场经济是要把两者优势结合起来； 三是市场经济作为资源配置手段本身不具有制度属性，可以和不同的社会制度结合，从而表现出不同的性质。坚持社会主义制度与市场经济的结合，是社会主义市场经济的特色所在、优势所在 中国特色社会主义外交和国际战略 #\r邓小平理论的历史地位 #\r邓小平理论是马克思列宁主义基本原理同当代中国实际和时代特征相结合的产物，是对马克思列宁主义、毛泽东思想的继承和发展，是全党全国人民集体智慧的结晶。 是中国特色社会主义理论体系的开篇之作。邓小平理论第一次比较系统地初步回答了建设中国特色社会主义的一系列基本问题，包括社会主义初级阶段理论，党在社会主义初级阶段的基本路线等，形成了一个比较完备的科学体系。 是改革开放和社会主义现代化建设的科学指南。邓小平理论指导了改革开放的伟大实践。 第七章 “三个代表”重要思想 #\r回答了：建设一个怎么样的党、怎样建设党\n“三个代表”重要思想的核心观点 #\r始终代表中国先进生产力的发展要求 始终代表中国先进文化的前进方向 始终代表中国最广大人民的根本利益 “三个代表”重要思想的主要内容 #\r发展是党执政兴国的第一要务 建立社会主义市场经济体制 坚持和完善公有制为主体，多种所有制经济共同发展的社会主义基本经济制度 全面建设小康社会 建设社会主义政治文明 实施“引进来”和“走出去”相结合的对外开放战略 推进党的建设新的伟大工程 第八章 科学发展观 #\r科学发展观的科学内涵 #\r推动经济社会发展是科学发展观的第一要义 以人为本是科学发展观的核心立场 全面协调可持续是科学发展观的基本要求 统筹兼顾是科学发展观的根本方法 科学发展观的主要内容 #\r加快转变经济发展方式 发展社会主义民主政治 推进社会主义文化强国建设 构建社会主义和谐社会 推进生态文明建设 全面提高党的建设科学化水平 ","date":"23 June 2024","externalUrl":null,"permalink":"/posts/%E6%AF%9B%E6%A6%82/%E6%AF%9B%E6%A6%82/","section":"","summary":"马克思主义中国化时代化，就是 1. 立足中国国情和时代特点，坚持把马克思主义基本原理同中国具体实际相结合、同中华优秀传统文化相结合，深入研究和解决中国不同历史时期的实际问题，真正搞懂面临的时代课题，不\u0026hellip;","title":"毛概","type":"posts"},{"content":"\r信号量与PV操作习题 #\r读者写者问题 #\rv1-读者优先策略 #\rrmutex的理解\n可以理解为更新临界资源readcount的坑位，同一时间只允许一个reader蹲在那里更新readcount 理发师问题 #\r一个理发师、一把理发椅、等候区容量N\n理发师：等候区有顾客就理发，没顾客睡觉\n顾客：等候区不满就进等候区，在等候区如果理发师睡觉就叫醒；等候区满就不理发了\n重要思想 #\r协同信号量: waiting \u0026lt;-\u0026gt; customers\nwaiting变量和customers信号量是一对协同量，二者意义相同，数值也相同(除了customer可能为-1)。 所以要用mutex信号量去保证二者在有顾客的时候是同步变化的，这样去理解mutex就容易的多了 为什么？因为我们要判断if(waiting\u0026lt;CHAIRS)，假如没有waiting，我们就得判断if(customers\u0026lt;CHAIRS)，但是用户代码直接访问信号量的操作是不被允许的 ","date":"24 May 2024","externalUrl":null,"permalink":"/posts/se%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/ex6-%E4%BF%A1%E5%8F%B7%E9%87%8F%E4%B8%8Epv%E6%93%8D%E4%BD%9C%E4%B9%A0%E9%A2%98/","section":"","summary":"rmutex的理解 : waiting customers","title":"Ex6 信号量与PV操作习题","type":"posts"},{"content":"","date":"24 May 2024","externalUrl":null,"permalink":"/categories/se%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/","section":"","summary":"","title":"SE操作系统","type":"categories"},{"content":" 解释中断向量 中断向量是确定中断服务程序的位置。包含段基址和偏移量。\n解释中断类型码 把每个中断服务程序进行编号，一个号代表一个中断服务程序，就是中断类型码，是计算机用来查找中断向量用的。(0-255)\n解释中断向量表 一片专门用来存放所有的中断向量的内存空间。\n在内存单元的最低处，地址空间为 00000H-003FFH (0-1024B)\n中断类型码 * 4 = 中断向量的首地址\n中断向量表提供了中断类型码与中断处理代码段入口地址的映射。\n实模式下中断程序地址如何得到? 根据中断类型码 n, 从中断向量表 n*4，取得中断处理程序的地址，段地址存入 CS，偏移量存入 IP，使得 CPU 转入中断程序运行。\n保护模式下中断程序地址如何得到? 以 IDTR 中中断向量表的基址为起始地址 + 调用号 N*8 = 中断门描述符首地址，取出中断门的 8 个字节\n根据中断门的选择子和偏移量得到中断处理程序入口\n中断向量的地址如何得到? 中断类型码 * 4\n实模式下如何根据中断向量的地址得到中断程序地址? 低二字节为偏移量，高二字节为段地址\n解释中断描述符 中断描述符含有中断处理程序地址信息，还包括许多属性和类型位\n每个中断描述符占用连续的8个字节，中断描述符分为三类：任务门、中断门和自陷门，CPU对不同的门有不同的处理方式\n低1，2字节和高7，8字节存偏移量\n2，3字节是段选择符\n4，5字节是访问权限字节\n保护模式下中断描述符表如何得到? 通过IDTR读取IDT的基地址。\n保护模式下中断门如何得到? IDT基地址+中断类型码*8\n保护模式下如何根据中断门得到中断处理程序地址? 中断门中的段选择符-\u0026gt;段基址 + 偏移量\n中断的分类，举例不同类型的中断? 从中断源的角度： 内部异常中断：由硬件异常或故障引起的\n软中断：程序执行了中断指令引起的中断，由程序员通过 INT 或 INT3 指令触发，通常当做 trap 处理，实现系统调用\n外部中断 / IO 中断：外部设备请求引起的中断（又可分为可屏蔽中断（INTR 引脚）和不可屏蔽中断（NMI 引脚）：重启、电源故障、内存出错等影响整个系统工作的中断时不能被屏蔽的）\n以 CPU 为界： 中断：CPU 以外的事件引起的中断（IO 中断、时钟中断、控制台中断等）\n异常：CPU 内部事件或程序执行中的事件引起的过程（除数为 0，CPU 本身故障、请求系统服务指令）\n中断与异常的区别? 狭义中断：CPU 以外的事件引起的中断（IO 中断、时钟中断、控制台中断等）\n异常：CPU 内部事件或程序执行中的事件引起的过程（除数为 0，CPU 本身故障、请求系统服务指令）\n实模式和保护模式下的中断处理差别 最大区别在于寻找中断处理代码入口的方式\n实模式：中断类型码 * 4 (中断向量表)\n保护模式：IDTR-\u0026gt;IDT中的中断描述符-\u0026gt;段基址+偏移\n如何识别键盘组合键（如 Shift+a）是否还有其他解决方案? 按下一个按键时检测之前或者此时是否有组合键的Make Code 记录特殊按键的状态，按下一般按键时检测其状态以确定组合键 IDT 是什么，有什么作用? 中断描述符表\n可以通过中断号 * 8访问对应中断描述符，进而得到中断处理程序的地址等信息\nIDT 中有几种描述符? 三种\n中断门描述符\n陷阱门描述符\n任务门描述符\n异常的分类? Fault：可被更正的异常，一旦被更正，程序可以不失连续性继续执行，返回地址是产生 fault 的指令。\nTrap：在发生 trap 的指令执行之后立即被报告的异常，也允许程序不失连续性继续执行，返回地址为产生 trap 的指令之后的那条指令。\nAbort：不总是报告精确异常发生位置的异常，不允许程序继续执行，用来报告严重错误的。\n用户态和内核态的特权级分别是多少? 3, 0\n中断向量表中，每个中断有几个字节?里面的结构是什么? 4个字节。高二字节 = 段地址，低二字节 = 偏移量\n中断异常共同点（至少两点），不同点（至少三点） 共同点：\n都是程序执行过程中的强制性转移，转移到相应的处理程序\n都是软件或硬件发生了某种情形而通知处理器的行为。\n不同点：\n中断是 CPU 具备的功能，通常因为硬件而随机发生；异常时软件运行过程中的一种开发过程中没有考虑到的程序错误。\n中断是 CPU 暂停当前工作，有计划地去处理其他事情，其发生一般是可预知的，处理过程也是实现制定好的，处理中断时程序是正常运行的；异常是 CPU 遇到了无法响应的工作，而进入一种非正常状态，异常的出现表明程序有缺陷。\n中断是异步的，是来自指令流之外的；异常是同步的，是来自指令流内部的。\n中断或异常的返回点。良性如中断和 trap，处理程序完了后返回到原指令流的下一条指令；恶性如 fault 和 abort，对于可修复 fault，会重新执行该指令，对于不可修复 fault 或 abort，则不会再返回。\n中断是由与当前程序无关的中断信号触发的，CPU 对中断的响应是被动的，且与 CPU 模式无关。既可以发生在内核态也可以发生在用户态；异常是由 CPU 控制单元产生的，大部分异常发生在用户态。\n","date":"22 May 2024","externalUrl":null,"permalink":"/posts/se%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/lab3/","section":"","summary":"中断向量是确定中断服务程序的位置。包含段基址和偏移量。 把每个中断服务程序进行编号，一个号代表一个中断服务程序，就是中断类型码，是计算机用来查找中断向量用的。(0-255) 一片专门用来存放所有的中断\u0026hellip;","title":"Lab3","type":"posts"},{"content":"","date":"21 May 2024","externalUrl":null,"permalink":"/categories/%E8%BD%AF%E5%B7%A5ii%E5%A4%A7%E4%BD%9C%E4%B8%9A-%E8%93%9D%E9%B2%B8%E5%95%86%E5%9F%8E/","section":"","summary":"","title":"软工II大作业-蓝鲸商城","type":"categories"},{"content":"\r商品推荐算法初探 #\r分析 #\r项目情况 #\r蓝鲸网购商城，这个问题域下涉及的对象只有商品和用户。这两个对象和推荐算法相关的属性有如下：\n商品 名称 分类 价格 图片等复杂信息 用户 商品访问记录 访问次数 商品购买记录(订单) 订单价格 商品评分记录 评分 需求 #\r能应对相对大量用户和商品的系统 算法必须能在2核2g的服务器上正常运行 使用在线算法 约束 #\r开发时间紧张 用户量和商品量十分小 可能有方法会改善这个情况，比如自动化生成工具 用户行为数据有限 因为要人工操作。但是同上。 算法的选择 #\r基于用户的协同过滤-User CF #\r核心思想：人以群分，推荐和你最相似的用户喜欢的商品\n优点 #\r在线算法 实现简单 效率高 缺点 #\r十分依赖于其他用户和商品的交互数据。交互越多推荐效果越好。 基于交互，会同时涉及用户和商品两个模块 基于商品的协同过滤-Item CF #\r核心思想：物以类聚，推荐和你喜欢的商品最相似的商品，相似度基于交互\n优点 #\r没怎么细看，我姑且认为这个更加准确吧\n缺点 #\r算法要求先离线处理所有商品的相似度 效率较慢 基于交互，会同时涉及用户和商品两个模块 基于内容的推荐算法 #\r核心思想：物以类聚，推荐和你喜欢的商品最相似的商品，相似度基于商品属性\n优点 #\r自然。推荐商品最直接、朴素的想法就是推荐内容相似的物品啦。\n静态。基于商品稳定的属性。不用依赖于不稳定的用户与商品的交互。\n缺点 #\r实现上不如前两种算法那么规范，主观性比较大。 ","date":"21 May 2024","externalUrl":null,"permalink":"/posts/%E8%BD%AF%E5%B7%A5ii%E5%A4%A7%E4%BD%9C%E4%B8%9A-%E8%93%9D%E9%B2%B8%E5%95%86%E5%9F%8E/%E6%8E%A8%E8%8D%90%E7%AE%97%E6%B3%95%E5%88%9D%E6%8E%A2/","section":"","summary":"蓝鲸网购商城，这个问题域下涉及的对象只有和。这两个对象和推荐算法相关的属性有如下： 没怎么细看，我姑且认为这个更加准确吧","title":"推荐算法初探","type":"posts"},{"content":"\r第五章-文件管理 #\r5.1-文件系统概述 #\r引入文件的优点 #\r用户使用方便，按名存取 文件安全可靠 文件可备份 文件可共享 文件系统的功能 #\r面向用户 按名存取 共享和保护 操作和使用 OS要实现 文件目录的建立与维护 存储空间的分配和回收 数据安全 用户权限 5.2-文件的存储 #\r物理文件 #\r卷：介质的物理单位\n块：主存储器和辅助存储器进行信息交换的物理单位，也叫物理记录\n逻辑文件 #\r流式文件 #\r文件中的数据是一串没有结构的字符流，比如一串字符串组成的文件\n记录式文件 #\r若干逻辑记录信息所组成的记录流文件。逻辑记录是逻辑上的一坨信息的单位\n逻辑记录的成组与分解 #\r这个条目解决了从逻辑记录大小和物理记录大小的不匹配的问题\n优点 #\r节省存储空间 减少IO次数 特点 #\r提前读：因为一次读了多个逻辑记录\n推迟写：要缓冲区逻辑记录满了才写\n长记录 #\r变长记录 #\r跨块记录 #\r文件的物理结构 #\r这个条目解决了从逻辑记录存到物理记录的组织\n顺序文件 #\r逻辑记录——线性排列——\u0026gt;物理记录\n优点：顺序读取快\n缺点：无法动态分配、修改\n连接文件 #\r逻辑记录——链表——\u0026gt;物理记录\n优点：能动态增长与修改\n缺点：读取必须从头顺序读\n直接文件 #\r逻辑记录——Hash——\u0026gt;物理记录\n优点：动态、即时读取\n缺点：哈希冲突\n⭐索引文件 #\r逻辑记录——索引表——\u0026gt;物理记录\n优点：动态、“半“即时读取\n缺点：建表空间开销和查表时间开销\n通常是多级索引。多级索引的项指向了一个目录块\n5.3-文件的目录结构 #\r文件目录是实现按名存取的重要结构\n如其名，就是个目录。既可能是像书那样的线性目录，也可能是树形目录\n目录结构的分类 #\r一级目录结构 #\r一张线性表当目录\n评价：所有用户共享、文件还不能重名，所以这样很混乱\n二级目录结构 #\r第一级目录按用户分，第二级就是对应用户的文件目录\n评价：用户的问题解决了，但是对单个用户来说还是很难用\n树形目录结构 #\r层次性的目录结构，既可以是森林(Windows)，也可以是一颗树(UNIX)\n评价：层次关系能反映现实的关系、文件可以重名、每个子树都可以设置权限等机制\n活动文件表 #\r解决查目录的访辅存问题，给每一个进程建立一个活动文件表\n用文件之前，通过OS提供的“打开文件”操作，文件的有关目录被放到主存的活动文件表\n不用文件了就关掉，并且把修改过的内容写回辅存\n⭐inode #\r直观理解：从文件名到inode号的映射\ninode区 #\r在磁盘上，保存了诸多inode项\ninode项 #\r保存了inode号、inode引用数、inode所在设备等信息\n更重要的，保存了文件的索引表\n活动/动态inode #\r类比活动文件表，把活跃的inode从磁盘里复制到主存\n静态inode就是磁盘里inode区存的一堆inode项\n5.4-文件的安全和保护 #\r文件共享 #\r不同用户共同使用\n好处 #\r减少用户大量重复性劳动 免除系统复制文件的工作 节省文件占用的存储空间 减少程序设计输入输出文件的次数 文件保护 #\r防止文件损坏\n文件副本 #\r动态多副本\n多个介质上维持同一内容的文件(有点类似RAID0？) 会增加设备和系统开销，适合小而重要的文件的保护 文件转储\n定时保存文件副本 存取控制矩阵 #\r为每个用户设置访问每个文件对象的存取属性\n系统的全部用户对全部文件的存取属性就组成的一个二维矩阵，称为存取控制矩阵\n二维矩阵是稀疏矩阵，故将其简化为存取控制表，每行包括：用户、文件、存取属性\n文件属性 #\r先对用户分类，再对每一类用户规定文件属性\n用户分类：属主、合作者、其他\n文件属性：读、写、执行等\n文件保密 #\r防止某些用户窃取\n措施 #\r隐蔽文件目录 设置口令 使用密码 ","date":"16 May 2024","externalUrl":null,"permalink":"/posts/se%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/c5-%E6%96%87%E4%BB%B6%E7%AE%A1%E7%90%86/","section":"","summary":"卷：介质的物理单位 块：主存储器和辅助存储器进行信息交换的物理单位，也叫 文件中的数据是一串没有结构的字符流，比如一串字符串组成的文件 若干逻辑记录信息所组成的记录流文件。是逻辑上的一坨信息的单位 这\u0026hellip;","title":"C5 文件管理","type":"posts"},{"content":"","date":"11 May 2024","externalUrl":null,"permalink":"/categories/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86/","section":"","summary":"","title":"编译原理","type":"categories"},{"content":"\r编译原理知识点索引 #\r声明 #\r本文档只包含一些关键的知识点\n词法分析-正则表达式和自动机理论 #\r对应Lecture-3\n定义 #\r字母表 #\r$$字母表\\Sigma是一个有限的符号集合$$ 串 #\r$$字母表\\Sigma上的串s是由\\Sigma中符号构成的一个有穷序列$$$空串:\\epsilon$\n语言 #\r$语言是给定字母表\\Sigma上一个任意的可数的串的集合$\n正则表达式 #\r$给定字母表\\Sigma, \\Sigma上的正则表达式由且仅由以下规则定义:$\n(1) $\\epsilon是正则表达式$\n(2) $\\forall a\\in\\Sigma, a是正则表达式$\n(3) $如果r是正则表达式, 则(r)是正则表达式$\n(4) $如果r, s都是正则表达式, 则 r|s, rs, r^*也是正则表达式$\nNFA(Nondeterministic Finite Automaton) #\r$非确定性有穷自动机\\mathcal{A}是一个五元组\\mathcal{A}=(\\Sigma,S,s_0,\\delta,F)$\n见课件-3-26\nDFA(Deterministic Finite Automaton) #\r见课件-3-34\nRE, NFA, DFA等价转化 #\rRE-\u0026gt;NFA - Thompson构造法 #\r见课件-3-40:45\nNFA-\u0026gt;DFA - 子集构造法 #\r原理见课件-3-54\n为什么叫子集构造法:\n构造出的DFA的每一个状态$s_D\\in S_D$, 对应原来NFA的状态的一个子集$s_D\\subseteq 2^{S_N}$ 总结:\n对NFA的每个状态求其对应**$\\epsilon$闭包**, 即只通过$\\epsilon$转移可达的状态集合. 这个集合中的状态可以被视作DFA中的一个状态 新的DFA中的状态的转移函数是其对应NFA状态集合中每个状态的转移函数构成的. 这一条课件讲的更清楚 DFA-\u0026gt;DFA - DFA最小化 #\rIR-LLVM #\rLLVM #\rLow Level Virtual Machine\n但是现在已经不止上面的含义了\nThree Address Code (TAC) #\r三地址指令\n一条指令所含操作数和地址的数量不超过3\nStatic Single Assignment (SSA) #\r静态单赋值\n静态:\n单赋值: 每个寄存器只在赋值号左边出现一次\nControl Flow Graph (CFG) #\r控制流图\n节点: 基本块(跳转与分支只能在基本块退出点执行, 跳转到另一个基本块的进入点)\n边: 跳转关系\n$\\phi$指令(phi) #\r根据控制流的来源决定返回值\n%3 = phi i32 [1, %1], [2, %2]\r// 如果从%1控制流来, 就给%3赋值1, 否则赋值2 ","date":"11 May 2024","externalUrl":null,"permalink":"/posts/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86/%E8%AF%BE%E5%A0%82%E7%9F%A5%E8%AF%86%E7%82%B9%E7%B4%A2%E5%BC%95/","section":"","summary":"本文档只包含一些关键的知识点 对应Lecture-3 为什么叫子集构造法: 总结: 根据控制流的来源决定返回值 ``` %3 = phi i32 [1, %1], [2, %2] // 如果从%1控制\u0026hellip;","title":"课堂知识点索引","type":"posts"},{"content":"\r使用Jenkins部署Maven项目到Docker #\rJenkins：能够自动配置、自动部署项目。通过Webhook可以实现项目一旦被Push就会自动重新配置项目并且部署，以实现更新\n1 准备步骤 #\r1.1 安装Docker #\r这步比较简单，网上教程也很多，故省略\n1.2 拉取jenkins镜像 #\r执行拉取镜像的命令\ndocker pull jenkins/jenkins:lts 查看当前的镜像，可以发现jenkins已经在列表里了\ndocker images REPOSITORY TAG IMAGE ID CREATED SIZE\rbluewhale-backend master 044e4cb8919f 16 hours ago 318MB\rmysql latest f3df03e3cfc9 8 days ago 585MB\rjenkins/jenkins lts 4e586344183a 3 weeks ago 469MB\ropenjdk 8-jre 0c14a0e20aa3 21 months ago 274MB 1.3 创建容器 #\r使用run命令从镜像创建容器\n镜像和容器的关系就像类和对象的关系\ndocker run -d --restart=always -uroot \\ --name jenkins \\ -p 8080:8080 \\ -v /home/jenkins:/var/jenkins_home \\ -v /var/run/docker.sock:/var/run/docker.sock \\ -v /usr/bin/docker:/usr/bin/docker \\ -v ~/.ssh/:/root/.ssh \\ jenkins/jenkins:lts 参数说明\n-d：让容器运行在后台，不占用当前的终端 --restart=always：让docker重启后自动启动这个容器 -uroot：容器以root身份创建 --name：指定容器名称，否则docker会随机生成美丽的名字 -p：将容器的端口映射到宿主机的端口。冒号前是宿主机的，后者是容器里的 -v：将宿主机的目录挂载到容器里，能让容器访问宿主机的目录。冒号前宿主机，后容器。 第一个挂载将宿主机的路径挂载到jenkins的工作目录，能让jenkins的工作目录持久化到宿主机，这样容器被销毁了也不会让jenkins的配置和数据被销毁 第二个和第三个挂载是让容器内部能使用宿主机的docker命令，以便jenkins在宿主机创建maven项目的容器 第四个挂载是把ssh的密钥挂载上，这样jenkins就可以用ssh从仓库拉取代码了。当然也可以在容器里面重新生成密钥对。 创建容器后查看当前正在运行的容器\ndocker ps CONTAINER ID IMAGE COMMAND CREATED STATUS PORTS NAMES 9ed58b36b0c4 jenkins/jenkins:lts \u0026#34;/usr/bin/tini -- /u…\u0026#34; About a minute ago Up About a minute 0.0.0.0:8080-\u0026gt;8080/tcp, :::8080-\u0026gt;8080/tcp, 50000/tcp jenkins 排版很烂是因为这个表太长了，不过只要有jenkins就行\n另外，使用-a选项可以查看所有状态的容器，包括已经退出和挂起的\n补充：容器的生命周期(摘自CSDNdocker容器的生命周期-CSDN博客)\n2 配置Jenkins #\r2.1 初始化Jenkins #\r2.1.1 管理员初始密码 #\r在浏览器访问8080端口进入Jenkins工作台\n根据提示输入管理员密码\n这里的路径是容器内的路径，所以要进入容器的命令行\ndocker exec -it jenkins bash 我尝试过从宿主机挂载的目录访问，但是权限会有问题，懒得解决了\n2.1.2 安装插件 #\r安装推荐的插件就行。\n但是我的ECS内存太少了，所以我都是用什么插件装什么\n2.1.3 创建管理员账户 #\r可以根据提示创建账户。如果不需要的话直接使用admin账号继续即可\n2.1.4 配置完成 #\r一路点到配置完成，就进入Jenkins的Dashboard了\n2.2 对Jenkins进行全局配置 #\r2.2.1 Dashboard-\u0026gt;Manage Jenkins-\u0026gt;Plugins #\r安装Maven集成插件，以便项目的构建 2.2.2 Dashboard-\u0026gt;Manage Jenkins-\u0026gt;Tools #\r安装JDK Jenkins好像自带一个JDK。但是如果想用自己的版本的话就要在JDK installations里面配置自己的JDK 安装Maven Maven可以自动安装，选择Install automatically就可以了 2.2.3 Dashboard-\u0026gt;Manage Jenkins-\u0026gt;Credentials #\r一路点开System-\u0026gt;Global credentials\n根据自己的验证方式配置就行了。\n我的是ssh密钥对，所以把id_rsa的内容全部(包括-----BEGIN OPENSSH PRIVATE KEY-----)复制进去\n记得把公钥复制到仓库的凭据设置里面\n3 部署Maven项目 #\r","date":"10 May 2024","externalUrl":null,"permalink":"/posts/%E8%BD%AF%E5%B7%A5ii%E5%A4%A7%E4%BD%9C%E4%B8%9A-%E8%93%9D%E9%B2%B8%E5%95%86%E5%9F%8E/jenkins%E9%83%A8%E7%BD%B2maven%E9%A1%B9%E7%9B%AE%E5%88%B0docker/","section":"","summary":"这步比较简单，网上教程也很多，故省略 执行拉取镜像的命令 \u003ccode\u003ebash docker pull jenkins/jenkins:lts \u003c/code\u003e 查看当前的镜像，可以发现jenkins已经在列表里了 \u0026hellip;","title":"Jenkins部署Maven项目到Docker","type":"posts"},{"content":"\r随记 #\rPumping Theorem的理解 #\r一个足够长的，能被正则表达式$r$接受的字符串，一定能分成$xyz$三个部分。因为$r$对应DFA的状态数$p$是有限的，而串的长度大于$p$时，一定有一个状态被经历了两次及以上\n其中$y$对应$r$的DFA中起始状态和结束状态是同一个状态\n由于是同一个状态，我就可以接受任意多个$y$，所以$xy^iz\\in L$肯定成立\n扩展：上下文无关法的Pumping Theorem，具体可见课件里面\n","date":"9 May 2024","externalUrl":null,"permalink":"/posts/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86/%E9%9A%8F%E8%AE%B0/","section":"","summary":"","title":"随记","type":"posts"},{"content":"\r待解决问题 #\rLexer #\rDFA最小化为什么是正确的\nDFA最小化的结果唯一吗\n有关自动机的书：《计算理论导引》、J.E.H R.M J.D.U《Automata Theory, Languages, and Computation 第三版》\n","date":"8 May 2024","externalUrl":null,"permalink":"/posts/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86/%E9%97%AE%E9%A2%98%E6%94%B6%E9%9B%86/","section":"","summary":"","title":"问题收集","type":"posts"},{"content":"\rJPA使用Specification动态查询 #\r解决动态多条件查询的问题。我们可能会设置许多查询条件，但实际查询时只会用到其中的某一些条件，动态查询能保证只查询这一部分条件。 实现 #\rRepository接口继承JpaSpecificationExecuter\u0026lt;T\u0026gt; public interface ItemRepository extends JpaRepository\u0026lt;Item,Integer\u0026gt;, JpaSpecificationExecutor\u0026lt;Item\u0026gt;{} 新建处理Specification的类，便于构造筛选条件 public class itemSpecification { public static Specification\u0026lt;Item\u0026gt; whereItem(Map\u0026lt;String, Object\u0026gt; params) { // 通过匿名内部类实现Specification接口 // 摘自 https://blog.csdn.net/weixin_46005530/article/details/132626158 return (Root\u0026lt;Item\u0026gt; root, CriteriaQuery\u0026lt;?\u0026gt; query, CriteriaBuilder cb) -\u0026gt; { List\u0026lt;Predicate\u0026gt; predicates = new ArrayList\u0026lt;\u0026gt;(); // 处理name参数 String name = (String) params.get(\u0026#34;name\u0026#34;); if (name != null) { // 模糊查询的实现: cb.like predicates.add(cb.like(root.get(\u0026#34;name\u0026#34;), \u0026#34;%\u0026#34; + name + \u0026#34;%\u0026#34;)); } ... // 处理category参数 String catName = (String) params.get(\u0026#34;category\u0026#34;); CategoryEnum category = CategoryEnum.valueOf(catName); if(catName != null){ predicates.add(cb.equal(root.get(\u0026#34;category\u0026#34;), category)); } // 返回封装好的查询条件 return query.where( predicates.toArray(new Predicate[predicates.size()]) ).getRestriction(); } } } 在ServiceImpl层直接findAll @Override public List\u0026lt;Item\u0026gt; getItemByConditions(Map\u0026lt;String, Object\u0026gt; params){ return itemRepository.findAll(itemSpecification.whereItem(params)); } 细节 #\r用Map\u0026lt;String, Object\u0026gt;存不确定的筛选条件，模拟了一个不确定格式的JSON 在Controller层可以用@RequestBody传也可以用@RequestParams传 @RequestBody Map\u0026lt;String, Object\u0026gt; map 从Enum名字(String)到Enum类(和Integer等价)的转换，用xxxEnum.valueOf(str) String catName = (String) params.get(\u0026#34;category\u0026#34;); CategoryEnum category = CategoryEnum.valueOf(catName); @data注解 #\r@data注解可以自动生成无参构造函数、Getter、Setter和toString等方法 可以用于VO和PO(DAO)的注解，替代@Getter、@Setter、@NoArgsConstructor一系列注解 Docker上部署Mysql Server的持久化 #\rdocker run -p 3306:3306 --name mysql \\ -v /home/docker/mysql/log:/var/log/mysql \\ -v /home/docker/mysql/data:/var/lib/mysql \\ -v /home/docker/mysql/conf:/etc/mysql/conf.d \\ -e MYSQL_ROOT_PASSWORD=root \\ -d mysql JavaDoc #\r项目可以直接自动生成文档\n任务栏Tools-\u0026gt;Generate JavaDoc\n使用@Documented注解可以使这个类出现在文档中\n","date":"8 May 2024","externalUrl":null,"permalink":"/posts/%E8%BD%AF%E5%B7%A5ii%E5%A4%A7%E4%BD%9C%E4%B8%9A-%E8%93%9D%E9%B2%B8%E5%95%86%E5%9F%8E/%E7%9F%A5%E8%AF%86%E7%82%B9%E9%9A%8F%E8%AE%B0/","section":"","summary":"\u003ccode\u003ejava public interface ItemRepository extends JpaRepository, JpaSpecificationExecutor{} \u003c/code\u003e ```jav\u0026hellip;","title":"知识点随记","type":"posts"},{"content":"\r第四章-设备管理 #\r4.1-设备管理概述 #\r⭐设备管理的目标 #\r解决设备和CPU速度的不匹配，使两者充分并行工作 屏蔽设备的具体操作细节，配置驱动程序，提供统一接口 设备控制器 #\rCPU和物理设备之间的接口\n组成\n⭐IO控制方式 #\r轮询 #\rCPU向控制器发送I/O命令，轮询I/O结果。 若设备未就绪，则重复，直至设备就绪。 设备就绪，CPU执行内存交换 中断 #\rCPU向控制器发出I/O命令，然后干其他事情 如果进程支持异步IO，就不用换进程 否则进程挂起，换进程 控制器在设备就绪后向CPU发出中断 CPU响应中断，进行内存交换 DMA #\rCPU向DMA模块发出I/O命令\n处理器干其他事，DMA负责等设备就绪和传送数据\nDMA数据传完之后中断CPU\nDMA一般用周期窃取的方式访问内存。因为CPU大部分情况下用Cache，这时空闲的主存就能被DMA高效利用\nI/O通道 #\r没看懂是啥 总线 #\r解决I/O速度不匹配的问题 不同总线结构的本质是让速率相近的设备在一条总线上 单总线 #\r三级总线 #\r南北桥 #\r4.2-I/O软件的实现 #\r设计目标 #\r效率：改善设备效率，尤其是磁盘\n通用：用统一标准来管理所有设备\n⭐I/O软件的层次结构 #\r从低到高为\nI/O中断处理程序 I/O设备驱动程序 独立于设备的I/O软件 用户空间的I/O软件 I/O中断处理程序 #\r位于OS底层，和设备联系紧密\n数据传输结束后产生I/O中断，CPU响应请求并转入中断处理程序\n功能：检查设备状态寄存器，根据状态进行相关操作\n报错 正常结束，唤醒请求这个I/O的进程 其他 I/O设备驱动程序 #\r初始化设备\n逻辑I/O请求转化为物理I/O操作\n监督设备正确执行，缓冲区纠错\n独立于设备的I/O软件 #\r执行适用于所有设备的常用I/O功能\n设备命名：通过路径名寻址设备 设备保护：用户是否有权访问设备 提供与设备无关的数据单位：字符/块 缓冲技术：调整CPU与I/O速度不匹配 分配和状态跟踪：分配设备 错误处理/报告：驱动无法处理的错误 用户空间的I/O软件 #\r库函数 虚拟设备软件，如Spooling 缓冲技术 #\r目的 #\r速度不匹配 协调逻辑记录大小和物理记录大小的不匹配 提高并行 减少I/O对CPU的中断次数 放宽中断响应时间 缓冲区 #\r放在主存中\n缓冲技术类型 #\r单缓冲 双缓冲 循环缓冲 4.3-设备分配-独占型外围设备 #\r独占型外围设备：一次只能由一个进程独占使用\n⭐分配方式 #\r静态分配：进程运行前申请 动态分配：进程随用随申请 分配设备的数据结构 #\r设备类表：存不同类设备的信息 设备表：存一类设备中不同物理设备的信息 4.5-虚拟设备-SPOOLing系统 #\rSPOOLing系统 #\rSPOOLing-外部设备联机并行操作-假脱机技术\n处在用户空间的I/O软件层\n核心思想：用高速的磁盘设备来模拟慢速的字符设备，缩短进程在内存中的驻留时间\n实现 #\r预输入程序：输入设备通过预输入程序把数据输到输入井就可以干其他事情了\n缓输出程序：输出全都计算好了，输出设备就通过缓输出程序慢慢把这一堆数据输完\n井交换程序：控制作业进程和井的数据交换\n补充-磁盘调度 #\rFIFO-先进先出 #\r按顺序处理请求\nSSTF-最短服务时间优先 #\r每次找距离当前磁头最近的任务\n会饥饿 SCAN-扫描 #\r一次只沿一个方向扫\n磁头移动到最外或最内磁道才掉头\n⭐LOOK-电梯调度 #\r一次只沿一个方向扫\n磁头移动到最外或最内任务才掉头\nCSCAN-循环扫描 #\r只会沿一个方向扫\n磁头到磁道末端后，返回另一端末端开始扫\n","date":"7 May 2024","externalUrl":null,"permalink":"/posts/se%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/c4-%E8%AE%BE%E5%A4%87%E7%AE%A1%E7%90%86/","section":"","summary":"\u003col\u003e\n\u003cli\u003e解决设备和CPU的不匹配，使两者充分工作 2. 设备的具体操作细节，配置驱动程序，提供 ：改善设备效率，尤其是磁盘 ：用统一标准来管理所有设备 从低到高为 位于OS底层，和设备联系紧密 数据传输\u0026hellip;\u003c/li\u003e\n\u003c/ol\u003e\n","title":"C4 设备管理","type":"posts"},{"content":"\r第三章-存储管理 #\r3.1-存储管理基础 #\r有哪些地址 #\r逻辑地址 #\r又叫相对地址。是用户编程所使用的地址空间。 物理地址 #\r处理器执行指令时所使用的地址空间 虚拟地址 #\r辅存的地址空间 为啥要存储管理 #\r转换地址 OS有两种转换地址的模式 静态重定位：程序装入内存时转换地址(由装入程序支持) 动态重定位：解析命令才转换地址(现在都用这个，考虑效率的话必须由硬件支持) 分配和去配主存空间 管理进程对主存的共享 保护进程，避免越界访问 扩充主存空间 把磁盘作为主存的扩充 对换技术：调出一部分进程 虚拟技术：调入进程的一部分 存储管理的模式 #\r单连续存储管理：1D逻辑地址 占用 一个 主存固定或可变分区 段式存储管理：2D逻辑地址 占用 多个 主存可变分区 页式存储管理：1D逻辑地址 占用 多个 页框 段页式存储管理：2D逻辑地址 占用 多个 页框 虚拟存储器 #\r基本思想 #\r为了让程序员不必考虑主存容量的限制，夸夸用地址，就把辅存的一部分当成主存，随用随调入 主存不够了，就把部分数据调出到辅存上去 3.2-单连续分区存储管理 #\r每个进程占用一个物理上完全连续的存储空间 主存：系统区+用户区 栅栏寄存器存两个区的分界，在访存时提供保护 一般采用静态重定位 内存分配 #\r固定分区存储 #\r主存按递增大小的块来分区，加载任务的时候大小合适就丢进去。\ne.g.\n0 4k 12k 28k 44k 92k \u0026hellip; OS区(4k) 分区1(8k) 分区2(16k) 分区3(16k) 分区4(24k) 分区5(24k) \u0026hellip; 可变分区存储 #\r按实际分配需求来确定内存分区\n存储用已分配区表和未分配区表记录。包含：分区基址、分区长度、分区标志(未分配还是任务1还是任务2还是\u0026hellip;)\n分配算法\n最先适应分配算法 First fit 从头找第一个大小够的分区 最容易产生碎片 邻近适应分配算法 Next fit 从上一次的空闲分区开始找，第一个大小够的分区 最优适应分配算法 Best fit 找大小最接近的分区 最坏适应分配算法 Worst fit 找最大的分区 移动技术\n把已分配的分区移到一堆，碎片就能变成一个新的大空间 需要动态重定向支持(不知道为什么qwq) 3.3-页式存储管理 #\r","date":"25 April 2024","externalUrl":null,"permalink":"/posts/se%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/c3-%E5%AD%98%E5%82%A8%E7%AE%A1%E7%90%86/","section":"","summary":"| 0 | 4k | 12k | 28k | 44k | 92k | \u0026hellip; | | \u0026mdash;\u0026mdash;- | OS区(4k) | 分区1(8k) | 分区2(16k) | 分区3(16k) | 分区4(2\u0026hellip;","title":"C3 存储管理","type":"posts"},{"content":"\r第三章-关系数据库标准语言SQL #\r数据定义 #\r创建模式 #\rCREATE SCHEMA \u0026lt;模式名\u0026gt; AUTHORIZATION \u0026lt;用户名\u0026gt;\n命令后可接受\nCREATE TABLE CREATE VIEW GRANT 执行创建模式语句必须有DBA权限\n删除模式 #\rDROP SCHEMA \u0026lt;模式名\u0026gt; \u0026lt;CASCADE|RESTRICT\u0026gt;\nCASCADE 级联：删除模式同时删除模式内所有数据库对象 RESTRICT 限制：只在模式下无任何下属对象才删除，否则拒绝执行 创建基本表 #\rCREATE TABLE \u0026lt;表名\u0026gt; (\u0026lt;列名\u0026gt; \u0026lt;数据类型\u0026gt; [\u0026lt;列级完整性约束条件\u0026gt;] [,同上] [,\u0026lt;表级完整性约束条件\u0026gt;]) e.g. CREATE TABLE Course (Cno CHAR(4) PRIMARY KEY, Cname CHAR(40) UNIQUE, Cpno CHAR(4), FOREIGN KEY(Cpno) REFERENCES Course(Cno) ); 修改基本表 #\rALTER TABLE \u0026lt;表名\u0026gt; [ADD[COLUMN] \u0026lt;列名\u0026gt; \u0026lt;数据类型\u0026gt; [完整性约束]] [ADD \u0026lt;表级完整性约束\u0026gt;] [DROP [COLUMN] \u0026lt;列名\u0026gt; [CASCADE|RESTRICT]] [DROP CONSTRAINT\u0026lt;完整性约束名\u0026gt;[CASCADE|RESTRICT]] [ALTER COLUMN \u0026lt;列名\u0026gt;\u0026lt;数据类型\u0026gt;]; 删除基本表 #\rDROP TABLE \u0026lt;表名\u0026gt; [CASCADE|RESTRICT]\n建立索引 #\rDBMS一般会自动建立PRIMARY KEY和UNIQUE列上的索引 CREATE [UNIQUE] [CLUSTER] INDEX\u0026lt;索引名\u0026gt; ON \u0026lt;表名\u0026gt; (\u0026lt;列名\u0026gt;[\u0026lt;次序\u0026gt;],[同前]···) e.g. CREATE UNIQUE INDEX SCno ON SC(Sno ASC, Cno DESC); ASC-升序\tDESC-降序\n有关聚簇索引CLUSTER\n在最经常查询的列上建立CLUSTER可以提高查询效率 一个基本表只能建立一个聚簇索引 经常更新的列不宜建立聚簇索引 数据查询 #\rSELECT [ALL|DISTINCT] \u0026lt;目标列表达式\u0026gt; [,\u0026lt;目标列表达式\u0026gt;]··· FROM \u0026lt;表|视图\u0026gt; [,\u0026lt;表|视图\u0026gt;]··· [WHERE\u0026lt;条件表达式\u0026gt;] [GROUP BY\u0026lt;列名\u0026gt;[HAVING\u0026lt;条件表达式\u0026gt;]] [ORDER BY\u0026lt;列名\u0026gt;[ASC|DESC]]; DISTINCT-消除取值重复的行\tALL-缺省\n目标列表达式 包括\n算数表达式2024-Sage\n字符串常量'Year of Birth'\n函数LOWER(Sdept)\n列别名BIRTH 2024-Sage\nWHERE查询满足条件的元组\n查询条件 谓词 比较 =,\u0026gt;,\u0026lt;,\u0026gt;=,\u0026lt;=,!=,\u0026lt;\u0026gt;,!\u0026gt;,!\u0026lt; 确定范围 BETWEEN value1 AND value2 确定集合 IN (element1, element2, \u0026hellip;) 字符匹配 LIKE \u0026lsquo;pattern\u0026rsquo; ESCAPE \u0026lsquo;转义符\u0026rsquo; 空值 IS NULL 多重条件 AND, OR, NOT ORDER BY中，空值默认为最大值\n聚集函数\nCOUNT SUM AVG MAX MIN 聚集函数 ([DISTINCT|ALL] \u0026lt;列名\u0026gt;) COUNT ([DISTINCT|ALL] *) GROUP BY作用\n细化聚聚函数。分组后，聚集函数将分别作用于每个组 WHERE与HAVING\nWHERE作用于基本表或视图，从中选择满足表达式的元组。HAVING作用于组，从中选择满足条件的组。 WHERE不能用聚集函数 连接查询 #\r等值连接和非等值连接 #\rWHERE中连接两个表的条件格式\n[\u0026lt;表名1\u0026gt;]\u0026lt;列名1\u0026gt; \u0026lt;比较运算符\u0026gt; [\u0026lt;表名2\u0026gt;]\u0026lt;列名2\u0026gt; [\u0026lt;表名1\u0026gt;]\u0026lt;列名1\u0026gt; BETWEEN [\u0026lt;表名2\u0026gt;]\u0026lt;列名2\u0026gt; AND [\u0026lt;表名3\u0026gt;]\u0026lt;列名3\u0026gt; 如果比较运算符是=,这个连接是等值连接。若在等值连接中把目标列中重复的属性列删掉则为自然连接\n自身连接 #\r一个表和自己连接。必须给表起别名，且属性前有表别名前缀。 e.g. SELECT FIRST.Cno, SECOND.Cpno FROM Course FIRST, Course SECOND WHERE FIRST.Cpno == SECOND.Cno; 外连接 #\rLEFT|RIGHT OUT JOIN \u0026lt;表名\u0026gt; ON e.g. SELECT Student.Sno, Sname, Ssex, Sage, Sdept, Cno FROM Student LEFT OUT JOIN SC ON (Student.Sname=Cno); 多表连接 #\re.g. SELECT Student.Sno, Sname, Cname, Grade FROM Student, SC, Course WHERE Student.Sno = SC.Sno AND SC.Cno = Course.Cno; 嵌套查询 #\r将一个查询块嵌套在另外一个查询块的WHERE或HAVING里面\n查询块：一个SELECT-FROM-WHERE语句 子查询不能用ORDER BY字句\n相关子查询/不相关子查询: 是否需要用到父查询的信息\nALL和ANY量词\n用在比较符号后面，集合或者查询结果前面\ne.g. WHERE Sage\u0026lt;ALL (SELECT Sage FROM Student WHERE Sdept=\u0026#39;CS\u0026#39;) EXIST量词\ne.g. SELECT Sname FROM Student WHERE EXISTS (SELECT * FROM SC WHERE Sno=Student.Sno AND Cno=\u0026#39;1\u0026#39;) 遍历Student每一列，如果这一列能让子查询结果非空，EXISTS就会返回真，这一列也会加入查询结果里去。\nEXIST后面子查询都用*，因为子查询只返回是否非空，给列名没啥用\nEXIST前面可加NOT\n量词间的替换\nIN、比较运算符、ANY、ALL都可以被EXIST等价替换 反过来不一定行 ","date":"22 April 2024","externalUrl":null,"permalink":"/posts/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%AE%A1%E7%90%86%E5%9F%BA%E7%A1%80/c3-sql/","section":"","summary":"\u003ccode\u003eCREATE SCHEMA AUTHORIZATION \u003c/code\u003e \u003ccode\u003eDROP SCHEMA \u003c/code\u003e \u003ccode\u003esql CREATE TABLE ( [] [,同上] [,]) \u003c/code\u003e ```sql e.g. CR\u0026hellip;","title":"C3-SQL","type":"posts"},{"content":"","date":"22 April 2024","externalUrl":null,"permalink":"/categories/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%AE%A1%E7%90%86%E5%9F%BA%E7%A1%80/","section":"","summary":"","title":"数据库管理基础","type":"categories"},{"content":"\r第二章-处理器管理 #\r本章结构 2.1-处理器 #\r特权指令 #\r特权指令：只能被操作系统内核使用的指令 比如启动IO指令、置PC指令等 处理器模式 #\r0=OS内核；1=系统调用；2=共享库程序；3=用户程序 现代操作系统：内核模式(特权指令ok)，用户模式(非特权指令) 2.2-中断 #\r中断概念 #\r广义中断：程序执行过程中，遇到急需处理的事件时，暂时中止当前程序的运行，转去执行相应的事件处理程序。等中断处理完成后再返回原程序中断的地方或调度其他程序执行的过程叫中断。 狭义中断：事件来源于处理器外的广义中断。如IO中断、时钟中断、外部信号中断 广义中断 minus 狭义中断 异常：事件来源于处理器运行指令引起的广义中断。如地址异常、算术异常、处理器硬件故障 系统异常：执行陷入(trap)指令而触发系统调用引起的终端事件。如请求设备、请求IO、创建进程 中断驱动下的进程状态机 #\r中断源 #\r处理器硬件故障中断 程序性中断 自愿性中断-系统调用 IO中断 外部中断 2.3-进程 #\r⭐⭐⭐进程的概念 #\r进程是一个具有一定独立功能的程序关于某个数据集合的一次运行活动 进程是操作系统进行资源分配和调度的一个独立单位 对于多线程系统来说，进程是资源分配的独立单位 线程是资源调度的独立单位 进程的形式化定义 #\r⭐⭐⭐进程的三态模型 #\r运行态指进程占有处理器运行\n就绪态指进程具备运行条件等待处理器运行\n等待态指进程由于等待资源、输入输出、信号等而不具备运行条件\n进程挂起 #\r计算机资源不足，会剥夺某些进程的资源，调入OS管理的堆换区。这些进程就被挂起了。 挂起的进程不参加进程调度。在适当的时候被调回内存。 挂起和非运行态的本质区别是有没有占用系统资源 ⭐⭐⭐进程控制块 PCB #\rOS用于记录和刻画进程状态及环境信息的数据结构。说白了就是面向OS的进程的花名册\n包含标识信息、现场信息、控制信息。\n⭐⭐⭐进程映像 Process Image #\r进程的内存级实体 包括：PCB、进程程序空间、进程数据空间、核心栈 核心栈就是在内核态执行指令时用的栈 进程上下文 Process Context #\r进程执行所需要的环境信息 包括：用户级上下文、寄存器上下文、系统级上下文 原语 Primitive #\r若干条指令构成的程序，执行上具有原子性。意思是原语不可能被中断。 用于执行一些涉及修改OS核心数据结构的操作。为了防止并发和中断等时间上的错误，原语必须整块执行。 常用原语：进程控制原语、进程通信原语 2.4-多线程技术 #\r为什么要多线程 #\r单线程能一定程度上实现并发了，但我们还想更进一步。 限制单线程并发程度的要素： 进程切换开销大。想切换执行路径就必须换进程，开销很大。 进程通信开销大。进程通信要陷入系统调用，涉及模式转换，开销大。 解决： 分离资源分配和调度。因为资源分配比较静态，不会很频繁。相对而言，(如果想更加并发的话)调度比资源分配频繁多了。 两者分离的结果就是进程和线程 进程和线程 #\r进程 #\r操作系统的视角：是OS进行保护和资源分配的独立单位。\n是线程的容器。给线程提供运行环境和系统资源，包括内存等资源。\n线程 #\r操作系统视角：是OS调度的基本单位\n是进程的一条执行路径\n并发多线程的优点 #\r线程切换快 管理比进程方便(因为线程比较小) 通信容易实现，因为有进程这个容器的支 并行程度高 节省内存空间 线程的实现-KLT和ULT #\rKLT-内核级线程 #\r线程是OS实现并管理的 优点：线程的阻塞不会引起进程的阻塞(内核进程内部知道发生了什么并且还能给进程切换线程)、多处理器支持、使内核自身也可KLT实现 缺点：由于线程管理是OS实现的，相关操作要切换模式，开销较大(但应该还是比单线程系统管理进程要快，不然这样KLT就没意义了)。 ULT-用户级线程 #\r线程由用户实现并管理 OS感知不到多线程的存在。这样会带来一些问题。 优点：自定义程度高、多平台支持(可以移植到单线程的OS)、用户模式就能管理，开销小 缺点：多处理器不支持、线程阻塞会被OS视为进程阻塞 Jacketing技术 #\r当线程陷入系统调用时，执行jacketing程序。由jacketing程序来检查资源使用情况，以决定是否执行进程切换或传递控制权给另一个线程 混合策略 #\r单应用的多个ULT可以映射成一些KLT，通过调整KLT数目，可以达到较好的并行效果 2.5-处理器调度 #\r处理器调度的层次 #\r高级调度 决定进程的创建和终止 中级调度 决定进程的挂起和恢复 为了提高内存利用率和作业吞吐量，短期内调整系统负载 低级调度 决定哪个进程交给处理器运行 最核心、最影响系统性能的调度 ","date":"22 April 2024","externalUrl":null,"permalink":"/posts/se%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/c2-%E5%A4%84%E7%90%86%E5%99%A8%E7%AE%A1%E7%90%86/","section":"","summary":"","title":"C2 处理器管理","type":"posts"},{"content":"\r第一章-计算机操作系统概述 #\r本章结构 1.2.2-操作系统及其分类 #\r理论 #\rOS的概念：OS是计算机系统最基础的系统软件，管理软硬件资源、控制程序执行、改善人机界面、合理组织计算机工作流程，为用户使用计算机提供良好运行环境\nOS的组成：进程调度、进程通信、内存管理、设备管理、文件管理、网络通信、作业控制\nOS的类型：\n多道批处理系统（脱机） 分时操作系统 实时操作系统 1.3.5-程序接口的视角 #\r系统调用 #\r实现的基础是陷阱机制：从用户态陷入内核态 调用系统调用时(int **h)，操作系统从用户态转入内核态执行系统调用 系统调用返回时转入用户态 1.3.6-系统结构的视角 #\r操作系统内核设计 #\r设计概念：模块化、层次化、虚拟化 内核设计分类 #\r单内核 在一大坨代码中实际包含了所有操作系统功能，并作为一个单一进程运行，具有唯一地址空间。 大部分UNIX(包括Linxu)系统都采用的单体内核。 微内核 大部分OS功能作为单独的进程在内核态外运行，他们通过消息传递进行通讯。 内核态只有最基本、最核心的功能模块。比如IPC、虚存、调度 混合内核 外内核 OS本身值提供很低级的硬件操作，没有很完整的硬件抽象。 用在嵌入式上 ","date":"22 April 2024","externalUrl":null,"permalink":"/posts/se%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/c1-%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E6%A6%82%E8%BF%B0/","section":"","summary":"","title":"C1 计算机操作系统概述","type":"posts"},{"content":"\rLec-0 绪论 #\r观察OS的视角 #\r用户角度 #\rOS是服务提供者 - 接口和服务 系统角度 #\rOS是资源管理者 - 处理器管理、存储管理、设备管理、文件管理 OS是虚拟机 - 虚拟机、os结构、os运行模型、网络环境下的操作系统 OS是程序执行的控制者 - 进程交互、调度、同步、通信、死锁 最基础的抽象🤓☝️ #\r进程抽象-是对已进入主存正在运行的程序在处理器上操作的状态集的抽象 。 虚存抽象-是对物理主存的抽象，进程可获得一个硕大的连续地址空间来存放可执行程序和数据，可使用虚拟地址来引用物理主存单元。 文件抽象-是对设备(磁盘)的抽象 。 复习Roadmap #\r","date":"22 April 2024","externalUrl":null,"permalink":"/posts/se%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/c0-%E7%BB%AA%E8%AE%BA/","section":"","summary":"","title":"C0 绪论","type":"posts"},{"content":"\r关于 #\r有时间再写哦。\n","externalUrl":null,"permalink":"/about/","section":"","summary":"","title":"","type":"about"},{"content":"","externalUrl":null,"permalink":"/authors/","section":"Authors","summary":"","title":"Authors","type":"authors"},{"content":"","externalUrl":null,"permalink":"/series/","section":"Series","summary":"","title":"Series","type":"series"},{"content":"","externalUrl":null,"permalink":"/tags/","section":"Tags","summary":"","title":"Tags","type":"tags"}]