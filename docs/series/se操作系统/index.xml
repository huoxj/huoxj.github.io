<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>SE操作系统 on Runz&#39;s Blog</title>
    <link>https://huoxj.github.io/series/se%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/</link>
    <description>Recent content in SE操作系统 on Runz&#39;s Blog</description>
    <generator>Hugo</generator>
    <language>cn</language>
    <lastBuildDate>Fri, 24 May 2024 00:00:00 +0000</lastBuildDate>
    <atom:link href="https://huoxj.github.io/series/se%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>Ex6 信号量与PV操作习题</title>
      <link>https://huoxj.github.io/posts/se%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/ex6-%E4%BF%A1%E5%8F%B7%E9%87%8F%E4%B8%8Epv%E6%93%8D%E4%BD%9C%E4%B9%A0%E9%A2%98/</link>
      <pubDate>Fri, 24 May 2024 00:00:00 +0000</pubDate>
      <guid>https://huoxj.github.io/posts/se%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/ex6-%E4%BF%A1%E5%8F%B7%E9%87%8F%E4%B8%8Epv%E6%93%8D%E4%BD%9C%E4%B9%A0%E9%A2%98/</guid>
      <description>&lt;h1 id=&#34;信号量与pv操作习题&#34;&gt;信号量与PV操作习题&lt;/h1&gt;&#xA;&lt;h2 id=&#34;读者写者问题&#34;&gt;读者写者问题&lt;/h2&gt;&#xA;&lt;h3 id=&#34;v1-读者优先策略&#34;&gt;v1-读者优先策略&lt;/h3&gt;&#xA;&lt;p&gt;&lt;img src=&#34;https://runzblog.oss-cn-hangzhou.aliyuncs.com/postimg/202409271721124.png&#34; alt=&#34;image-20240524100405216&#34;&gt;&lt;/p&gt;&#xA;&lt;p&gt;rmutex的理解&lt;/p&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;可以理解为更新临界资源readcount的坑位，同一时间只允许一个reader蹲在那里更新readcount&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;h2 id=&#34;理发师问题&#34;&gt;理发师问题&lt;/h2&gt;&#xA;&lt;blockquote&gt;&#xA;&lt;p&gt;一个理发师、一把理发椅、等候区容量N&lt;/p&gt;&#xA;&lt;p&gt;理发师：等候区有顾客就理发，没顾客睡觉&lt;/p&gt;&#xA;&lt;p&gt;顾客：等候区不满就进等候区，在等候区如果理发师睡觉就叫醒；等候区满就不理发了&lt;/p&gt;&#xA;&lt;/blockquote&gt;&#xA;&lt;p&gt;&lt;img src=&#34;https://runzblog.oss-cn-hangzhou.aliyuncs.com/postimg/202409271721753.png&#34; alt=&#34;&#34;&gt;&lt;/p&gt;&#xA;&lt;h3 id=&#34;重要思想&#34;&gt;重要思想&lt;/h3&gt;&#xA;&lt;p&gt;&lt;strong&gt;协同信号量&lt;/strong&gt;: waiting &amp;lt;-&amp;gt; customers&lt;/p&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;waiting变量和customers信号量是一对协同量，二者意义相同，数值也相同(除了customer可能为-1)。&lt;/li&gt;&#xA;&lt;li&gt;所以要用mutex信号量去保证二者在&lt;strong&gt;有顾客的时候&lt;/strong&gt;是同步变化的，这样去理解mutex就容易的多了&lt;/li&gt;&#xA;&lt;li&gt;&lt;strong&gt;为什么&lt;/strong&gt;？因为我们要判断if(waiting&amp;lt;CHAIRS)，假如没有waiting，我们就得判断if(customers&amp;lt;CHAIRS)，但是用户代码直接访问信号量的操作是不被允许的&lt;/li&gt;&#xA;&lt;/ul&gt;</description>
    </item>
    <item>
      <title>Lab3</title>
      <link>https://huoxj.github.io/posts/se%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/lab3/</link>
      <pubDate>Wed, 22 May 2024 00:00:00 +0000</pubDate>
      <guid>https://huoxj.github.io/posts/se%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/lab3/</guid>
      <description>&lt;blockquote&gt;&#xA;&lt;ol&gt;&#xA;&lt;li&gt;解释中断向量&lt;/li&gt;&#xA;&lt;/ol&gt;&#xA;&lt;/blockquote&gt;&#xA;&lt;p&gt;中断向量是确定中断服务程序的位置。包含段基址和偏移量。&lt;/p&gt;&#xA;&lt;blockquote&gt;&#xA;&lt;ol start=&#34;2&#34;&gt;&#xA;&lt;li&gt;解释中断类型码&lt;/li&gt;&#xA;&lt;/ol&gt;&#xA;&lt;/blockquote&gt;&#xA;&lt;p&gt;把每个中断服务程序进行编号，一个号代表一个中断服务程序，就是中断类型码，是计算机用来查找中断向量用的。(0-255)&lt;/p&gt;&#xA;&lt;blockquote&gt;&#xA;&lt;ol start=&#34;3&#34;&gt;&#xA;&lt;li&gt;解释中断向量表&lt;/li&gt;&#xA;&lt;/ol&gt;&#xA;&lt;/blockquote&gt;&#xA;&lt;p&gt;一片专门用来存放所有的中断向量的内存空间。&lt;/p&gt;&#xA;&lt;p&gt;在内存单元的最低处，地址空间为 00000H-003FFH (0-1024B)&lt;/p&gt;&#xA;&lt;p&gt;中断类型码 * 4 = 中断向量的首地址&lt;/p&gt;&#xA;&lt;p&gt;中断向量表提供了中断类型码与中断处理代码段入口地址的映射。&lt;/p&gt;&#xA;&lt;blockquote&gt;&#xA;&lt;ol start=&#34;4&#34;&gt;&#xA;&lt;li&gt;实模式下中断程序地址如何得到?&lt;/li&gt;&#xA;&lt;/ol&gt;&#xA;&lt;/blockquote&gt;&#xA;&lt;p&gt;根据中断类型码 n, 从中断向量表 n*4，取得中断处理程序的地址，段地址存入 CS，偏移量存入 IP，使得 CPU 转入中断程序运行。&lt;/p&gt;&#xA;&lt;blockquote&gt;&#xA;&lt;ol start=&#34;5&#34;&gt;&#xA;&lt;li&gt;保护模式下中断程序地址如何得到?&lt;/li&gt;&#xA;&lt;/ol&gt;&#xA;&lt;/blockquote&gt;&#xA;&lt;ol&gt;&#xA;&lt;li&gt;&#xA;&lt;p&gt;以 IDTR 中中断向量表的基址为起始地址 + 调用号 N*8 = 中断门描述符首地址，取出中断门的 8 个字节&lt;/p&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;&#xA;&lt;p&gt;根据中断门的选择子和偏移量得到中断处理程序入口&lt;/p&gt;&#xA;&lt;/li&gt;&#xA;&lt;/ol&gt;&#xA;&lt;blockquote&gt;&#xA;&lt;ol start=&#34;6&#34;&gt;&#xA;&lt;li&gt;中断向量的地址如何得到?&lt;/li&gt;&#xA;&lt;/ol&gt;&#xA;&lt;/blockquote&gt;&#xA;&lt;p&gt;中断类型码 * 4&lt;/p&gt;&#xA;&lt;blockquote&gt;&#xA;&lt;ol start=&#34;7&#34;&gt;&#xA;&lt;li&gt;实模式下如何根据中断向量的地址得到中断程序地址?&lt;/li&gt;&#xA;&lt;/ol&gt;&#xA;&lt;/blockquote&gt;&#xA;&lt;p&gt;低二字节为偏移量，高二字节为段地址&lt;/p&gt;&#xA;&lt;blockquote&gt;&#xA;&lt;ol start=&#34;8&#34;&gt;&#xA;&lt;li&gt;解释中断描述符&lt;/li&gt;&#xA;&lt;/ol&gt;&#xA;&lt;/blockquote&gt;&#xA;&lt;p&gt;中断描述符含有中断处理程序地址信息，还包括许多属性和类型位&lt;/p&gt;&#xA;&lt;p&gt;每个中断描述符占用连续的8个字节，中断描述符分为三类：任务门、中断门和自陷门，CPU对不同的门有不同的处理方式&lt;/p&gt;&#xA;&lt;p&gt;低1，2字节和高7，8字节存偏移量&lt;/p&gt;&#xA;&lt;p&gt;2，3字节是段选择符&lt;/p&gt;&#xA;&lt;p&gt;4，5字节是访问权限字节&lt;/p&gt;&#xA;&lt;blockquote&gt;&#xA;&lt;ol start=&#34;9&#34;&gt;&#xA;&lt;li&gt;保护模式下中断描述符表如何得到?&lt;/li&gt;&#xA;&lt;/ol&gt;&#xA;&lt;/blockquote&gt;&#xA;&lt;p&gt;通过IDTR读取IDT的基地址。&lt;/p&gt;&#xA;&lt;blockquote&gt;&#xA;&lt;ol start=&#34;10&#34;&gt;&#xA;&lt;li&gt;保护模式下中断门如何得到?&lt;/li&gt;&#xA;&lt;/ol&gt;&#xA;&lt;/blockquote&gt;&#xA;&lt;p&gt;IDT基地址+中断类型码*8&lt;/p&gt;&#xA;&lt;blockquote&gt;&#xA;&lt;ol start=&#34;11&#34;&gt;&#xA;&lt;li&gt;保护模式下如何根据中断门得到中断处理程序地址?&lt;/li&gt;&#xA;&lt;/ol&gt;&#xA;&lt;/blockquote&gt;&#xA;&lt;p&gt;中断门中的段选择符-&amp;gt;段基址 + 偏移量&lt;/p&gt;&#xA;&lt;blockquote&gt;&#xA;&lt;ol start=&#34;12&#34;&gt;&#xA;&lt;li&gt;中断的分类，举例不同类型的中断?&lt;/li&gt;&#xA;&lt;/ol&gt;&#xA;&lt;/blockquote&gt;&#xA;&lt;ol&gt;&#xA;&lt;li&gt;从&lt;strong&gt;中断源&lt;/strong&gt;的角度：&lt;/li&gt;&#xA;&lt;/ol&gt;&#xA;&lt;p&gt;&lt;strong&gt;内部异常中断&lt;/strong&gt;：由硬件异常或故障引起的&lt;/p&gt;&#xA;&lt;p&gt;&lt;strong&gt;软中断&lt;/strong&gt;：程序执行了中断指令引起的中断，由程序员通过 INT 或 INT3 指令触发，通常当做 trap 处理，实现系统调用&lt;/p&gt;&#xA;&lt;p&gt;&lt;strong&gt;外部中断&lt;/strong&gt; / IO 中断：外部设备请求引起的中断（又可分为可屏蔽中断（INTR 引脚）和不可屏蔽中断（NMI 引脚）：重启、电源故障、内存出错等影响整个系统工作的中断时不能被屏蔽的）&lt;/p&gt;</description>
    </item>
    <item>
      <title>C5 文件管理</title>
      <link>https://huoxj.github.io/posts/se%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/c5-%E6%96%87%E4%BB%B6%E7%AE%A1%E7%90%86/</link>
      <pubDate>Thu, 16 May 2024 00:00:00 +0000</pubDate>
      <guid>https://huoxj.github.io/posts/se%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/c5-%E6%96%87%E4%BB%B6%E7%AE%A1%E7%90%86/</guid>
      <description>&lt;h1 id=&#34;第五章-文件管理&#34;&gt;第五章-文件管理&lt;/h1&gt;&#xA;&lt;h2 id=&#34;51-文件系统概述&#34;&gt;5.1-文件系统概述&lt;/h2&gt;&#xA;&lt;h3 id=&#34;引入文件的优点&#34;&gt;引入文件的优点&lt;/h3&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;用户使用方便，&lt;strong&gt;按名存取&lt;/strong&gt;&lt;/li&gt;&#xA;&lt;li&gt;文件安全可靠&lt;/li&gt;&#xA;&lt;li&gt;文件可备份&lt;/li&gt;&#xA;&lt;li&gt;文件可共享&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;h3 id=&#34;文件系统的功能&#34;&gt;文件系统的功能&lt;/h3&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;面向用户&#xA;&lt;ul&gt;&#xA;&lt;li&gt;按名存取&lt;/li&gt;&#xA;&lt;li&gt;共享和保护&lt;/li&gt;&#xA;&lt;li&gt;操作和使用&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;OS要实现&#xA;&lt;ul&gt;&#xA;&lt;li&gt;文件目录的建立与维护&lt;/li&gt;&#xA;&lt;li&gt;存储空间的分配和回收&lt;/li&gt;&#xA;&lt;li&gt;数据安全&lt;/li&gt;&#xA;&lt;li&gt;用户权限&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;h2 id=&#34;52-文件的存储&#34;&gt;5.2-文件的存储&lt;/h2&gt;&#xA;&lt;h3 id=&#34;物理文件&#34;&gt;物理文件&lt;/h3&gt;&#xA;&lt;p&gt;卷：介质的物理单位&lt;/p&gt;&#xA;&lt;p&gt;块：主存储器和辅助存储器进行信息交换的物理单位，也叫&lt;strong&gt;物理记录&lt;/strong&gt;&lt;/p&gt;&#xA;&lt;h3 id=&#34;逻辑文件&#34;&gt;逻辑文件&lt;/h3&gt;&#xA;&lt;h4 id=&#34;流式文件&#34;&gt;流式文件&lt;/h4&gt;&#xA;&lt;p&gt;文件中的数据是一串没有结构的字符流，比如一串字符串组成的文件&lt;/p&gt;&#xA;&lt;h4 id=&#34;记录式文件&#34;&gt;记录式文件&lt;/h4&gt;&#xA;&lt;p&gt;若干逻辑记录信息所组成的记录流文件。&lt;strong&gt;逻辑记录&lt;/strong&gt;是逻辑上的一坨信息的单位&lt;/p&gt;&#xA;&lt;h3 id=&#34;逻辑记录的成组与分解&#34;&gt;逻辑记录的成组与分解&lt;/h3&gt;&#xA;&lt;p&gt;这个条目解决了从&lt;strong&gt;逻辑记录大小&lt;/strong&gt;和&lt;strong&gt;物理记录大小&lt;/strong&gt;的&lt;strong&gt;不匹配&lt;/strong&gt;的问题&lt;/p&gt;&#xA;&lt;h4 id=&#34;优点&#34;&gt;优点&lt;/h4&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;节省存储空间&lt;/li&gt;&#xA;&lt;li&gt;减少IO次数&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;h4 id=&#34;特点&#34;&gt;特点&lt;/h4&gt;&#xA;&lt;p&gt;提前读：因为一次读了多个逻辑记录&lt;/p&gt;&#xA;&lt;p&gt;推迟写：要缓冲区逻辑记录满了才写&lt;/p&gt;&#xA;&lt;h4 id=&#34;长记录&#34;&gt;长记录&lt;/h4&gt;&#xA;&lt;!-- raw HTML omitted --&gt;&#xA;&lt;h4 id=&#34;变长记录&#34;&gt;变长记录&lt;/h4&gt;&#xA;&lt;!-- raw HTML omitted --&gt;&#xA;&lt;h4 id=&#34;跨块记录&#34;&gt;跨块记录&lt;/h4&gt;&#xA;&lt;!-- raw HTML omitted --&gt;&#xA;&lt;h3 id=&#34;文件的物理结构&#34;&gt;文件的物理结构&lt;/h3&gt;&#xA;&lt;p&gt;这个条目解决了从逻辑记录存到物理记录的&lt;strong&gt;组织&lt;/strong&gt;&lt;/p&gt;&#xA;&lt;h4 id=&#34;顺序文件&#34;&gt;顺序文件&lt;/h4&gt;&#xA;&lt;p&gt;逻辑记录——&lt;!-- raw HTML omitted --&gt;线性排列&lt;!-- raw HTML omitted --&gt;——&amp;gt;物理记录&lt;/p&gt;&#xA;&lt;p&gt;优点：顺序读取快&lt;/p&gt;&#xA;&lt;p&gt;缺点：无法动态分配、修改&lt;/p&gt;&#xA;&lt;h4 id=&#34;连接文件&#34;&gt;连接文件&lt;/h4&gt;&#xA;&lt;p&gt;逻辑记录——&lt;!-- raw HTML omitted --&gt;链表&lt;!-- raw HTML omitted --&gt;——&amp;gt;物理记录&lt;/p&gt;</description>
    </item>
    <item>
      <title>C4 设备管理</title>
      <link>https://huoxj.github.io/posts/se%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/c4-%E8%AE%BE%E5%A4%87%E7%AE%A1%E7%90%86/</link>
      <pubDate>Tue, 07 May 2024 00:00:00 +0000</pubDate>
      <guid>https://huoxj.github.io/posts/se%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/c4-%E8%AE%BE%E5%A4%87%E7%AE%A1%E7%90%86/</guid>
      <description>&lt;h1 id=&#34;第四章-设备管理&#34;&gt;第四章-设备管理&lt;/h1&gt;&#xA;&lt;h2 id=&#34;41-设备管理概述&#34;&gt;4.1-设备管理概述&lt;/h2&gt;&#xA;&lt;h3 id=&#34;设备管理的目标&#34;&gt;⭐设备管理的目标&lt;/h3&gt;&#xA;&lt;ol&gt;&#xA;&lt;li&gt;解决设备和CPU&lt;strong&gt;速度&lt;/strong&gt;的不匹配，使两者充分&lt;strong&gt;并行&lt;/strong&gt;工作&lt;/li&gt;&#xA;&lt;li&gt;&lt;strong&gt;屏蔽&lt;/strong&gt;设备的具体操作细节，配置驱动程序，提供&lt;strong&gt;统一接口&lt;/strong&gt;&lt;/li&gt;&#xA;&lt;/ol&gt;&#xA;&lt;h3 id=&#34;设备控制器&#34;&gt;设备控制器&lt;/h3&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;&#xA;&lt;p&gt;CPU和物理设备之间的接口&lt;/p&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;&#xA;&lt;p&gt;组成&lt;/p&gt;&#xA;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;!-- raw HTML omitted --&gt;&#xA;&lt;h3 id=&#34;io控制方式&#34;&gt;⭐IO控制方式&lt;/h3&gt;&#xA;&lt;h4 id=&#34;轮询&#34;&gt;轮询&lt;/h4&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;CPU向控制器发送I/O命令，轮询I/O结果。&lt;/li&gt;&#xA;&lt;li&gt;若设备未就绪，则&lt;strong&gt;重复&lt;/strong&gt;，直至设备就绪。&lt;/li&gt;&#xA;&lt;li&gt;设备就绪，CPU执行&lt;strong&gt;内存交换&lt;/strong&gt;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;h4 id=&#34;中断&#34;&gt;中断&lt;/h4&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;CPU向控制器发出I/O命令，然后&lt;strong&gt;干其他事情&lt;/strong&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;如果进程支持异步IO，就不用换进程&lt;/li&gt;&#xA;&lt;li&gt;否则进程挂起，换进程&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;控制器在设备就绪后向CPU发出中断&lt;/li&gt;&#xA;&lt;li&gt;CPU响应中断，进行&lt;strong&gt;内存交换&lt;/strong&gt;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;h4 id=&#34;dma&#34;&gt;DMA&lt;/h4&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;&#xA;&lt;p&gt;CPU向DMA模块发出I/O命令&lt;/p&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;&#xA;&lt;p&gt;处理器&lt;strong&gt;干其他事&lt;/strong&gt;，DMA负责等设备就绪和&lt;strong&gt;传送数据&lt;/strong&gt;&lt;/p&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;&#xA;&lt;p&gt;DMA数据传完之后中断CPU&lt;/p&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;&#xA;&lt;p&gt;DMA一般用周期窃取的方式访问内存。因为CPU大部分情况下用Cache，这时空闲的主存就能被DMA高效利用&lt;/p&gt;&#xA;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;h3 id=&#34;io通道&#34;&gt;I/O通道&lt;/h3&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;没看懂是啥&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;h3 id=&#34;总线&#34;&gt;总线&lt;/h3&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;解决I/O&lt;strong&gt;速度不匹配&lt;/strong&gt;的问题&lt;/li&gt;&#xA;&lt;li&gt;不同总线结构的本质是让&lt;strong&gt;速率相近&lt;/strong&gt;的设备在一条总线上&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;h4 id=&#34;单总线&#34;&gt;单总线&lt;/h4&gt;&#xA;&lt;!-- raw HTML omitted --&gt;&#xA;&lt;h4 id=&#34;三级总线&#34;&gt;三级总线&lt;/h4&gt;&#xA;&lt;!-- raw HTML omitted --&gt;&#xA;&lt;h4 id=&#34;南北桥&#34;&gt;南北桥&lt;/h4&gt;&#xA;&lt;!-- raw HTML omitted --&gt;&#xA;&lt;h2 id=&#34;42-io软件的实现&#34;&gt;4.2-I/O软件的实现&lt;/h2&gt;&#xA;&lt;h3 id=&#34;设计目标&#34;&gt;设计目标&lt;/h3&gt;&#xA;&lt;p&gt;&lt;strong&gt;效率&lt;/strong&gt;：改善设备效率，尤其是磁盘&lt;/p&gt;&#xA;&lt;p&gt;&lt;strong&gt;通用&lt;/strong&gt;：用统一标准来管理所有设备&lt;/p&gt;&#xA;&lt;h3 id=&#34;io软件的层次结构&#34;&gt;⭐I/O软件的层次结构&lt;/h3&gt;&#xA;&lt;p&gt;从低到高为&lt;/p&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;I/O中断处理程序&lt;/li&gt;&#xA;&lt;li&gt;I/O设备驱动程序&lt;/li&gt;&#xA;&lt;li&gt;独立于设备的I/O软件&lt;/li&gt;&#xA;&lt;li&gt;用户空间的I/O软件&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;h4 id=&#34;io中断处理程序&#34;&gt;I/O中断处理程序&lt;/h4&gt;&#xA;&lt;p&gt;位于OS底层，和设备联系紧密&lt;/p&gt;&#xA;&lt;p&gt;数据传输&lt;strong&gt;结束&lt;/strong&gt;后产生I/O中断，CPU响应请求并转入中断处理程序&lt;/p&gt;&#xA;&lt;p&gt;功能：检查&lt;strong&gt;设备状态寄存器&lt;/strong&gt;，根据状态进行相关操作&lt;/p&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;报错&lt;/li&gt;&#xA;&lt;li&gt;正常结束，唤醒请求这个I/O的进程&lt;/li&gt;&#xA;&lt;li&gt;其他&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;h4 id=&#34;io设备驱动程序&#34;&gt;I/O设备驱动程序&lt;/h4&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;&#xA;&lt;p&gt;&lt;strong&gt;初始化&lt;/strong&gt;设备&lt;/p&gt;</description>
    </item>
    <item>
      <title>C3 存储管理</title>
      <link>https://huoxj.github.io/posts/se%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/c3-%E5%AD%98%E5%82%A8%E7%AE%A1%E7%90%86/</link>
      <pubDate>Thu, 25 Apr 2024 00:00:00 +0000</pubDate>
      <guid>https://huoxj.github.io/posts/se%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/c3-%E5%AD%98%E5%82%A8%E7%AE%A1%E7%90%86/</guid>
      <description>&lt;h1 id=&#34;第三章-存储管理&#34;&gt;第三章-存储管理&lt;/h1&gt;&#xA;&lt;h2 id=&#34;31-存储管理基础&#34;&gt;3.1-存储管理基础&lt;/h2&gt;&#xA;&lt;h3 id=&#34;有哪些地址&#34;&gt;有哪些地址&lt;/h3&gt;&#xA;&lt;h4 id=&#34;逻辑地址&#34;&gt;逻辑地址&lt;/h4&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;又叫&lt;strong&gt;相对地址&lt;/strong&gt;。是用户编程所使用的地址空间。&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;h4 id=&#34;物理地址&#34;&gt;物理地址&lt;/h4&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;&lt;strong&gt;处理器执行&lt;/strong&gt;指令时所使用的地址空间&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;h4 id=&#34;虚拟地址&#34;&gt;虚拟地址&lt;/h4&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;辅存的地址空间&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;h3 id=&#34;为啥要存储管理&#34;&gt;为啥要存储管理&lt;/h3&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;&lt;strong&gt;转换地址&lt;/strong&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;OS有两种转换地址的模式&lt;/li&gt;&#xA;&lt;li&gt;静态重定位：&lt;strong&gt;程序装入&lt;/strong&gt;内存时转换地址(由装入程序支持)&lt;/li&gt;&#xA;&lt;li&gt;动态重定位：&lt;strong&gt;解析命令&lt;/strong&gt;才转换地址(现在都用这个，考虑效率的话必须由硬件支持)&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;&lt;strong&gt;分配&lt;/strong&gt;和&lt;strong&gt;去配&lt;/strong&gt;主存空间&lt;/li&gt;&#xA;&lt;li&gt;管理进程对&lt;strong&gt;主存的共享&lt;/strong&gt;&lt;/li&gt;&#xA;&lt;li&gt;&lt;strong&gt;保护进程&lt;/strong&gt;，避免越界访问&lt;/li&gt;&#xA;&lt;li&gt;扩充主存空间&#xA;&lt;ul&gt;&#xA;&lt;li&gt;把磁盘作为主存的扩充&lt;/li&gt;&#xA;&lt;li&gt;对换技术：调出一部分进程&lt;/li&gt;&#xA;&lt;li&gt;虚拟技术：调入进程的一部分&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;h3 id=&#34;存储管理的模式&#34;&gt;存储管理的模式&lt;/h3&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;单连续存储管理：1D逻辑地址 占用 一个 主存固定或可变分区&lt;/li&gt;&#xA;&lt;li&gt;段式存储管理：2D逻辑地址 占用 多个 主存可变分区&lt;/li&gt;&#xA;&lt;li&gt;页式存储管理：1D逻辑地址 占用 多个 页框&lt;/li&gt;&#xA;&lt;li&gt;段页式存储管理：2D逻辑地址 占用 多个 页框&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;h3 id=&#34;虚拟存储器&#34;&gt;虚拟存储器&lt;/h3&gt;&#xA;&lt;h4 id=&#34;基本思想&#34;&gt;基本思想&lt;/h4&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;为了让程序员不必考虑主存容量的限制，夸夸用地址，就把辅存的一部分当成主存，&lt;strong&gt;随用随调入&lt;/strong&gt;&lt;/li&gt;&#xA;&lt;li&gt;&lt;strong&gt;主存不够&lt;/strong&gt;了，就把部分数据&lt;strong&gt;调出到辅存&lt;/strong&gt;上去&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;h2 id=&#34;32-单连续分区存储管理&#34;&gt;3.2-单连续分区存储管理&lt;/h2&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;每个进程占用一个物理上完全连续的存储空间&lt;/li&gt;&#xA;&lt;li&gt;主存：系统区+用户区&lt;/li&gt;&#xA;&lt;li&gt;&lt;strong&gt;栅栏寄存器&lt;/strong&gt;存两个区的分界，在访存时提供保护&lt;/li&gt;&#xA;&lt;li&gt;一般采用&lt;strong&gt;静态重定位&lt;/strong&gt;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;h3 id=&#34;内存分配&#34;&gt;内存分配&lt;/h3&gt;&#xA;&lt;h4 id=&#34;固定分区存储&#34;&gt;固定分区存储&lt;/h4&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;&#xA;&lt;p&gt;主存按递增大小的块来分区，加载任务的时候大小合适就丢进去。&lt;/p&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;&#xA;&lt;p&gt;e.g.&lt;/p&gt;&#xA;&lt;table&gt;&#xA;  &lt;thead&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;th style=&#34;text-align: left&#34;&gt;0&lt;/th&gt;&#xA;          &lt;th style=&#34;text-align: left&#34;&gt;4k&lt;/th&gt;&#xA;          &lt;th style=&#34;text-align: left&#34;&gt;12k&lt;/th&gt;&#xA;          &lt;th style=&#34;text-align: left&#34;&gt;28k&lt;/th&gt;&#xA;          &lt;th style=&#34;text-align: left&#34;&gt;44k&lt;/th&gt;&#xA;          &lt;th style=&#34;text-align: left&#34;&gt;92k&lt;/th&gt;&#xA;          &lt;th style=&#34;text-align: left&#34;&gt;&amp;hellip;&lt;/th&gt;&#xA;      &lt;/tr&gt;&#xA;  &lt;/thead&gt;&#xA;  &lt;tbody&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;td style=&#34;text-align: left&#34;&gt;OS区(4k)&lt;/td&gt;&#xA;          &lt;td style=&#34;text-align: left&#34;&gt;分区1(8k)&lt;/td&gt;&#xA;          &lt;td style=&#34;text-align: left&#34;&gt;分区2(16k)&lt;/td&gt;&#xA;          &lt;td style=&#34;text-align: left&#34;&gt;分区3(16k)&lt;/td&gt;&#xA;          &lt;td style=&#34;text-align: left&#34;&gt;分区4(24k)&lt;/td&gt;&#xA;          &lt;td style=&#34;text-align: left&#34;&gt;分区5(24k)&lt;/td&gt;&#xA;          &lt;td style=&#34;text-align: left&#34;&gt;&amp;hellip;&lt;/td&gt;&#xA;      &lt;/tr&gt;&#xA;  &lt;/tbody&gt;&#xA;&lt;/table&gt;&#xA;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;h4 id=&#34;可变分区存储&#34;&gt;可变分区存储&lt;/h4&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;&#xA;&lt;p&gt;按实际分配需求来确定内存分区&lt;/p&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;&#xA;&lt;p&gt;存储用&lt;strong&gt;已分配区表&lt;/strong&gt;和&lt;strong&gt;未分配区表&lt;/strong&gt;记录。包含：分区基址、分区长度、分区标志(未分配还是任务1还是任务2还是&amp;hellip;)&lt;/p&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;&#xA;&lt;p&gt;分配算法&lt;/p&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;最先适应分配算法 First fit&#xA;&lt;ul&gt;&#xA;&lt;li&gt;从头找第一个大小够的分区&lt;/li&gt;&#xA;&lt;li&gt;最容易产生碎片&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;邻近适应分配算法 Next fit&#xA;&lt;ul&gt;&#xA;&lt;li&gt;从上一次的空闲分区开始找，第一个大小够的分区&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;最优适应分配算法 Best fit&#xA;&lt;ul&gt;&#xA;&lt;li&gt;找大小最接近的分区&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;最坏适应分配算法 Worst fit&#xA;&lt;ul&gt;&#xA;&lt;li&gt;找最大的分区&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;&#xA;&lt;p&gt;移动技术&lt;/p&gt;</description>
    </item>
    <item>
      <title>C0 绪论</title>
      <link>https://huoxj.github.io/posts/se%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/c0-%E7%BB%AA%E8%AE%BA/</link>
      <pubDate>Mon, 22 Apr 2024 00:00:00 +0000</pubDate>
      <guid>https://huoxj.github.io/posts/se%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/c0-%E7%BB%AA%E8%AE%BA/</guid>
      <description>&lt;h1 id=&#34;lec-0-绪论&#34;&gt;Lec-0 绪论&lt;/h1&gt;&#xA;&lt;h2 id=&#34;观察os的视角&#34;&gt;观察OS的视角&lt;/h2&gt;&#xA;&lt;h3 id=&#34;用户角度&#34;&gt;用户角度&lt;/h3&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;OS是&lt;strong&gt;服务提供者&lt;/strong&gt; - 接口和服务&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;h3 id=&#34;系统角度&#34;&gt;系统角度&lt;/h3&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;OS是&lt;strong&gt;资源管理者&lt;/strong&gt; - 处理器管理、存储管理、设备管理、文件管理&lt;/li&gt;&#xA;&lt;li&gt;OS是&lt;strong&gt;虚拟机&lt;/strong&gt; - 虚拟机、os结构、os运行模型、网络环境下的操作系统&lt;/li&gt;&#xA;&lt;li&gt;OS是&lt;strong&gt;程序执行的控制者&lt;/strong&gt; - 进程交互、调度、同步、通信、死锁&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;h2 id=&#34;最基础的抽象&#34;&gt;最基础的抽象🤓☝️&lt;/h2&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;进程抽象-是对已进入主存正在运行的程序在处理器上操作的状态集的抽象 。&lt;/li&gt;&#xA;&lt;li&gt;虚存抽象-是对物理主存的抽象，进程可获得一个硕大的连续地址空间来存放可执行程序和数据，可使用虚拟地址来引用物理主存单元。&lt;/li&gt;&#xA;&lt;li&gt;文件抽象-是对设备(磁盘)的抽象 。&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;h2 id=&#34;复习roadmap&#34;&gt;复习Roadmap&lt;/h2&gt;&#xA;&lt;p&gt;&lt;img src=&#34;https://runzblog.oss-cn-hangzhou.aliyuncs.com/postimg/202409271716735.png&#34; alt=&#34;image-20240422141419166&#34;&gt;&lt;/p&gt;</description>
    </item>
    <item>
      <title>C1 计算机操作系统概述</title>
      <link>https://huoxj.github.io/posts/se%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/c1-%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E6%A6%82%E8%BF%B0/</link>
      <pubDate>Mon, 22 Apr 2024 00:00:00 +0000</pubDate>
      <guid>https://huoxj.github.io/posts/se%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/c1-%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E6%A6%82%E8%BF%B0/</guid>
      <description>&lt;h1 id=&#34;第一章-计算机操作系统概述&#34;&gt;第一章-计算机操作系统概述&lt;/h1&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;本章结构&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;p&gt;&lt;img src=&#34;https://runzblog.oss-cn-hangzhou.aliyuncs.com/postimg/202409271717415.png&#34; alt=&#34;image-20240422141854716&#34;&gt;&lt;/p&gt;&#xA;&lt;h2 id=&#34;122-操作系统及其分类&#34;&gt;1.2.2-操作系统及其分类&lt;/h2&gt;&#xA;&lt;h3 id=&#34;理论&#34;&gt;理论&lt;/h3&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;&#xA;&lt;p&gt;OS的&lt;strong&gt;概念&lt;/strong&gt;：OS是计算机系统最基础的系统软件，管理软硬件资源、控制程序执行、改善人机界面、合理组织计算机工作流程，为用户使用计算机提供良好运行环境&lt;/p&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;&#xA;&lt;p&gt;OS的&lt;strong&gt;组成&lt;/strong&gt;：进程调度、进程通信、内存管理、设备管理、文件管理、网络通信、作业控制&lt;/p&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;&#xA;&lt;p&gt;OS的&lt;strong&gt;类型&lt;/strong&gt;：&lt;/p&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;多道批处理系统（脱机）&lt;/li&gt;&#xA;&lt;li&gt;分时操作系统&lt;/li&gt;&#xA;&lt;li&gt;实时操作系统&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;h2 id=&#34;135-程序接口的视角&#34;&gt;1.3.5-程序接口的视角&lt;/h2&gt;&#xA;&lt;h3 id=&#34;系统调用&#34;&gt;系统调用&lt;/h3&gt;&#xA;&lt;p&gt;&lt;img src=&#34;https://runzblog.oss-cn-hangzhou.aliyuncs.com/postimg/202409272308402.png&#34; alt=&#34;image-20240927230851266&#34;&gt;&lt;/p&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;实现的基础是陷阱机制：从用户态陷入内核态&lt;/li&gt;&#xA;&lt;li&gt;调用系统调用时(int **h)，操作系统从用户态转入内核态执行系统调用&lt;/li&gt;&#xA;&lt;li&gt;系统调用返回时转入用户态&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;h2 id=&#34;136-系统结构的视角&#34;&gt;1.3.6-系统结构的视角&lt;/h2&gt;&#xA;&lt;h3 id=&#34;操作系统内核设计&#34;&gt;操作系统内核设计&lt;/h3&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;设计概念：模块化、层次化、虚拟化&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;h4 id=&#34;内核设计分类&#34;&gt;内核设计分类&lt;/h4&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;单内核&#xA;&lt;ul&gt;&#xA;&lt;li&gt;在一大坨代码中实际包含了所有操作系统功能，并作为一个单一进程运行，具有唯一地址空间。&lt;/li&gt;&#xA;&lt;li&gt;大部分UNIX(包括Linxu)系统都采用的单体内核。&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;微内核&#xA;&lt;ul&gt;&#xA;&lt;li&gt;&lt;a href=&#34;blog.csdn.net/silentpebble/article/details/7941025&#34;&gt;大部分OS功能作为单独的进程在内核态外运行，他们通过消息传递进行通讯&lt;/a&gt;。&lt;/li&gt;&#xA;&lt;li&gt;内核态只有最基本、最核心的功能模块。比如IPC、虚存、调度&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;混合内核&lt;/li&gt;&#xA;&lt;li&gt;外内核&#xA;&lt;ul&gt;&#xA;&lt;li&gt;OS本身值提供很低级的硬件操作，没有很完整的硬件抽象。&lt;/li&gt;&#xA;&lt;li&gt;用在嵌入式上&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;/ul&gt;</description>
    </item>
    <item>
      <title>C2 处理器管理</title>
      <link>https://huoxj.github.io/posts/se%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/c2-%E5%A4%84%E7%90%86%E5%99%A8%E7%AE%A1%E7%90%86/</link>
      <pubDate>Mon, 22 Apr 2024 00:00:00 +0000</pubDate>
      <guid>https://huoxj.github.io/posts/se%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/c2-%E5%A4%84%E7%90%86%E5%99%A8%E7%AE%A1%E7%90%86/</guid>
      <description>&lt;h1 id=&#34;第二章-处理器管理&#34;&gt;第二章-处理器管理&lt;/h1&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;本章结构&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;p&gt;&lt;img src=&#34;https://runzblog.oss-cn-hangzhou.aliyuncs.com/postimg/202409271717642.png&#34; alt=&#34;image-20240422145053555&#34;&gt;&lt;/p&gt;&#xA;&lt;h2 id=&#34;21-处理器&#34;&gt;2.1-处理器&lt;/h2&gt;&#xA;&lt;h3 id=&#34;特权指令&#34;&gt;特权指令&lt;/h3&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;特权指令：只能被操作系统内核使用的指令&lt;/li&gt;&#xA;&lt;li&gt;比如启动IO指令、置PC指令等&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;h3 id=&#34;处理器模式&#34;&gt;处理器模式&lt;/h3&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;0=OS内核；1=系统调用；2=共享库程序；3=用户程序&lt;/li&gt;&#xA;&lt;li&gt;现代操作系统：内核模式(特权指令ok)，用户模式(非特权指令)&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;h2 id=&#34;22-中断&#34;&gt;2.2-中断&lt;/h2&gt;&#xA;&lt;h3 id=&#34;中断概念&#34;&gt;中断概念&lt;/h3&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;&lt;strong&gt;广义中断&lt;/strong&gt;：程序执行过程中，遇到急需处理的事件时，暂时中止当前程序的运行，转去执行相应的事件处理程序。等中断处理完成后再返回原程序中断的地方或调度其他程序执行的过程叫中断。&lt;/li&gt;&#xA;&lt;li&gt;&lt;strong&gt;狭义中断&lt;/strong&gt;：事件来源于处理器外的广义中断。如IO中断、时钟中断、外部信号中断&lt;/li&gt;&#xA;&lt;li&gt;&lt;strong&gt;广义中断 minus 狭义中断&lt;/strong&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;异常：事件来源于处理器运行指令引起的广义中断。如地址异常、算术异常、处理器硬件故障&lt;/li&gt;&#xA;&lt;li&gt;系统异常：执行陷入(trap)指令而触发系统调用引起的终端事件。如请求设备、请求IO、创建进程&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;h3 id=&#34;中断驱动下的进程状态机&#34;&gt;中断驱动下的进程状态机&lt;/h3&gt;&#xA;&lt;p&gt;&lt;img src=&#34;https://runzblog.oss-cn-hangzhou.aliyuncs.com/postimg/202409271717238.png&#34; alt=&#34;&#34;&gt;&lt;/p&gt;&#xA;&lt;h3 id=&#34;中断源&#34;&gt;中断源&lt;/h3&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;处理器硬件故障中断&lt;/li&gt;&#xA;&lt;li&gt;程序性中断&lt;/li&gt;&#xA;&lt;li&gt;自愿性中断-系统调用&lt;/li&gt;&#xA;&lt;li&gt;IO中断&lt;/li&gt;&#xA;&lt;li&gt;外部中断&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;h2 id=&#34;23-进程&#34;&gt;2.3-进程&lt;/h2&gt;&#xA;&lt;h3 id=&#34;进程的概念&#34;&gt;⭐⭐⭐进程的概念&lt;/h3&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;进程是一个具有一定独立功能的&lt;strong&gt;程序&lt;/strong&gt;关于某个&lt;strong&gt;数据集合&lt;/strong&gt;的一次运行活动&lt;/li&gt;&#xA;&lt;li&gt;进程是操作系统进行&lt;strong&gt;资源分配&lt;/strong&gt;和&lt;strong&gt;调度&lt;/strong&gt;的一个独立单位&#xA;&lt;ul&gt;&#xA;&lt;li&gt;对于多线程系统来说，进程是&lt;strong&gt;资源分配&lt;/strong&gt;的独立单位&lt;/li&gt;&#xA;&lt;li&gt;线程是资源调度的独立单位&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;h3 id=&#34;进程的形式化定义&#34;&gt;进程的形式化定义&lt;/h3&gt;&#xA;&lt;p&gt;&lt;img src=&#34;https://runzblog.oss-cn-hangzhou.aliyuncs.com/postimg/202409271718917.png&#34; alt=&#34;&#34;&gt;&lt;/p&gt;&#xA;&lt;h3 id=&#34;进程的三态模型&#34;&gt;⭐⭐⭐&lt;strong&gt;进程的三态模型&lt;/strong&gt;&lt;/h3&gt;&#xA;&lt;p&gt;&lt;img src=&#34;https://runzblog.oss-cn-hangzhou.aliyuncs.com/postimg/202409271718439.png&#34; alt=&#34;&#34;&gt;&lt;/p&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;&#xA;&lt;p&gt;&lt;strong&gt;运行态&lt;/strong&gt;指进程占有处理器运行&lt;/p&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;&#xA;&lt;p&gt;&lt;strong&gt;就绪态&lt;/strong&gt;指进程具备运行条件等待处理器运行&lt;/p&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;&#xA;&lt;p&gt;&lt;strong&gt;等待态&lt;/strong&gt;指进程由于等待资源、输入输出、信号等而不具备运行条件&lt;/p&gt;&#xA;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;h3 id=&#34;进程挂起&#34;&gt;进程挂起&lt;/h3&gt;&#xA;&lt;p&gt;&lt;img src=&#34;https://runzblog.oss-cn-hangzhou.aliyuncs.com/postimg/202409271719195.png&#34; alt=&#34;&#34;&gt;&lt;/p&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;计算机资源不足，会剥夺某些进程的资源，调入OS管理的堆换区。这些进程就被挂起了。&lt;/li&gt;&#xA;&lt;li&gt;挂起的进程&lt;strong&gt;不参加进程调度&lt;/strong&gt;。在适当的时候被调回内存。&lt;/li&gt;&#xA;&lt;li&gt;挂起和非运行态的本质区别是有没有&lt;strong&gt;占用系统资源&lt;/strong&gt;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;p&gt;&lt;img src=&#34;https://runzblog.oss-cn-hangzhou.aliyuncs.com/postimg/202409271719451.png&#34; alt=&#34;&#34;&gt;&lt;/p&gt;&#xA;&lt;h3 id=&#34;进程控制块-pcb&#34;&gt;⭐⭐⭐进程控制块 PCB&lt;/h3&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;&#xA;&lt;p&gt;OS用于记录和刻画进程状态及环境信息的数据结构。说白了就是面向OS的&lt;strong&gt;进程的花名册&lt;/strong&gt;&lt;/p&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;&#xA;&lt;p&gt;包含&lt;strong&gt;标识信息&lt;/strong&gt;、&lt;strong&gt;现场信息&lt;/strong&gt;、&lt;strong&gt;控制信息&lt;/strong&gt;。&lt;/p&gt;&#xA;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;h3 id=&#34;进程映像-process-image&#34;&gt;⭐⭐⭐进程映像 Process Image&lt;/h3&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;进程的&lt;strong&gt;内存级&lt;/strong&gt;实体&lt;/li&gt;&#xA;&lt;li&gt;包括：PCB、进程程序空间、进程数据空间、核心栈&#xA;&lt;ul&gt;&#xA;&lt;li&gt;核心栈就是在内核态执行指令时用的栈&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;h3 id=&#34;进程上下文-process-context&#34;&gt;进程上下文 Process Context&lt;/h3&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;进程执行所需要的环境信息&lt;/li&gt;&#xA;&lt;li&gt;包括：用户级上下文、寄存器上下文、系统级上下文&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;h3 id=&#34;原语-primitive&#34;&gt;原语 Primitive&lt;/h3&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;若干条指令构成的程序，执行上具有原子性。意思是原语不可能被中断。&lt;/li&gt;&#xA;&lt;li&gt;用于执行一些涉及修改OS核心数据结构的操作。为了防止并发和中断等时间上的错误，原语必须整块执行。&lt;/li&gt;&#xA;&lt;li&gt;常用原语：进程控制原语、进程通信原语&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;h2 id=&#34;24-多线程技术&#34;&gt;2.4-多线程技术&lt;/h2&gt;&#xA;&lt;h3 id=&#34;为什么要多线程&#34;&gt;为什么要多线程&lt;/h3&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;单线程能一定程度上实现并发了，但我们还想更进一步。&lt;/li&gt;&#xA;&lt;li&gt;限制单线程并发程度的要素：&#xA;&lt;ul&gt;&#xA;&lt;li&gt;进程切换开销大。想切换执行路径就必须换进程，开销很大。&lt;/li&gt;&#xA;&lt;li&gt;进程通信开销大。进程通信要陷入系统调用，涉及模式转换，开销大。&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;解决：&#xA;&lt;ul&gt;&#xA;&lt;li&gt;分离&lt;strong&gt;资源分配&lt;/strong&gt;和&lt;strong&gt;调度&lt;/strong&gt;。因为资源分配比较静态，不会很频繁。相对而言，(如果想更加并发的话)调度比资源分配频繁多了。&lt;/li&gt;&#xA;&lt;li&gt;两者分离的结果就是&lt;strong&gt;进程&lt;/strong&gt;和&lt;strong&gt;线程&lt;/strong&gt;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;h3 id=&#34;进程和线程&#34;&gt;进程和线程&lt;/h3&gt;&#xA;&lt;h4 id=&#34;进程&#34;&gt;进程&lt;/h4&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;&#xA;&lt;p&gt;操作系统的视角：是OS进行保护和&lt;strong&gt;资源分配&lt;/strong&gt;的独立单位。&lt;/p&gt;</description>
    </item>
  </channel>
</rss>
