<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>C&#43;&#43;拾遗 on Runz&#39;s Blog</title>
    <link>https://huoxj.github.io/series/c&#43;&#43;%E6%8B%BE%E9%81%97/</link>
    <description>Recent content in C&#43;&#43;拾遗 on Runz&#39;s Blog</description>
    <generator>Hugo</generator>
    <language>cn</language>
    <lastBuildDate>Thu, 10 Apr 2025 00:00:00 +0000</lastBuildDate>
    <atom:link href="https://huoxj.github.io/series/c++%E6%8B%BE%E9%81%97/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>智能指针踩坑</title>
      <link>https://huoxj.github.io/posts/c&#43;&#43;%E6%8B%BE%E9%81%97/%E6%99%BA%E8%83%BD%E6%8C%87%E9%92%88%E8%B8%A9%E5%9D%91/</link>
      <pubDate>Thu, 10 Apr 2025 00:00:00 +0000</pubDate>
      <guid>https://huoxj.github.io/posts/c&#43;&#43;%E6%8B%BE%E9%81%97/%E6%99%BA%E8%83%BD%E6%8C%87%E9%92%88%E8%B8%A9%E5%9D%91/</guid>
      <description></description>
    </item>
    <item>
      <title>智能指针、裸指针和引用</title>
      <link>https://huoxj.github.io/posts/c&#43;&#43;%E6%8B%BE%E9%81%97/%E6%99%BA%E8%83%BD%E6%8C%87%E9%92%88%E8%A3%B8%E6%8C%87%E9%92%88%E5%92%8C%E5%BC%95%E7%94%A8/</link>
      <pubDate>Wed, 09 Apr 2025 00:00:00 +0000</pubDate>
      <guid>https://huoxj.github.io/posts/c&#43;&#43;%E6%8B%BE%E9%81%97/%E6%99%BA%E8%83%BD%E6%8C%87%E9%92%88%E8%A3%B8%E6%8C%87%E9%92%88%E5%92%8C%E5%BC%95%E7%94%A8/</guid>
      <description>&lt;p&gt;主要讲讲三者的使用场景。以及延伸一下 RAII 和所有权。&lt;/p&gt;</description>
    </item>
    <item>
      <title>宏</title>
      <link>https://huoxj.github.io/posts/c&#43;&#43;%E6%8B%BE%E9%81%97/%E5%AE%8F/</link>
      <pubDate>Tue, 11 Mar 2025 00:00:00 +0000</pubDate>
      <guid>https://huoxj.github.io/posts/c&#43;&#43;%E6%8B%BE%E9%81%97/%E5%AE%8F/</guid>
      <description>&lt;h1 id=&#34;头文件多次-include&#34;&gt;头文件多次 include&lt;/h1&gt;&#xA;&lt;p&gt;&lt;code&gt;#include&lt;/code&gt; 的作用是将对应文件直接拷贝过来。这不可避免地会导致某个头文件被拷贝了多次，从而造成重复定义的问题。&lt;/p&gt;&#xA;&lt;p&gt;目前已知两种解决方法：条件编译 和 &lt;code&gt;pragma once&lt;/code&gt;&lt;/p&gt;&#xA;&lt;h2 id=&#34;方法简述&#34;&gt;方法简述&lt;/h2&gt;&#xA;&lt;h3 id=&#34;条件编译&#34;&gt;条件编译&lt;/h3&gt;&#xA;&lt;p&gt;条件编译可以让宏拥有判断的特性。&lt;/p&gt;&#xA;&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#d8dee9;background-color:#2e3440;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-cpp&#34; data-lang=&#34;cpp&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#5e81ac;font-style:italic&#34;&gt;#define CONDITION&#xA;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#5e81ac;font-style:italic&#34;&gt;&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#5e81ac;font-style:italic&#34;&gt;#ifdef CONDITION&#xA;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#5e81ac;font-style:italic&#34;&gt;&lt;/span&gt;&lt;span style=&#34;color:#eceff4&#34;&gt;...&lt;/span&gt;    &lt;span style=&#34;color:#616e87;font-style:italic&#34;&gt;// section a&#xA;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#616e87;font-style:italic&#34;&gt;&lt;/span&gt;&lt;span style=&#34;color:#5e81ac;font-style:italic&#34;&gt;#else&#xA;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#5e81ac;font-style:italic&#34;&gt;&lt;/span&gt;&lt;span style=&#34;color:#eceff4&#34;&gt;...&lt;/span&gt;    &lt;span style=&#34;color:#616e87;font-style:italic&#34;&gt;// section b&#xA;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#616e87;font-style:italic&#34;&gt;&lt;/span&gt;&lt;span style=&#34;color:#5e81ac;font-style:italic&#34;&gt;#endif&#xA;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;定义了 &lt;code&gt;CONDITION&lt;/code&gt; 宏，编译器会只编译 section a 的内容，丢弃 section b。&lt;/p&gt;&#xA;&lt;p&gt;除此之外，还有 &lt;code&gt;ifndef&lt;/code&gt; &lt;code&gt;elif&lt;/code&gt; 等宏。&lt;/p&gt;&#xA;&lt;blockquote&gt;&#xA;&lt;p&gt;ifndef 即 if not define&lt;/p&gt;&#xA;&lt;/blockquote&gt;&#xA;&lt;p&gt;在可能被多次 include 的头文件开头定义一个宏，并将后面所有的内容包裹在 ifdef 中，可以保证 ifdef 宏包裹的内容不被多次 include。&lt;/p&gt;&#xA;&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#d8dee9;background-color:#2e3440;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-cpp&#34; data-lang=&#34;cpp&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#5e81ac;font-style:italic&#34;&gt;#ifndef __UTILS_H__&#xA;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#5e81ac;font-style:italic&#34;&gt;#define __UTILS_H__&#xA;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#5e81ac;font-style:italic&#34;&gt;&lt;/span&gt;&lt;span style=&#34;color:#eceff4&#34;&gt;...&lt;/span&gt;    &lt;span style=&#34;color:#616e87;font-style:italic&#34;&gt;// contents of the header&#xA;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#616e87;font-style:italic&#34;&gt;&lt;/span&gt;&lt;span style=&#34;color:#5e81ac;font-style:italic&#34;&gt;#endif&#xA;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;blockquote&gt;&#xA;&lt;p&gt;CLion IDE 在创建头文件时会自动帮你生成这段条件编译&lt;/p&gt;&#xA;&lt;/blockquote&gt;&#xA;&lt;h3 id=&#34;pragma-once&#34;&gt;pragma once&lt;/h3&gt;&#xA;&lt;p&gt;使用很简单，在头文件开头加上：&lt;/p&gt;&#xA;&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#d8dee9;background-color:#2e3440;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-cpp&#34; data-lang=&#34;cpp&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#5e81ac;font-style:italic&#34;&gt;#pragma once&#xA;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;结束。&lt;/p&gt;&#xA;&lt;h2 id=&#34;方法对比&#34;&gt;方法对比&lt;/h2&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;pragma once 使用更简单&lt;/li&gt;&#xA;&lt;li&gt;pragma 某些编译器不支持，用小作坊手搓的编译器可能会寄寄&#xA;&lt;ul&gt;&#xA;&lt;li&gt;gcc, clang 是支持的&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;/ul&gt;</description>
    </item>
    <item>
      <title>STL-算法</title>
      <link>https://huoxj.github.io/posts/c&#43;&#43;%E6%8B%BE%E9%81%97/stl-%E7%AE%97%E6%B3%95/</link>
      <pubDate>Sun, 19 Jan 2025 00:00:00 +0000</pubDate>
      <guid>https://huoxj.github.io/posts/c&#43;&#43;%E6%8B%BE%E9%81%97/stl-%E7%AE%97%E6%B3%95/</guid>
      <description>&lt;h2 id=&#34;谓词&#34;&gt;谓词&lt;/h2&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;std::all_of&lt;/li&gt;&#xA;&lt;li&gt;std::any_of&lt;/li&gt;&#xA;&lt;li&gt;std::none_of&lt;/li&gt;&#xA;&lt;/ul&gt;</description>
    </item>
    <item>
      <title>异常处理</title>
      <link>https://huoxj.github.io/posts/c&#43;&#43;%E6%8B%BE%E9%81%97/%E5%BC%82%E5%B8%B8%E5%A4%84%E7%90%86/</link>
      <pubDate>Sun, 29 Dec 2024 00:00:00 +0000</pubDate>
      <guid>https://huoxj.github.io/posts/c&#43;&#43;%E6%8B%BE%E9%81%97/%E5%BC%82%E5%B8%B8%E5%A4%84%E7%90%86/</guid>
      <description>&lt;h2 id=&#34;错误&#34;&gt;错误&lt;/h2&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;语法错误：编译器解决&lt;/li&gt;&#xA;&lt;li&gt;逻辑错误：测试解决&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;h2 id=&#34;异常&#34;&gt;异常&lt;/h2&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;运行环境造成。如内存不足、文件操作失败等&lt;/li&gt;&#xA;&lt;li&gt;特征&#xA;&lt;ul&gt;&#xA;&lt;li&gt;可以预见&lt;/li&gt;&#xA;&lt;li&gt;无法避免&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;异常处理：提高程序鲁棒性&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;h2 id=&#34;异常处理方法&#34;&gt;异常处理方法&lt;/h2&gt;&#xA;&lt;p&gt;传统的方法是，使用&lt;strong&gt;函数参数&lt;/strong&gt;或者&lt;strong&gt;返回值&lt;/strong&gt;来标识是否发生异常、发生什么异常。&lt;/p&gt;&#xA;&lt;p&gt;函数&lt;strong&gt;调用者&lt;/strong&gt;检查参数或者返回值来确定异常，并&lt;strong&gt;处理异常&lt;/strong&gt;。&lt;/p&gt;&#xA;&lt;p&gt;这样需要逐层返回。并且对于一些特殊的情况无法处理，比如构造函数发生异常。&lt;/p&gt;&#xA;&lt;hr&gt;&#xA;&lt;h2 id=&#34;c-异常处理机制&#34;&gt;C++ 异常处理机制&lt;/h2&gt;&#xA;&lt;h3 id=&#34;try&#34;&gt;try&lt;/h3&gt;&#xA;&lt;p&gt;&lt;strong&gt;监控&lt;/strong&gt;语句序列中是否发生异常。&lt;/p&gt;&#xA;&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#d8dee9;background-color:#2e3440;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-cpp&#34; data-lang=&#34;cpp&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#81a1c1;font-weight:bold&#34;&gt;try&lt;/span&gt;&lt;span style=&#34;color:#eceff4&#34;&gt;{&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&#x9;statements to monitor&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#eceff4&#34;&gt;}&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;h3 id=&#34;throw&#34;&gt;throw&lt;/h3&gt;&#xA;&lt;p&gt;try 中检测到异常时，&lt;strong&gt;抛出&lt;/strong&gt;异常。&lt;/p&gt;&#xA;&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#d8dee9;background-color:#2e3440;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-cpp&#34; data-lang=&#34;cpp&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#81a1c1;font-weight:bold&#34;&gt;throw&lt;/span&gt; expression&#xA;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;h3 id=&#34;catch&#34;&gt;catch&lt;/h3&gt;&#xA;&lt;p&gt;捕获异常并处理。try 后可以跟随多个 catch 来捕获不同类型的异常。&lt;/p&gt;&#xA;&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#d8dee9;background-color:#2e3440;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-cpp&#34; data-lang=&#34;cpp&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#81a1c1;font-weight:bold&#34;&gt;catch&lt;/span&gt; &lt;span style=&#34;color:#eceff4&#34;&gt;(&lt;/span&gt;ExceptionType e&lt;span style=&#34;color:#eceff4&#34;&gt;){&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&#x9;deal with exception&lt;span style=&#34;color:#eceff4&#34;&gt;...&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#eceff4&#34;&gt;}&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;h3 id=&#34;异常处理的嵌套&#34;&gt;异常处理的嵌套&lt;/h3&gt;&#xA;&lt;p&gt;抛出的异常会在&lt;strong&gt;调用链&lt;/strong&gt;中自下往上捕获。&lt;/p&gt;&#xA;&lt;p&gt;最终还未被捕获的异常，由系统的 abort 处理。&lt;/p&gt;&#xA;&lt;p&gt;&lt;img src=&#34;https://runzblog.oss-cn-hangzhou.aliyuncs.com/postimg/202412290856374.png&#34; alt=&#34;&#34;&gt;&lt;/p&gt;&#xA;&lt;h3 id=&#34;异常类间的继承&#34;&gt;异常类间的继承&lt;/h3&gt;&#xA;&lt;p&gt;在捕获一系列有继承关系的异常类对象的时候，需要注意：&lt;/p&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;用&lt;strong&gt;引用&lt;/strong&gt;传递异常对象。&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;p&gt;即：&lt;/p&gt;&#xA;&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#d8dee9;background-color:#2e3440;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-cpp&#34; data-lang=&#34;cpp&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#81a1c1;font-weight:bold&#34;&gt;try&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#eceff4&#34;&gt;{...}&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#81a1c1;font-weight:bold&#34;&gt;catch&lt;/span&gt;&lt;span style=&#34;color:#eceff4&#34;&gt;(&lt;/span&gt;Exception1 &lt;span style=&#34;color:#81a1c1&#34;&gt;&amp;amp;&lt;/span&gt;e1&lt;span style=&#34;color:#eceff4&#34;&gt;){...}&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#81a1c1;font-weight:bold&#34;&gt;catch&lt;/span&gt;&lt;span style=&#34;color:#eceff4&#34;&gt;(&lt;/span&gt;Exception2 &lt;span style=&#34;color:#81a1c1&#34;&gt;&amp;amp;&lt;/span&gt;e2&lt;span style=&#34;color:#eceff4&#34;&gt;){...}&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;如果直接传异常对象，容易发生对象切片。&lt;/p&gt;&#xA;&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#d8dee9;background-color:#2e3440;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-cpp&#34; data-lang=&#34;cpp&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#81a1c1;font-weight:bold&#34;&gt;class&lt;/span&gt; &lt;span style=&#34;color:#8fbcbb&#34;&gt;EBase&lt;/span&gt; &lt;span style=&#34;color:#eceff4&#34;&gt;{};&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#81a1c1;font-weight:bold&#34;&gt;class&lt;/span&gt; &lt;span style=&#34;color:#8fbcbb&#34;&gt;EDerived&lt;/span&gt;&lt;span style=&#34;color:#81a1c1&#34;&gt;:&lt;/span&gt; &lt;span style=&#34;color:#81a1c1;font-weight:bold&#34;&gt;public&lt;/span&gt; EBase &lt;span style=&#34;color:#eceff4&#34;&gt;{};&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#81a1c1&#34;&gt;void&lt;/span&gt; &lt;span style=&#34;color:#88c0d0&#34;&gt;f&lt;/span&gt;&lt;span style=&#34;color:#eceff4&#34;&gt;(&lt;/span&gt;EBase e&lt;span style=&#34;color:#eceff4&#34;&gt;)&lt;/span&gt; &lt;span style=&#34;color:#eceff4&#34;&gt;{&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&#x9;&lt;span style=&#34;color:#81a1c1;font-weight:bold&#34;&gt;throw&lt;/span&gt; e&lt;span style=&#34;color:#eceff4&#34;&gt;;&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#eceff4&#34;&gt;}&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;EDerived e&lt;span style=&#34;color:#eceff4&#34;&gt;;&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#81a1c1;font-weight:bold&#34;&gt;try&lt;/span&gt; &lt;span style=&#34;color:#eceff4&#34;&gt;{&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&#x9;f&lt;span style=&#34;color:#eceff4&#34;&gt;(&lt;/span&gt;e&lt;span style=&#34;color:#eceff4&#34;&gt;);&lt;/span&gt;  &lt;span style=&#34;color:#616e87;font-style:italic&#34;&gt;// Object Slicing, throwing EBase instead of EDerived&#xA;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#616e87;font-style:italic&#34;&gt;&lt;/span&gt;&lt;span style=&#34;color:#eceff4&#34;&gt;}&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#81a1c1;font-weight:bold&#34;&gt;catch&lt;/span&gt;&lt;span style=&#34;color:#eceff4&#34;&gt;(&lt;/span&gt;EDerived e&lt;span style=&#34;color:#eceff4&#34;&gt;)&lt;/span&gt; &lt;span style=&#34;color:#eceff4&#34;&gt;{&lt;/span&gt; cout&lt;span style=&#34;color:#81a1c1&#34;&gt;&amp;lt;&amp;lt;&lt;/span&gt;&lt;span style=&#34;color:#a3be8c&#34;&gt;&amp;#34;Derived&amp;#34;&lt;/span&gt;&lt;span style=&#34;color:#eceff4&#34;&gt;;&lt;/span&gt; &lt;span style=&#34;color:#eceff4&#34;&gt;}&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#81a1c1;font-weight:bold&#34;&gt;catch&lt;/span&gt;&lt;span style=&#34;color:#eceff4&#34;&gt;(&lt;/span&gt;EBase e&lt;span style=&#34;color:#eceff4&#34;&gt;)&lt;/span&gt; &lt;span style=&#34;color:#eceff4&#34;&gt;{&lt;/span&gt; cout&lt;span style=&#34;color:#81a1c1&#34;&gt;&amp;lt;&amp;lt;&lt;/span&gt;&lt;span style=&#34;color:#a3be8c&#34;&gt;&amp;#34;Base&amp;#34;&lt;/span&gt;&lt;span style=&#34;color:#eceff4&#34;&gt;;&lt;/span&gt; &lt;span style=&#34;color:#eceff4&#34;&gt;}&lt;/span&gt;  &lt;span style=&#34;color:#616e87;font-style:italic&#34;&gt;// e caught here&#xA;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;ul&gt;&#xA;&lt;li&gt;按 “从最派生的类到最基的类” 的顺序来捕获&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;p&gt;catch 是按声明顺序捕获的。&lt;/p&gt;</description>
    </item>
    <item>
      <title>C&#43;&#43; 强制类型转换</title>
      <link>https://huoxj.github.io/posts/c&#43;&#43;%E6%8B%BE%E9%81%97/c&#43;&#43;-%E5%BC%BA%E5%88%B6%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2/</link>
      <pubDate>Tue, 24 Dec 2024 00:00:00 +0000</pubDate>
      <guid>https://huoxj.github.io/posts/c&#43;&#43;%E6%8B%BE%E9%81%97/c&#43;&#43;-%E5%BC%BA%E5%88%B6%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2/</guid>
      <description>&lt;h2 id=&#34;why&#34;&gt;Why&lt;/h2&gt;&#xA;&lt;p&gt;C 中的强制类型转换是通过在表达式前面加类型名实现的。&lt;/p&gt;&#xA;&lt;p&gt;C++ 中，强制类型转换被细分成了四个运算符：&lt;/p&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;static_cast&lt;/li&gt;&#xA;&lt;li&gt;reinterpret_cast&lt;/li&gt;&#xA;&lt;li&gt;const_cast&lt;/li&gt;&#xA;&lt;li&gt;dynamic_cast&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;p&gt;原因如下：&lt;/p&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;不同场景下的强制转换，风险是不同的，需要细分来体现&#xA;比如，int 转成 double 是风险不大的；但是将 const 指针转换成非 const 指针是十分危险的。&lt;/li&gt;&#xA;&lt;li&gt;在继承场景下，将基类转换成派生类需要检查是否成功&#xA;C 中的强制转换是无法知道基类指针转换成派生类是否成功的。但是 dynamic_cast 可以以返回 nullptr 的方式告诉你转换是否成功。&lt;/li&gt;&#xA;&lt;li&gt;程序中强制类型转换难以定位&#xA;新方法中，你只需要找 cast 单词出现的地方，就能知道所有进行了显示强制类型转换的地方。&lt;/li&gt;&#xA;&lt;li&gt;类型转换出错时，cast 会报错，方便定位错误&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;h2 id=&#34;static_cast&#34;&gt;static_cast&lt;/h2&gt;&#xA;&lt;p&gt;static_cast 负责风险低、自然的转换。允许可以隐式转换的类型间的转换。&lt;/p&gt;&#xA;&lt;p&gt;具体来说：&lt;/p&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;允许&lt;strong&gt;基本类型&lt;/strong&gt;之间的转换。比如 int、float、double 之间的转换&lt;/li&gt;&#xA;&lt;li&gt;允许对象的重载了强制类型转换运算符的转换&lt;/li&gt;&#xA;&lt;li&gt;其他场景尽量不要用 static_cast&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;h2 id=&#34;dynamic_cast&#34;&gt;dynamic_cast&lt;/h2&gt;&#xA;&lt;p&gt;dynamic_cast 负责基类到派生类的引用和指针的转换。&lt;/p&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;目标类型是源类型的派生。即父转子。&lt;/li&gt;&#xA;&lt;li&gt;被转换的类需要有虚函数，否则会报错：&#xA;&lt;code&gt;bad_dynamic_cast_not_polymorphic: &#39;xxx&#39; is not polymorphic&lt;/code&gt;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;h2 id=&#34;reinterpret_cast&#34;&gt;reinterpret_cast&lt;/h2&gt;&#xA;&lt;p&gt;reinterpret_cast 负责指针的不安全的转换。转换时，逐 bit 复制数据，也印证了 reinterpret 的含义，就是对相同的 01 bit 流进行不同的解释。&lt;/p&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;负责不同类型的指针、引用之间的转换&lt;/li&gt;&#xA;&lt;li&gt;指针到指针数值（里面存的地址）的转换。&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;h2 id=&#34;const_cast&#34;&gt;const_cast&lt;/h2&gt;&#xA;&lt;p&gt;const_cast 负责去除 const 的转换。&lt;/p&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;将 const 的只读变量转换成普通的可读可写的变量&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;h2 id=&#34;参考&#34;&gt;参考&lt;/h2&gt;&#xA;&lt;p&gt;&lt;a href=&#34;https://c.biancheng.net/view/410.html&#34;&gt;C++强制类型转换运算符（static_cast、reinterpret_cast、const_cast和dynamic_cast） - C语言中文网&lt;/a&gt;&lt;/p&gt;</description>
    </item>
    <item>
      <title>C&#43;&#43;期末复习</title>
      <link>https://huoxj.github.io/posts/c&#43;&#43;%E6%8B%BE%E9%81%97/c&#43;&#43;%E6%9C%9F%E6%9C%AB%E5%A4%8D%E4%B9%A0/</link>
      <pubDate>Tue, 24 Dec 2024 00:00:00 +0000</pubDate>
      <guid>https://huoxj.github.io/posts/c&#43;&#43;%E6%8B%BE%E9%81%97/c&#43;&#43;%E6%9C%9F%E6%9C%AB%E5%A4%8D%E4%B9%A0/</guid>
      <description>&lt;p&gt;根据上课 PPT 和同学与学长的笔记整理而成。&lt;/p&gt;&#xA;&lt;h2 id=&#34;介绍&#34;&gt;介绍&lt;/h2&gt;&#xA;&lt;h3 id=&#34;c-历史&#34;&gt;C++ 历史&lt;/h3&gt;&#xA;&lt;p&gt;先跳过。。。&lt;/p&gt;&#xA;&lt;h2 id=&#34;结构化编程部分&#34;&gt;结构化编程部分&lt;/h2&gt;&#xA;&lt;h3 id=&#34;强制类型转换&#34;&gt;强制类型转换&lt;/h3&gt;&#xA;&lt;p&gt;article link=&amp;quot;/posts/C++拾遗/C++-强制类型转换&amp;quot; &amp;gt;}}&lt;/p&gt;&#xA;&lt;h3 id=&#34;表达式的副作用&#34;&gt;表达式的副作用&lt;/h3&gt;&#xA;&lt;p&gt;副作用，就是一个过程是否会修改参与的变量的性质。&lt;/p&gt;&#xA;&lt;p&gt;在表达式中，有副作用的运算符：&lt;code&gt;=&lt;/code&gt; &lt;code&gt;+=&lt;/code&gt; &lt;code&gt;++&lt;/code&gt; &lt;code&gt;&amp;lt;&amp;lt;&lt;/code&gt; 等等&#xA;无副作用的运算符：&lt;code&gt;+&lt;/code&gt; &lt;code&gt;&amp;amp;&amp;amp;&lt;/code&gt; 等等&lt;/p&gt;&#xA;&lt;hr&gt;&#xA;&lt;h3 id=&#34;decltype&#34;&gt;decltype&lt;/h3&gt;&#xA;&lt;p&gt;和 auto 有相似之处。&lt;/p&gt;&#xA;&lt;p&gt;auto 和 decltype 都用在声明变量上，都是基于 RTTI 机制实现的。&lt;/p&gt;&#xA;&lt;p&gt;auto 是对&lt;strong&gt;初始化&lt;/strong&gt;的右值进行类型推导，然后给声明的变量确定类型、赋值。&lt;/p&gt;&#xA;&lt;p&gt;decltype 是对传入的参数类型进行类型推导，然后本身就作为这个类型的名称。&lt;/p&gt;&#xA;&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#d8dee9;background-color:#2e3440;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-cpp&#34; data-lang=&#34;cpp&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#81a1c1&#34;&gt;int&lt;/span&gt; x &lt;span style=&#34;color:#81a1c1&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#b48ead&#34;&gt;0&lt;/span&gt;&lt;span style=&#34;color:#eceff4&#34;&gt;;&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#81a1c1&#34;&gt;int&lt;/span&gt;&lt;span style=&#34;color:#81a1c1&#34;&gt;&amp;amp;&lt;/span&gt; ref &lt;span style=&#34;color:#81a1c1&#34;&gt;=&lt;/span&gt; x&lt;span style=&#34;color:#eceff4&#34;&gt;;&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#81a1c1;font-weight:bold&#34;&gt;auto&lt;/span&gt; ref1 &lt;span style=&#34;color:#81a1c1&#34;&gt;=&lt;/span&gt; x&lt;span style=&#34;color:#eceff4&#34;&gt;;&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#81a1c1;font-weight:bold&#34;&gt;decltype&lt;/span&gt;&lt;span style=&#34;color:#eceff4&#34;&gt;(&lt;/span&gt;ref&lt;span style=&#34;color:#eceff4&#34;&gt;)&lt;/span&gt; ref2 &lt;span style=&#34;color:#81a1c1&#34;&gt;=&lt;/span&gt; x&lt;span style=&#34;color:#eceff4&#34;&gt;;&lt;/span&gt;  &lt;span style=&#34;color:#616e87;font-style:italic&#34;&gt;// equals to &amp;#34;int&amp;amp; ref2 = x&amp;#34;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;既然本身就作为这个类型的名称，我们也可以结合 using 和 typedef：&lt;/p&gt;&#xA;&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#d8dee9;background-color:#2e3440;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-cpp&#34; data-lang=&#34;cpp&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#81a1c1&#34;&gt;int&lt;/span&gt; x &lt;span style=&#34;color:#81a1c1&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#b48ead&#34;&gt;0&lt;/span&gt;&lt;span style=&#34;color:#eceff4&#34;&gt;;&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#81a1c1&#34;&gt;int&lt;/span&gt;&lt;span style=&#34;color:#81a1c1&#34;&gt;&amp;amp;&lt;/span&gt; ref &lt;span style=&#34;color:#81a1c1&#34;&gt;=&lt;/span&gt; x&lt;span style=&#34;color:#eceff4&#34;&gt;;&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#81a1c1;font-weight:bold&#34;&gt;using&lt;/span&gt; int_ref &lt;span style=&#34;color:#81a1c1&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#81a1c1;font-weight:bold&#34;&gt;decltype&lt;/span&gt;&lt;span style=&#34;color:#eceff4&#34;&gt;(&lt;/span&gt;ref&lt;span style=&#34;color:#eceff4&#34;&gt;);&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;h4 id=&#34;参考&#34;&gt;参考&lt;/h4&gt;&#xA;&lt;p&gt;&lt;a href=&#34;https://www.cnblogs.com/QG-whz/p/4952980.html&#34;&gt;C++11特性：decltype关键字 - melonstreet - 博客园&lt;/a&gt;&lt;/p&gt;</description>
    </item>
    <item>
      <title>三剑客</title>
      <link>https://huoxj.github.io/posts/c&#43;&#43;%E6%8B%BE%E9%81%97/%E4%B8%89%E5%89%91%E5%AE%A2/</link>
      <pubDate>Sat, 21 Dec 2024 00:00:00 +0000</pubDate>
      <guid>https://huoxj.github.io/posts/c&#43;&#43;%E6%8B%BE%E9%81%97/%E4%B8%89%E5%89%91%E5%AE%A2/</guid>
      <description>&lt;p&gt;std::optional&#xA;std::tuple&#xA;std::any&lt;/p&gt;</description>
    </item>
    <item>
      <title>流</title>
      <link>https://huoxj.github.io/posts/c&#43;&#43;%E6%8B%BE%E9%81%97/%E6%B5%81/</link>
      <pubDate>Thu, 12 Dec 2024 00:00:00 +0000</pubDate>
      <guid>https://huoxj.github.io/posts/c&#43;&#43;%E6%8B%BE%E9%81%97/%E6%B5%81/</guid>
      <description>&lt;h2 id=&#34;输入输出处理&#34;&gt;输入、输出处理&lt;/h2&gt;&#xA;&lt;h2 id=&#34;用流替代-sprintf--sscanf&#34;&gt;用流替代 sprintf / sscanf&lt;/h2&gt;&#xA;&lt;p&gt;&lt;a href=&#34;https://blog.csdn.net/Hodors/article/details/136045381&#34;&gt;C++如何理解 sprintf 函数 ，寻找更好的替代方案_c++ sprintf-CSDN博客&lt;/a&gt;&lt;/p&gt;</description>
    </item>
    <item>
      <title>锁与条件变量</title>
      <link>https://huoxj.github.io/posts/c&#43;&#43;%E6%8B%BE%E9%81%97/%E9%94%81%E4%B8%8E%E6%9D%A1%E4%BB%B6%E5%8F%98%E9%87%8F/</link>
      <pubDate>Wed, 11 Dec 2024 00:00:00 +0000</pubDate>
      <guid>https://huoxj.github.io/posts/c&#43;&#43;%E6%8B%BE%E9%81%97/%E9%94%81%E4%B8%8E%E6%9D%A1%E4%BB%B6%E5%8F%98%E9%87%8F/</guid>
      <description>&lt;ul&gt;&#xA;&lt;li&gt;std::mutex&lt;/li&gt;&#xA;&lt;li&gt;std::condition_variable&lt;/li&gt;&#xA;&lt;li&gt;std::unique_lock&lt;/li&gt;&#xA;&lt;li&gt;std::atomic&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;h2 id=&#34;参考&#34;&gt;参考&lt;/h2&gt;&#xA;&lt;p&gt;&lt;a href=&#34;https://blog.csdn.net/u012507022/article/details/85909567&#34;&gt;C++11多线程 unique_lock详解_uniquelock-CSDN博客&lt;/a&gt;&#xA;&lt;a href=&#34;https://blog.csdn.net/qq_38210354/article/details/107168532&#34;&gt;C++11多线程条件变量std::condition_variable详解（转 ）_while (!ready) cv.wait(lck);-CSDN博客&lt;/a&gt;&#xA;&lt;a href=&#34;https://blog.csdn.net/m0_75215937/article/details/135074541&#34;&gt;【C++入门到精通】condition_variable（条件变量）C++11 [ C++入门 ]_c++ condition variable-CSDN博客&lt;/a&gt;&#xA;&lt;a href=&#34;https://www.runoob.com/cplusplus/cpp-libs-atomic.html&#34;&gt;C++ 标准库 atomic | 菜鸟教程&lt;/a&gt;&lt;/p&gt;</description>
    </item>
    <item>
      <title>运算符重载</title>
      <link>https://huoxj.github.io/posts/c&#43;&#43;%E6%8B%BE%E9%81%97/%E8%BF%90%E7%AE%97%E7%AC%A6%E9%87%8D%E8%BD%BD/</link>
      <pubDate>Thu, 05 Dec 2024 00:00:00 +0000</pubDate>
      <guid>https://huoxj.github.io/posts/c&#43;&#43;%E6%8B%BE%E9%81%97/%E8%BF%90%E7%AE%97%E7%AC%A6%E9%87%8D%E8%BD%BD/</guid>
      <description>&lt;h2 id=&#34;可重载的运算符&#34;&gt;可重载的运算符&lt;/h2&gt;&#xA;&lt;p&gt;大部分运算符都可重载：&lt;/p&gt;&#xA;&lt;table&gt;&#xA;  &lt;thead&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;th style=&#34;text-align: left&#34;&gt;双目算术运算符&lt;/th&gt;&#xA;          &lt;th style=&#34;text-align: left&#34;&gt;+ (加)，-(减)，*(乘)，/(除)，% (取模)&lt;/th&gt;&#xA;      &lt;/tr&gt;&#xA;  &lt;/thead&gt;&#xA;  &lt;tbody&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;td style=&#34;text-align: left&#34;&gt;关系运算符&lt;/td&gt;&#xA;          &lt;td style=&#34;text-align: left&#34;&gt;==(等于)，!= (不等于)，&amp;lt; (小于)，&amp;gt; (大于)，&amp;lt;=(小于等于)，&amp;gt;=(大于等于)&lt;/td&gt;&#xA;      &lt;/tr&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;td style=&#34;text-align: left&#34;&gt;逻辑运算符&lt;/td&gt;&#xA;          &lt;td style=&#34;text-align: left&#34;&gt;||(逻辑或)，&amp;amp;&amp;amp;(逻辑与)，!(逻辑非)&lt;/td&gt;&#xA;      &lt;/tr&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;td style=&#34;text-align: left&#34;&gt;单目运算符&lt;/td&gt;&#xA;          &lt;td style=&#34;text-align: left&#34;&gt;+ (正)，-(负)，*(指针)，&amp;amp;(取地址)&lt;/td&gt;&#xA;      &lt;/tr&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;td style=&#34;text-align: left&#34;&gt;自增自减运算符&lt;/td&gt;&#xA;          &lt;td style=&#34;text-align: left&#34;&gt;++(自增)，&amp;ndash;(自减)&lt;/td&gt;&#xA;      &lt;/tr&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;td style=&#34;text-align: left&#34;&gt;位运算符&lt;/td&gt;&#xA;          &lt;td style=&#34;text-align: left&#34;&gt;| (按位或)，&amp;amp; (按位与)，~(按位取反)，^(按位异或),，&amp;laquo; (左移)，&amp;raquo;(右移)&lt;/td&gt;&#xA;      &lt;/tr&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;td style=&#34;text-align: left&#34;&gt;赋值运算符&lt;/td&gt;&#xA;          &lt;td style=&#34;text-align: left&#34;&gt;=, +=, -=, *=, /= , % = , &amp;amp;=, |=, ^=, &amp;laquo;=, &amp;raquo;=&lt;/td&gt;&#xA;      &lt;/tr&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;td style=&#34;text-align: left&#34;&gt;空间申请与释放&lt;/td&gt;&#xA;          &lt;td style=&#34;text-align: left&#34;&gt;new, delete, new[ ] , delete[]&lt;/td&gt;&#xA;      &lt;/tr&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;td style=&#34;text-align: left&#34;&gt;其他运算符&lt;/td&gt;&#xA;          &lt;td style=&#34;text-align: left&#34;&gt;&lt;strong&gt;()&lt;/strong&gt;(函数调用)，&lt;strong&gt;-&amp;gt;&lt;/strong&gt;(成员访问)，&lt;strong&gt;,&lt;/strong&gt;(逗号)，&lt;strong&gt;[]&lt;/strong&gt;(下标)&lt;/td&gt;&#xA;      &lt;/tr&gt;&#xA;  &lt;/tbody&gt;&#xA;&lt;/table&gt;&#xA;&lt;p&gt;所以，只需要记住不可重载的：&lt;/p&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;&lt;code&gt;.&lt;/code&gt;：成员访问&lt;/li&gt;&#xA;&lt;li&gt;&lt;code&gt;.*&lt;/code&gt;：成员指针的成员访问&lt;/li&gt;&#xA;&lt;li&gt;&lt;code&gt;::&lt;/code&gt;: 域运算符&lt;/li&gt;&#xA;&lt;li&gt;&lt;code&gt;?:&lt;/code&gt;: 三目运算符&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;p&gt;还有，&lt;strong&gt;不建议重载&lt;/strong&gt;的：&lt;/p&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;&lt;code&gt;&amp;amp;&amp;amp;&lt;/code&gt;, &lt;code&gt;||&lt;/code&gt;: 重载会影响短路机制&lt;/li&gt;&#xA;&lt;li&gt;改变原运算符含义的。比如 &lt;code&gt;+&lt;/code&gt; 重载成减法&lt;/li&gt;&#xA;&lt;li&gt;改变运算符的优先级、结合方向或操作数&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;p&gt;只能用成员函数重载的：&lt;/p&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;&lt;code&gt;=&lt;/code&gt;, &lt;code&gt;()&lt;/code&gt;, &lt;code&gt;[]&lt;/code&gt;, &lt;code&gt;-&amp;gt;&lt;/code&gt;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;h2 id=&#34;类内重载&#34;&gt;类内重载&lt;/h2&gt;&#xA;&lt;p&gt;类内重载，重载函数作为类的成员函数。运算符的操作数（中的&lt;strong&gt;第一个&lt;/strong&gt;）隐含了 this 指针。&lt;/p&gt;</description>
    </item>
    <item>
      <title>OO-继承与派生</title>
      <link>https://huoxj.github.io/posts/c&#43;&#43;%E6%8B%BE%E9%81%97/oo-%E7%BB%A7%E6%89%BF%E4%B8%8E%E6%B4%BE%E7%94%9F/</link>
      <pubDate>Thu, 21 Nov 2024 00:00:00 +0000</pubDate>
      <guid>https://huoxj.github.io/posts/c&#43;&#43;%E6%8B%BE%E9%81%97/oo-%E7%BB%A7%E6%89%BF%E4%B8%8E%E6%B4%BE%E7%94%9F/</guid>
      <description>&lt;h2 id=&#34;前言&#34;&gt;前言&lt;/h2&gt;&#xA;&lt;p&gt;考试必考。所以在网上找一些笔记，记下有价值的部分以供复习。&lt;/p&gt;&#xA;&lt;p&gt;继承和派生这对名词基本是一个意思，只是各自用语习惯不一样：&lt;/p&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;继承 —— 基类 —— 派生类&lt;/li&gt;&#xA;&lt;li&gt;派生 —— 基类 —— 派生类&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;p&gt;OO 是 Java 学的，所以我倾向于第一种表达。&lt;/p&gt;&#xA;&lt;h2 id=&#34;继承权限&#34;&gt;继承权限&lt;/h2&gt;&#xA;&lt;h3 id=&#34;继承方式&#34;&gt;继承方式&lt;/h3&gt;&#xA;&lt;p&gt;C++ 很神奇地提供了三种继承方式：public、private 和 protected。&lt;/p&gt;&#xA;&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#d8dee9;background-color:#2e3440;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-cpp&#34; data-lang=&#34;cpp&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#81a1c1;font-weight:bold&#34;&gt;class&lt;/span&gt; &lt;span style=&#34;color:#8fbcbb&#34;&gt;parent&lt;/span&gt;&lt;span style=&#34;color:#eceff4&#34;&gt;{};&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#81a1c1;font-weight:bold&#34;&gt;class&lt;/span&gt; &lt;span style=&#34;color:#8fbcbb&#34;&gt;child1&lt;/span&gt;&lt;span style=&#34;color:#81a1c1&#34;&gt;:&lt;/span&gt; &lt;span style=&#34;color:#81a1c1;font-weight:bold&#34;&gt;public&lt;/span&gt; parent&lt;span style=&#34;color:#eceff4&#34;&gt;{};&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#81a1c1;font-weight:bold&#34;&gt;class&lt;/span&gt; &lt;span style=&#34;color:#8fbcbb&#34;&gt;child2&lt;/span&gt;&lt;span style=&#34;color:#81a1c1&#34;&gt;:&lt;/span&gt; &lt;span style=&#34;color:#81a1c1;font-weight:bold&#34;&gt;protected&lt;/span&gt; parent&lt;span style=&#34;color:#eceff4&#34;&gt;{};&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#81a1c1;font-weight:bold&#34;&gt;class&lt;/span&gt; &lt;span style=&#34;color:#8fbcbb&#34;&gt;child3&lt;/span&gt;&lt;span style=&#34;color:#81a1c1&#34;&gt;:&lt;/span&gt; &lt;span style=&#34;color:#81a1c1;font-weight:bold&#34;&gt;private&lt;/span&gt; parent&lt;span style=&#34;color:#eceff4&#34;&gt;{};&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;继承方式决定了基类成员在派生类中的访问权限，权限高于继承方式的会被限制。&lt;/p&gt;&#xA;&lt;p&gt;比如 protected 继承会将基类中 public 的成员变成 protected。&lt;/p&gt;&#xA;&lt;h3 id=&#34;修改基类成员的访问权限&#34;&gt;修改基类成员的访问权限&lt;/h3&gt;&#xA;&lt;p&gt;使用 using 关键字可以修改基类成员在派生类中的访问权限。权限提高和降低都没问题。&lt;/p&gt;&#xA;&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#d8dee9;background-color:#2e3440;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-cpp&#34; data-lang=&#34;cpp&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#81a1c1;font-weight:bold&#34;&gt;class&lt;/span&gt; &lt;span style=&#34;color:#8fbcbb&#34;&gt;parent&lt;/span&gt;&lt;span style=&#34;color:#eceff4&#34;&gt;{&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#81a1c1;font-weight:bold&#34;&gt;protected&lt;/span&gt;&lt;span style=&#34;color:#81a1c1&#34;&gt;:&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&#x9;&lt;span style=&#34;color:#81a1c1&#34;&gt;int&lt;/span&gt; element&lt;span style=&#34;color:#eceff4&#34;&gt;;&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#eceff4&#34;&gt;};&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#81a1c1;font-weight:bold&#34;&gt;class&lt;/span&gt; &lt;span style=&#34;color:#8fbcbb&#34;&gt;child&lt;/span&gt;&lt;span style=&#34;color:#eceff4&#34;&gt;{&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#81a1c1;font-weight:bold&#34;&gt;public&lt;/span&gt;&lt;span style=&#34;color:#81a1c1&#34;&gt;:&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&#x9;&lt;span style=&#34;color:#81a1c1;font-weight:bold&#34;&gt;using&lt;/span&gt; parent&lt;span style=&#34;color:#81a1c1&#34;&gt;::&lt;/span&gt;element&lt;span style=&#34;color:#eceff4&#34;&gt;;&lt;/span&gt;    &lt;span style=&#34;color:#616e87;font-style:italic&#34;&gt;// protected -&amp;gt; public&#xA;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#616e87;font-style:italic&#34;&gt;&lt;/span&gt;&lt;span style=&#34;color:#81a1c1;font-weight:bold&#34;&gt;private&lt;/span&gt;&lt;span style=&#34;color:#81a1c1&#34;&gt;:&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&#x9;&lt;span style=&#34;color:#81a1c1;font-weight:bold&#34;&gt;using&lt;/span&gt; parent&lt;span style=&#34;color:#81a1c1&#34;&gt;::&lt;/span&gt;element&lt;span style=&#34;color:#eceff4&#34;&gt;;&lt;/span&gt;    &lt;span style=&#34;color:#616e87;font-style:italic&#34;&gt;// protected -&amp;gt; private&#xA;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#616e87;font-style:italic&#34;&gt;&lt;/span&gt;&lt;span style=&#34;color:#eceff4&#34;&gt;}&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;h2 id=&#34;成员覆盖&#34;&gt;成员覆盖&lt;/h2&gt;&#xA;&lt;p&gt;继承中的成员覆盖问题，本质是作用域的问题。&lt;/p&gt;&#xA;&lt;p&gt;通过派生类访问成员时，首先会在派生类的作用域下寻找这个名字的成员。如果没找到，再到基类的作用域里找。&lt;/p&gt;&#xA;&lt;p&gt;主要注意以下情景：&lt;/p&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;派生类同名成员变量访问权限低于基类时&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#d8dee9;background-color:#2e3440;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-cpp&#34; data-lang=&#34;cpp&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;parent&lt;span style=&#34;color:#eceff4&#34;&gt;{&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#81a1c1;font-weight:bold&#34;&gt;public&lt;/span&gt;&lt;span style=&#34;color:#81a1c1&#34;&gt;:&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&#x9;&lt;span style=&#34;color:#81a1c1&#34;&gt;int&lt;/span&gt; a&lt;span style=&#34;color:#eceff4&#34;&gt;;&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#eceff4&#34;&gt;};&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;child&lt;span style=&#34;color:#eceff4&#34;&gt;{&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#81a1c1;font-weight:bold&#34;&gt;private&lt;/span&gt;&lt;span style=&#34;color:#81a1c1&#34;&gt;:&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&#x9;&lt;span style=&#34;color:#81a1c1&#34;&gt;int&lt;/span&gt; a&lt;span style=&#34;color:#eceff4&#34;&gt;;&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#eceff4&#34;&gt;}&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;child c&lt;span style=&#34;color:#eceff4&#34;&gt;;&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;c&lt;span style=&#34;color:#eceff4&#34;&gt;.&lt;/span&gt;a&lt;span style=&#34;color:#eceff4&#34;&gt;;&lt;/span&gt;         &lt;span style=&#34;color:#616e87;font-style:italic&#34;&gt;// cannot access a.&#xA;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#616e87;font-style:italic&#34;&gt;&lt;/span&gt;c&lt;span style=&#34;color:#eceff4&#34;&gt;.&lt;/span&gt;parent&lt;span style=&#34;color:#eceff4&#34;&gt;.&lt;/span&gt;a&lt;span style=&#34;color:#eceff4&#34;&gt;;&lt;/span&gt;  &lt;span style=&#34;color:#616e87;font-style:italic&#34;&gt;// ok&#xA;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;ul&gt;&#xA;&lt;li&gt;派生类与基类不会发生函数重载&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#d8dee9;background-color:#2e3440;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-cpp&#34; data-lang=&#34;cpp&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;parent&lt;span style=&#34;color:#eceff4&#34;&gt;{&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&#x9;&lt;span style=&#34;color:#81a1c1&#34;&gt;void&lt;/span&gt; &lt;span style=&#34;color:#88c0d0&#34;&gt;foo&lt;/span&gt;&lt;span style=&#34;color:#eceff4&#34;&gt;(&lt;/span&gt;&lt;span style=&#34;color:#81a1c1&#34;&gt;int&lt;/span&gt; a&lt;span style=&#34;color:#eceff4&#34;&gt;);&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#eceff4&#34;&gt;};&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;child&lt;span style=&#34;color:#eceff4&#34;&gt;{&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&#x9;&lt;span style=&#34;color:#81a1c1&#34;&gt;void&lt;/span&gt; &lt;span style=&#34;color:#88c0d0&#34;&gt;foo&lt;/span&gt;&lt;span style=&#34;color:#eceff4&#34;&gt;(&lt;/span&gt;&lt;span style=&#34;color:#81a1c1&#34;&gt;double&lt;/span&gt; a&lt;span style=&#34;color:#eceff4&#34;&gt;);&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#eceff4&#34;&gt;}&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;child c&lt;span style=&#34;color:#eceff4&#34;&gt;;&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#81a1c1&#34;&gt;int&lt;/span&gt; a&lt;span style=&#34;color:#eceff4&#34;&gt;;&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;c&lt;span style=&#34;color:#eceff4&#34;&gt;.&lt;/span&gt;foo&lt;span style=&#34;color:#eceff4&#34;&gt;(&lt;/span&gt;a&lt;span style=&#34;color:#eceff4&#34;&gt;);&lt;/span&gt;          &lt;span style=&#34;color:#616e87;font-style:italic&#34;&gt;// double&#xA;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#616e87;font-style:italic&#34;&gt;&lt;/span&gt;c&lt;span style=&#34;color:#eceff4&#34;&gt;.&lt;/span&gt;parent&lt;span style=&#34;color:#81a1c1&#34;&gt;::&lt;/span&gt;foo&lt;span style=&#34;color:#eceff4&#34;&gt;(&lt;/span&gt;a&lt;span style=&#34;color:#eceff4&#34;&gt;);&lt;/span&gt;  &lt;span style=&#34;color:#616e87;font-style:italic&#34;&gt;// int&#xA;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;h2 id=&#34;构造函数&#34;&gt;构造函数&lt;/h2&gt;&#xA;&lt;p&gt;构造函数无法继承。&lt;/p&gt;</description>
    </item>
    <item>
      <title>OO 杂项</title>
      <link>https://huoxj.github.io/posts/c&#43;&#43;%E6%8B%BE%E9%81%97/oo-%E6%9D%82%E9%A1%B9/</link>
      <pubDate>Wed, 20 Nov 2024 00:00:00 +0000</pubDate>
      <guid>https://huoxj.github.io/posts/c&#43;&#43;%E6%8B%BE%E9%81%97/oo-%E6%9D%82%E9%A1%B9/</guid>
      <description>&lt;h2 id=&#34;类的内存模型&#34;&gt;类的内存模型&lt;/h2&gt;&#xA;&lt;p&gt;&lt;a href=&#34;https://nimrod.blog/posts/what-does-cpp-object-layout-look-like/&#34;&gt;What does C++ Object Layout Look Like? | Nimrod&amp;rsquo;s Coding Lab&lt;/a&gt;&lt;/p&gt;&#xA;&lt;h2 id=&#34;空类默认提供的方法&#34;&gt;空类默认提供的方法&lt;/h2&gt;&#xA;&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#d8dee9;background-color:#2e3440;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-cpp&#34; data-lang=&#34;cpp&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#81a1c1;font-weight:bold&#34;&gt;class&lt;/span&gt; &lt;span style=&#34;color:#8fbcbb&#34;&gt;T&lt;/span&gt; &lt;span style=&#34;color:#eceff4&#34;&gt;{};&lt;/span&gt;  &#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#81a1c1;font-weight:bold&#34;&gt;class&lt;/span&gt; &lt;span style=&#34;color:#8fbcbb&#34;&gt;T&lt;/span&gt; &lt;span style=&#34;color:#eceff4&#34;&gt;{&lt;/span&gt;  &#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&#x9;T&lt;span style=&#34;color:#eceff4&#34;&gt;();&lt;/span&gt;                            &lt;span style=&#34;color:#616e87;font-style:italic&#34;&gt;// 构造函数&#xA;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#616e87;font-style:italic&#34;&gt;&lt;/span&gt;&#x9;T&lt;span style=&#34;color:#eceff4&#34;&gt;(&lt;/span&gt;&lt;span style=&#34;color:#81a1c1;font-weight:bold&#34;&gt;const&lt;/span&gt; T&lt;span style=&#34;color:#81a1c1&#34;&gt;&amp;amp;&lt;/span&gt;&lt;span style=&#34;color:#eceff4&#34;&gt;);&lt;/span&gt;                    &lt;span style=&#34;color:#616e87;font-style:italic&#34;&gt;// 拷贝构造&#xA;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#616e87;font-style:italic&#34;&gt;&lt;/span&gt;&#x9;T&lt;span style=&#34;color:#eceff4&#34;&gt;(&lt;/span&gt;&lt;span style=&#34;color:#81a1c1;font-weight:bold&#34;&gt;const&lt;/span&gt; T&lt;span style=&#34;color:#81a1c1&#34;&gt;&amp;amp;&amp;amp;&lt;/span&gt;&lt;span style=&#34;color:#eceff4&#34;&gt;);&lt;/span&gt;                   &lt;span style=&#34;color:#616e87;font-style:italic&#34;&gt;// 拷贝构造 rval&#xA;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#616e87;font-style:italic&#34;&gt;&lt;/span&gt;&#x9;&lt;span style=&#34;color:#81a1c1&#34;&gt;~&lt;/span&gt;T&lt;span style=&#34;color:#eceff4&#34;&gt;();&lt;/span&gt;                           &lt;span style=&#34;color:#616e87;font-style:italic&#34;&gt;// 析构函数&#xA;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#616e87;font-style:italic&#34;&gt;&lt;/span&gt;&#x9;T&lt;span style=&#34;color:#81a1c1&#34;&gt;&amp;amp;&lt;/span&gt; &lt;span style=&#34;color:#81a1c1;font-weight:bold&#34;&gt;operator&lt;/span&gt;&lt;span style=&#34;color:#81a1c1&#34;&gt;=&lt;/span&gt;&lt;span style=&#34;color:#eceff4&#34;&gt;(&lt;/span&gt;&lt;span style=&#34;color:#81a1c1;font-weight:bold&#34;&gt;const&lt;/span&gt; T&lt;span style=&#34;color:#81a1c1&#34;&gt;&amp;amp;&lt;/span&gt;&lt;span style=&#34;color:#eceff4&#34;&gt;);&lt;/span&gt;         &lt;span style=&#34;color:#616e87;font-style:italic&#34;&gt;// 拷贝赋值&#xA;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#616e87;font-style:italic&#34;&gt;&lt;/span&gt;&#x9;T&lt;span style=&#34;color:#81a1c1&#34;&gt;&amp;amp;&lt;/span&gt; &lt;span style=&#34;color:#81a1c1;font-weight:bold&#34;&gt;operator&lt;/span&gt;&lt;span style=&#34;color:#81a1c1&#34;&gt;=&lt;/span&gt;&lt;span style=&#34;color:#eceff4&#34;&gt;(&lt;/span&gt;&lt;span style=&#34;color:#81a1c1;font-weight:bold&#34;&gt;const&lt;/span&gt; T&lt;span style=&#34;color:#81a1c1&#34;&gt;&amp;amp;&amp;amp;&lt;/span&gt;&lt;span style=&#34;color:#eceff4&#34;&gt;);&lt;/span&gt;        &lt;span style=&#34;color:#616e87;font-style:italic&#34;&gt;// 拷贝赋值 rval&#xA;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#616e87;font-style:italic&#34;&gt;&lt;/span&gt;&#x9;T &lt;span style=&#34;color:#81a1c1&#34;&gt;*&lt;/span&gt;&lt;span style=&#34;color:#81a1c1;font-weight:bold&#34;&gt;operator&lt;/span&gt; &lt;span style=&#34;color:#81a1c1&#34;&gt;&amp;amp;&lt;/span&gt;&lt;span style=&#34;color:#eceff4&#34;&gt;();&lt;/span&gt;                &lt;span style=&#34;color:#616e87;font-style:italic&#34;&gt;// 取地址&#xA;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#616e87;font-style:italic&#34;&gt;&lt;/span&gt;&#x9;&lt;span style=&#34;color:#81a1c1;font-weight:bold&#34;&gt;const&lt;/span&gt; T&lt;span style=&#34;color:#81a1c1&#34;&gt;*&lt;/span&gt; &lt;span style=&#34;color:#81a1c1;font-weight:bold&#34;&gt;operator&lt;/span&gt; &lt;span style=&#34;color:#81a1c1&#34;&gt;&amp;amp;&lt;/span&gt;&lt;span style=&#34;color:#eceff4&#34;&gt;()&lt;/span&gt; &lt;span style=&#34;color:#81a1c1;font-weight:bold&#34;&gt;const&lt;/span&gt;&lt;span style=&#34;color:#eceff4&#34;&gt;;&lt;/span&gt;    &lt;span style=&#34;color:#616e87;font-style:italic&#34;&gt;// 取地址 const 重载版&#xA;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#616e87;font-style:italic&#34;&gt;&lt;/span&gt;&lt;span style=&#34;color:#eceff4&#34;&gt;};&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;最后两个函数比较怪。一个是返回非 const 的指针，另一个返回 const 的。在调用时，编译器如何决定调用哪个呢？&lt;/p&gt;&#xA;&lt;p&gt;注意函数后的 const 修饰符。这两个函数实际应该长这样：&lt;/p&gt;&#xA;&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#d8dee9;background-color:#2e3440;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-cpp&#34; data-lang=&#34;cpp&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;T &lt;span style=&#34;color:#81a1c1&#34;&gt;*&lt;/span&gt;&lt;span style=&#34;color:#81a1c1;font-weight:bold&#34;&gt;operator&lt;/span&gt; &lt;span style=&#34;color:#81a1c1&#34;&gt;&amp;amp;&lt;/span&gt;&lt;span style=&#34;color:#eceff4&#34;&gt;(&lt;/span&gt;T &lt;span style=&#34;color:#81a1c1&#34;&gt;*&lt;/span&gt;&lt;span style=&#34;color:#81a1c1;font-weight:bold&#34;&gt;this&lt;/span&gt;&lt;span style=&#34;color:#eceff4&#34;&gt;);&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#81a1c1;font-weight:bold&#34;&gt;const&lt;/span&gt; T&lt;span style=&#34;color:#81a1c1&#34;&gt;*&lt;/span&gt; &lt;span style=&#34;color:#81a1c1;font-weight:bold&#34;&gt;operator&lt;/span&gt; &lt;span style=&#34;color:#81a1c1&#34;&gt;&amp;amp;&lt;/span&gt;&lt;span style=&#34;color:#eceff4&#34;&gt;(&lt;/span&gt;&lt;span style=&#34;color:#81a1c1;font-weight:bold&#34;&gt;const&lt;/span&gt; T &lt;span style=&#34;color:#81a1c1&#34;&gt;*&lt;/span&gt;&lt;span style=&#34;color:#81a1c1;font-weight:bold&#34;&gt;this&lt;/span&gt;&lt;span style=&#34;color:#eceff4&#34;&gt;);&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;是 this 指针的功劳。调用方是哪种就执行哪个。&lt;/p&gt;&#xA;&lt;h2 id=&#34;const-与-static-成员&#34;&gt;const 与 static 成员&lt;/h2&gt;&#xA;&lt;h3 id=&#34;static-const-成员变量&#34;&gt;static const 成员变量&lt;/h3&gt;&#xA;&lt;p&gt;对于成员变量，变量会在&lt;strong&gt;编译期&lt;/strong&gt;确定，并被放到程序静态区。运行时，这个成员和类与对象在内存上没有关系，但是要通过类名来访问。&lt;/p&gt;</description>
    </item>
    <item>
      <title>杂项</title>
      <link>https://huoxj.github.io/posts/c&#43;&#43;%E6%8B%BE%E9%81%97/%E6%9D%82%E9%A1%B9/</link>
      <pubDate>Sun, 17 Nov 2024 00:00:00 +0000</pubDate>
      <guid>https://huoxj.github.io/posts/c&#43;&#43;%E6%8B%BE%E9%81%97/%E6%9D%82%E9%A1%B9/</guid>
      <description>&lt;h2 id=&#34;raii--智能指针&#34;&gt;RAII &amp;amp; 智能指针&lt;/h2&gt;&#xA;&lt;h3 id=&#34;raii&#34;&gt;RAII&lt;/h3&gt;&#xA;&lt;p&gt;RAII： Resource acquisition is initialization&lt;/p&gt;&#xA;&lt;p&gt;将资源管理交给其本身的思想。&lt;/p&gt;&#xA;&lt;p&gt;尽量使用对象的生命周期来管理资源，初始化时调用构造函数进行资源分配，离开作用域时自动调用析构函数释放资源。而不是自己来管理资源的分配与释放。&lt;/p&gt;&#xA;&lt;h3 id=&#34;智能指针&#34;&gt;智能指针&lt;/h3&gt;&#xA;&lt;p&gt;所以很自然想到智能指针：&lt;/p&gt;&#xA;&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#d8dee9;background-color:#2e3440;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-cpp&#34; data-lang=&#34;cpp&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#81a1c1;font-weight:bold&#34;&gt;template&lt;/span&gt;&lt;span style=&#34;color:#81a1c1&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span style=&#34;color:#81a1c1;font-weight:bold&#34;&gt;class&lt;/span&gt; &lt;span style=&#34;color:#8fbcbb&#34;&gt;T&lt;/span&gt;&lt;span style=&#34;color:#81a1c1&#34;&gt;&amp;gt;&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#81a1c1;font-weight:bold&#34;&gt;class&lt;/span&gt; &lt;span style=&#34;color:#8fbcbb&#34;&gt;auto_ptr&lt;/span&gt;&lt;span style=&#34;color:#eceff4&#34;&gt;{&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&#x9;&lt;span style=&#34;color:#81a1c1;font-weight:bold&#34;&gt;public&lt;/span&gt;&lt;span style=&#34;color:#81a1c1&#34;&gt;:&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&#x9;&#x9;auto_ptr&lt;span style=&#34;color:#eceff4&#34;&gt;(&lt;/span&gt;T &lt;span style=&#34;color:#81a1c1&#34;&gt;*&lt;/span&gt;p&lt;span style=&#34;color:#81a1c1&#34;&gt;=&lt;/span&gt;&lt;span style=&#34;color:#b48ead&#34;&gt;0&lt;/span&gt;&lt;span style=&#34;color:#eceff4&#34;&gt;)&lt;/span&gt;&lt;span style=&#34;color:#81a1c1&#34;&gt;:&lt;/span&gt;ptr&lt;span style=&#34;color:#eceff4&#34;&gt;(&lt;/span&gt;p&lt;span style=&#34;color:#eceff4&#34;&gt;)&lt;/span&gt; &lt;span style=&#34;color:#eceff4&#34;&gt;{}&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&#x9;&#x9;&lt;span style=&#34;color:#81a1c1&#34;&gt;~&lt;/span&gt;auto_ptr&lt;span style=&#34;color:#eceff4&#34;&gt;()&lt;/span&gt; &lt;span style=&#34;color:#eceff4&#34;&gt;{&lt;/span&gt; &lt;span style=&#34;color:#81a1c1;font-weight:bold&#34;&gt;delete&lt;/span&gt; ptr&lt;span style=&#34;color:#eceff4&#34;&gt;;&lt;/span&gt; &lt;span style=&#34;color:#eceff4&#34;&gt;}&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&#x9;&#x9;T&lt;span style=&#34;color:#81a1c1&#34;&gt;*&lt;/span&gt; &lt;span style=&#34;color:#81a1c1;font-weight:bold&#34;&gt;operator&lt;/span&gt;&lt;span style=&#34;color:#81a1c1&#34;&gt;-&amp;gt;&lt;/span&gt;&lt;span style=&#34;color:#eceff4&#34;&gt;()&lt;/span&gt; &lt;span style=&#34;color:#81a1c1;font-weight:bold&#34;&gt;const&lt;/span&gt; &lt;span style=&#34;color:#eceff4&#34;&gt;{&lt;/span&gt; &lt;span style=&#34;color:#81a1c1;font-weight:bold&#34;&gt;return&lt;/span&gt; ptr&lt;span style=&#34;color:#eceff4&#34;&gt;;&lt;/span&gt; &lt;span style=&#34;color:#eceff4&#34;&gt;}&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&#x9;&#x9;T&lt;span style=&#34;color:#81a1c1&#34;&gt;&amp;amp;&lt;/span&gt; &lt;span style=&#34;color:#81a1c1;font-weight:bold&#34;&gt;operator&lt;/span&gt; &lt;span style=&#34;color:#81a1c1&#34;&gt;*&lt;/span&gt;&lt;span style=&#34;color:#eceff4&#34;&gt;()&lt;/span&gt; &lt;span style=&#34;color:#81a1c1;font-weight:bold&#34;&gt;const&lt;/span&gt; &lt;span style=&#34;color:#eceff4&#34;&gt;{&lt;/span&gt; &lt;span style=&#34;color:#81a1c1;font-weight:bold&#34;&gt;return&lt;/span&gt; &lt;span style=&#34;color:#81a1c1&#34;&gt;*&lt;/span&gt;ptr&lt;span style=&#34;color:#eceff4&#34;&gt;;&lt;/span&gt; &lt;span style=&#34;color:#eceff4&#34;&gt;}&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&#x9;&lt;span style=&#34;color:#81a1c1;font-weight:bold&#34;&gt;private&lt;/span&gt;&lt;span style=&#34;color:#81a1c1&#34;&gt;:&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&#x9;&#x9;T&lt;span style=&#34;color:#81a1c1&#34;&gt;*&lt;/span&gt; ptr&lt;span style=&#34;color:#eceff4&#34;&gt;;&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#eceff4&#34;&gt;}&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;这种手搓的是会出问题的。比如拷贝构造后，两个智能指针对象指向同一块内存，会导致这块内存被析构函数释放两次。&lt;/p&gt;&#xA;&lt;h3 id=&#34;标准库智能指针&#34;&gt;标准库智能指针&lt;/h3&gt;&#xA;&lt;p&gt;头文件：&lt;code&gt;#include &amp;lt;memory&amp;gt;&lt;/code&gt;&lt;/p&gt;&#xA;&lt;h4 id=&#34;auto_ptr&#34;&gt;auto_ptr&lt;/h4&gt;&#xA;&lt;p&gt;和手搓的基本一样。代码不是很复杂的情况下用这个就行。&lt;/p&gt;&#xA;&lt;h4 id=&#34;unique_ptr&#34;&gt;unique_ptr&lt;/h4&gt;&#xA;&lt;p&gt;独占所有权的指针。就是说，unique_ptr 指向的内存只能被它一个人占有。同一时间内只会有一个 unique_ptr 指向同一块内存。&lt;/p&gt;&#xA;&lt;p&gt;这建立在你完全使用 unique_ptr 提供的接口的情况之上。也就是说完全有办法让两个 unique_ptr 指向同一块内存。&lt;/p&gt;&#xA;&lt;p&gt;C++14 以后，使用 &lt;code&gt;std::make_unique&lt;/code&gt; 来创建 unique_ptr。&lt;/p&gt;&#xA;&lt;p&gt;特点是：&lt;/p&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;不允许拷贝构造&lt;/li&gt;&#xA;&lt;li&gt;支持移动语义&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#d8dee9;background-color:#2e3440;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-cpp&#34; data-lang=&#34;cpp&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#81a1c1;font-weight:bold&#34;&gt;using&lt;/span&gt; int_ptr&lt;span style=&#34;color:#81a1c1&#34;&gt;=&lt;/span&gt;std&lt;span style=&#34;color:#81a1c1&#34;&gt;::&lt;/span&gt;unique_ptr&lt;span style=&#34;color:#81a1c1&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span style=&#34;color:#81a1c1&#34;&gt;int&lt;/span&gt;&lt;span style=&#34;color:#81a1c1&#34;&gt;&amp;gt;&lt;/span&gt;&lt;span style=&#34;color:#eceff4&#34;&gt;;&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#81a1c1&#34;&gt;int&lt;/span&gt; &lt;span style=&#34;color:#81a1c1&#34;&gt;*&lt;/span&gt;ptr &lt;span style=&#34;color:#81a1c1&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#81a1c1;font-weight:bold&#34;&gt;new&lt;/span&gt; &lt;span style=&#34;color:#81a1c1&#34;&gt;int&lt;/span&gt;&lt;span style=&#34;color:#eceff4&#34;&gt;(&lt;/span&gt;&lt;span style=&#34;color:#b48ead&#34;&gt;5&lt;/span&gt;&lt;span style=&#34;color:#eceff4&#34;&gt;);&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;int_ptr &lt;span style=&#34;color:#88c0d0&#34;&gt;p&lt;/span&gt;&lt;span style=&#34;color:#eceff4&#34;&gt;(&lt;/span&gt;ptr&lt;span style=&#34;color:#eceff4&#34;&gt;);&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;int_ptr p_ &lt;span style=&#34;color:#81a1c1&#34;&gt;=&lt;/span&gt; std&lt;span style=&#34;color:#81a1c1&#34;&gt;::&lt;/span&gt;make_unique&lt;span style=&#34;color:#81a1c1&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span style=&#34;color:#81a1c1&#34;&gt;int&lt;/span&gt;&lt;span style=&#34;color:#81a1c1&#34;&gt;&amp;gt;&lt;/span&gt;&lt;span style=&#34;color:#eceff4&#34;&gt;(&lt;/span&gt;&lt;span style=&#34;color:#b48ead&#34;&gt;5&lt;/span&gt;&lt;span style=&#34;color:#eceff4&#34;&gt;);&lt;/span&gt;  &lt;span style=&#34;color:#616e87;font-style:italic&#34;&gt;// In c++14&#xA;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#616e87;font-style:italic&#34;&gt;&lt;/span&gt;cout&lt;span style=&#34;color:#81a1c1&#34;&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span style=&#34;color:#81a1c1&#34;&gt;*&lt;/span&gt;p &lt;span style=&#34;color:#81a1c1&#34;&gt;&amp;lt;&amp;lt;&lt;/span&gt; endl&lt;span style=&#34;color:#eceff4&#34;&gt;;&lt;/span&gt;  &lt;span style=&#34;color:#616e87;font-style:italic&#34;&gt;// 5&#xA;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#616e87;font-style:italic&#34;&gt;&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;int_ptr q &lt;span style=&#34;color:#81a1c1&#34;&gt;=&lt;/span&gt; p&lt;span style=&#34;color:#eceff4&#34;&gt;;&lt;/span&gt;  &lt;span style=&#34;color:#616e87;font-style:italic&#34;&gt;// you can not clone unique_ptr!!!&#xA;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#616e87;font-style:italic&#34;&gt;&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;int_ptr &lt;span style=&#34;color:#88c0d0&#34;&gt;r&lt;/span&gt;&lt;span style=&#34;color:#eceff4&#34;&gt;(&lt;/span&gt;std&lt;span style=&#34;color:#81a1c1&#34;&gt;::&lt;/span&gt;move&lt;span style=&#34;color:#eceff4&#34;&gt;(&lt;/span&gt;p&lt;span style=&#34;color:#eceff4&#34;&gt;));&lt;/span&gt;  &lt;span style=&#34;color:#616e87;font-style:italic&#34;&gt;// move semantic&#xA;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#616e87;font-style:italic&#34;&gt;&lt;/span&gt;cout&lt;span style=&#34;color:#81a1c1&#34;&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span style=&#34;color:#81a1c1&#34;&gt;*&lt;/span&gt;r &lt;span style=&#34;color:#81a1c1&#34;&gt;&amp;lt;&amp;lt;&lt;/span&gt; endl&lt;span style=&#34;color:#eceff4&#34;&gt;;&lt;/span&gt;  &lt;span style=&#34;color:#616e87;font-style:italic&#34;&gt;// 5&#xA;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#616e87;font-style:italic&#34;&gt;&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;int_ptr &lt;span style=&#34;color:#88c0d0&#34;&gt;s&lt;/span&gt;&lt;span style=&#34;color:#eceff4&#34;&gt;(&lt;/span&gt;ptr&lt;span style=&#34;color:#eceff4&#34;&gt;);&lt;/span&gt;  &lt;span style=&#34;color:#616e87;font-style:italic&#34;&gt;// this will cause double free!!!&#xA;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;h4 id=&#34;shared_ptr&#34;&gt;shared_ptr&lt;/h4&gt;&#xA;&lt;p&gt;含引用计数的指针。这样就可以实现多个指针指向同一对象了。&lt;/p&gt;</description>
    </item>
    <item>
      <title>可变参数</title>
      <link>https://huoxj.github.io/posts/c&#43;&#43;%E6%8B%BE%E9%81%97/%E5%8F%AF%E5%8F%98%E5%8F%82%E6%95%B0/</link>
      <pubDate>Fri, 15 Nov 2024 00:00:00 +0000</pubDate>
      <guid>https://huoxj.github.io/posts/c&#43;&#43;%E6%8B%BE%E9%81%97/%E5%8F%AF%E5%8F%98%E5%8F%82%E6%95%B0/</guid>
      <description>&lt;p&gt;向函数传不定个数的参数就是可变参数。标识符为 &lt;code&gt;...&lt;/code&gt;。&lt;/p&gt;&#xA;&lt;p&gt;举例：&lt;/p&gt;&#xA;&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#d8dee9;background-color:#2e3440;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-c&#34; data-lang=&#34;c&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#81a1c1&#34;&gt;int&lt;/span&gt; &lt;span style=&#34;color:#88c0d0&#34;&gt;printf&lt;/span&gt;&lt;span style=&#34;color:#eceff4&#34;&gt;(&lt;/span&gt;&lt;span style=&#34;color:#81a1c1;font-weight:bold&#34;&gt;const&lt;/span&gt; &lt;span style=&#34;color:#81a1c1&#34;&gt;char&lt;/span&gt; &lt;span style=&#34;color:#81a1c1&#34;&gt;*&lt;/span&gt;format&lt;span style=&#34;color:#eceff4&#34;&gt;,&lt;/span&gt; &lt;span style=&#34;color:#eceff4&#34;&gt;...);&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;h2 id=&#34;在-c-中的使用&#34;&gt;在 C 中的使用&lt;/h2&gt;&#xA;&lt;p&gt;C 中使用可变参数需要引入头文件 &lt;code&gt;stdarg.h&lt;/code&gt;。&lt;/p&gt;</description>
    </item>
    <item>
      <title>移动语义与右值引用</title>
      <link>https://huoxj.github.io/posts/c&#43;&#43;%E6%8B%BE%E9%81%97/%E7%A7%BB%E5%8A%A8%E8%AF%AD%E4%B9%89%E4%B8%8E%E5%8F%B3%E5%80%BC%E5%BC%95%E7%94%A8/</link>
      <pubDate>Sun, 10 Nov 2024 00:00:00 +0000</pubDate>
      <guid>https://huoxj.github.io/posts/c&#43;&#43;%E6%8B%BE%E9%81%97/%E7%A7%BB%E5%8A%A8%E8%AF%AD%E4%B9%89%E4%B8%8E%E5%8F%B3%E5%80%BC%E5%BC%95%E7%94%A8/</guid>
      <description>&lt;h2 id=&#34;参考&#34;&gt;参考&lt;/h2&gt;&#xA;&lt;p&gt;&lt;a href=&#34;https://www.cprogramming.com/c++11/rvalue-references-and-move-semantics-in-c++11.html#google_vignette&#34;&gt;Rvalue References and Move Semantics in C++11 - Cprogramming.com&lt;/a&gt;&lt;/p&gt;&#xA;&lt;p&gt;&lt;a href=&#34;https://zhuanlan.zhihu.com/p/347977300&#34;&gt;认识C++移动语义与右值引用 - 知乎&lt;/a&gt;&lt;/p&gt;</description>
    </item>
    <item>
      <title>关键字</title>
      <link>https://huoxj.github.io/posts/c&#43;&#43;%E6%8B%BE%E9%81%97/%E5%85%B3%E9%94%AE%E5%AD%97/</link>
      <pubDate>Sun, 20 Oct 2024 00:00:00 +0000</pubDate>
      <guid>https://huoxj.github.io/posts/c&#43;&#43;%E6%8B%BE%E9%81%97/%E5%85%B3%E9%94%AE%E5%AD%97/</guid>
      <description>&lt;h2 id=&#34;typedef&#34;&gt;typedef&lt;/h2&gt;&#xA;&lt;p&gt;字面意思，给类型取别名。&lt;/p&gt;&#xA;&lt;h3 id=&#34;和-define-的区别&#34;&gt;和 define 的区别&lt;/h3&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;&#xA;&lt;p&gt;define 可以替换任何东西，比如常量、编译开关等&lt;/p&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;&#xA;&lt;p&gt;define 在编译之前的预处理阶段生效，typedef 在编译阶段生效。&lt;/p&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;&#xA;&lt;p&gt;typedef可以只在某个作用域内生效。&lt;/p&gt;&#xA;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#d8dee9;background-color:#2e3440;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-cpp&#34; data-lang=&#34;cpp&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#81a1c1&#34;&gt;int&lt;/span&gt; &lt;span style=&#34;color:#88c0d0&#34;&gt;main&lt;/span&gt;&lt;span style=&#34;color:#eceff4&#34;&gt;()&lt;/span&gt; &lt;span style=&#34;color:#eceff4&#34;&gt;{&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&#x9;&lt;span style=&#34;color:#81a1c1;font-weight:bold&#34;&gt;typedef&lt;/span&gt; &lt;span style=&#34;color:#81a1c1&#34;&gt;int&lt;/span&gt; size_t&lt;span style=&#34;color:#eceff4&#34;&gt;;&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&#x9;size_t s &lt;span style=&#34;color:#81a1c1&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#b48ead&#34;&gt;3&lt;/span&gt;&lt;span style=&#34;color:#eceff4&#34;&gt;;&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&#x9;fun&lt;span style=&#34;color:#eceff4&#34;&gt;();&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#eceff4&#34;&gt;}&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#81a1c1&#34;&gt;int&lt;/span&gt; &lt;span style=&#34;color:#88c0d0&#34;&gt;fun&lt;/span&gt;&lt;span style=&#34;color:#eceff4&#34;&gt;()&lt;/span&gt; &lt;span style=&#34;color:#eceff4&#34;&gt;{&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&#x9;size_t t &lt;span style=&#34;color:#81a1c1&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#b48ead&#34;&gt;2&lt;/span&gt;&lt;span style=&#34;color:#eceff4&#34;&gt;;&lt;/span&gt; &lt;span style=&#34;color:#616e87;font-style:italic&#34;&gt;// ERROR&#xA;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#616e87;font-style:italic&#34;&gt;&lt;/span&gt;&lt;span style=&#34;color:#eceff4&#34;&gt;}&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;ul&gt;&#xA;&lt;li&gt;对指针的修饰不同&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;p&gt;含 const 时，两者不等价&#xA;TODO&lt;/p&gt;&#xA;&lt;h3 id=&#34;类型别名&#34;&gt;类型别名&lt;/h3&gt;&#xA;&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#d8dee9;background-color:#2e3440;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-cpp&#34; data-lang=&#34;cpp&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#81a1c1;font-weight:bold&#34;&gt;typedef&lt;/span&gt; &lt;span style=&#34;color:#81a1c1&#34;&gt;unsigned&lt;/span&gt; &lt;span style=&#34;color:#81a1c1&#34;&gt;int&lt;/span&gt; size_t&#xA;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;h3 id=&#34;结构体别名&#34;&gt;结构体别名&lt;/h3&gt;&#xA;&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#d8dee9;background-color:#2e3440;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-cpp&#34; data-lang=&#34;cpp&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#81a1c1;font-weight:bold&#34;&gt;typedef&lt;/span&gt; &lt;span style=&#34;color:#81a1c1;font-weight:bold&#34;&gt;struct&lt;/span&gt; &lt;span style=&#34;color:#8fbcbb&#34;&gt;person&lt;/span&gt;&lt;span style=&#34;color:#eceff4&#34;&gt;{&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&#x9;&lt;span style=&#34;color:#81a1c1&#34;&gt;char&lt;/span&gt; name&lt;span style=&#34;color:#eceff4&#34;&gt;[&lt;/span&gt;&lt;span style=&#34;color:#b48ead&#34;&gt;128&lt;/span&gt;&lt;span style=&#34;color:#eceff4&#34;&gt;];&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#eceff4&#34;&gt;}&lt;/span&gt;Person&lt;span style=&#34;color:#eceff4&#34;&gt;;&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;Person a&lt;span style=&#34;color:#eceff4&#34;&gt;;&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;h3 id=&#34;函数指针别名&#34;&gt;函数指针别名&lt;/h3&gt;&#xA;&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#d8dee9;background-color:#2e3440;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-cpp&#34; data-lang=&#34;cpp&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#81a1c1;font-weight:bold&#34;&gt;typedef&lt;/span&gt; &lt;span style=&#34;color:#81a1c1&#34;&gt;void&lt;/span&gt;&lt;span style=&#34;color:#81a1c1&#34;&gt;*&lt;/span&gt;&lt;span style=&#34;color:#eceff4&#34;&gt;(&lt;/span&gt;&lt;span style=&#34;color:#81a1c1&#34;&gt;*&lt;/span&gt;Fun&lt;span style=&#34;color:#eceff4&#34;&gt;)&lt;/span&gt; &#xA;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;h2 id=&#34;sizeof&#34;&gt;sizeof&lt;/h2&gt;&#xA;&lt;p&gt;sizeof 有两种。一种带括号的，另一种不带。&lt;/p&gt;&#xA;&lt;h3 id=&#34;sizeof-无括号&#34;&gt;sizeof 无括号&lt;/h3&gt;&#xA;&lt;p&gt;返回所给类型的字节数。后面只能跟类型名。&lt;/p&gt;&#xA;&lt;h3 id=&#34;sizeof-1&#34;&gt;sizeof()&lt;/h3&gt;&#xA;&lt;p&gt;返回括号中变量所占字节数。&lt;/p&gt;&#xA;&lt;p&gt;可以理解为在识别了这个变量的类型后，再使用无括号的 sizeof 返回这个类型占的字节数。&lt;/p&gt;&#xA;&lt;p&gt;注意：&lt;/p&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;指向数组首元素的指针传入时，只会返回 4。因为传入的是指针变量而不是数组变量（e.g. &lt;code&gt;int*&lt;/code&gt;  和 &lt;code&gt;int[5]&lt;/code&gt;）&lt;/li&gt;&#xA;&lt;/ul&gt;</description>
    </item>
    <item>
      <title>类型解释</title>
      <link>https://huoxj.github.io/posts/c&#43;&#43;%E6%8B%BE%E9%81%97/%E7%B1%BB%E5%9E%8B%E8%A7%A3%E9%87%8A/</link>
      <pubDate>Sun, 13 Oct 2024 00:00:00 +0000</pubDate>
      <guid>https://huoxj.github.io/posts/c&#43;&#43;%E6%8B%BE%E9%81%97/%E7%B1%BB%E5%9E%8B%E8%A7%A3%E9%87%8A/</guid>
      <description>&lt;h2 id=&#34;写在前面&#34;&gt;写在前面&lt;/h2&gt;&#xA;&lt;p&gt;写这部分是为了：&lt;/p&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;读懂复杂且恶心的类型声明，比如 &lt;code&gt;void (*signal(int, void (*fp)(int)))(int);&lt;/code&gt;&lt;/li&gt;&#xA;&lt;li&gt;考试&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;p&gt;记住要：&lt;/p&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;不写这种不符合规范，并且恶心他人的声明&lt;/li&gt;&#xA;&lt;li&gt;多用 &lt;code&gt;using&lt;/code&gt; 以及 STL 封装好的类型，适度用 &lt;code&gt;typedef&lt;/code&gt;&lt;/li&gt;&#xA;&lt;li&gt;对恶心的写法说 no&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;p&gt;推荐这个网站，能帮你把 C 类型声明翻译成自然语言：&lt;/p&gt;&#xA;&lt;p&gt;&lt;a href=&#34;https://cdecl.org/&#34;&gt;cdecl: C gibberish ↔ English&lt;/a&gt;&lt;/p&gt;&#xA;&lt;h2 id=&#34;变量声明说明符&#34;&gt;变量声明说明符&lt;/h2&gt;&#xA;&lt;p&gt;本文中，我们只关心如下几种说明符，因为这几种说明符是最困难的部分：&lt;/p&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;&lt;code&gt;*&lt;/code&gt;: 指针&lt;/li&gt;&#xA;&lt;li&gt;&lt;code&gt;[]&lt;/code&gt;: 数组&lt;/li&gt;&#xA;&lt;li&gt;&lt;code&gt;()&lt;/code&gt;: 括号（改变声明优先级）或者 函数指针&lt;/li&gt;&#xA;&lt;li&gt;&lt;code&gt;&amp;amp;&lt;/code&gt;: 引用&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;h2 id=&#34;优先级&#34;&gt;优先级&lt;/h2&gt;&#xA;&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#d8dee9;background-color:#2e3440;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-text&#34; data-lang=&#34;text&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;括号括住的部分 &amp;gt; 后缀说明符 &amp;gt; 前缀说明符&#xA;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;h2 id=&#34;读声明&#34;&gt;读声明&lt;/h2&gt;&#xA;&lt;p&gt;优先级规律总结出来其实就是 &lt;code&gt;右左法则&lt;/code&gt;，或者叫 &lt;code&gt;clockwise/spiral Rule&lt;/code&gt;。&lt;/p&gt;&#xA;&lt;p&gt;法则内容如下：&lt;/p&gt;&#xA;&lt;h3 id=&#34;从唯一的未定义的标识符开始&#34;&gt;从唯一的未定义的标识符开始&lt;/h3&gt;&#xA;&lt;p&gt;声明语句中，有且仅有一个之前没定义过的标识符。我们就从这个标识符开始。&lt;/p&gt;&#xA;&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#d8dee9;background-color:#2e3440;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-cpp&#34; data-lang=&#34;cpp&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#81a1c1&#34;&gt;int&lt;/span&gt; &lt;span style=&#34;color:#eceff4&#34;&gt;((&lt;/span&gt;&lt;span style=&#34;color:#81a1c1&#34;&gt;*&lt;/span&gt;fp&lt;span style=&#34;color:#eceff4&#34;&gt;)[&lt;/span&gt;MAXN&lt;span style=&#34;color:#eceff4&#34;&gt;])(&lt;/span&gt;&lt;span style=&#34;color:#81a1c1&#34;&gt;int&lt;/span&gt; x&lt;span style=&#34;color:#eceff4&#34;&gt;,&lt;/span&gt; &lt;span style=&#34;color:#81a1c1&#34;&gt;int&lt;/span&gt; y&lt;span style=&#34;color:#eceff4&#34;&gt;);&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;上例就是 &lt;code&gt;fp&lt;/code&gt;。&lt;/p&gt;&#xA;&lt;h3 id=&#34;先看右边的声明符再看左边&#34;&gt;先看右边的声明符，再看左边&lt;/h3&gt;&#xA;&lt;p&gt;因为后缀说明符优先级更高，所以先看右边。&lt;/p&gt;&#xA;&lt;h3 id=&#34;将看到的声明符转译为英文&#34;&gt;将看到的声明符转译为英文&lt;/h3&gt;&#xA;&lt;p&gt;看到了哪个声明符，就将如下列出的翻译模板加到我们当前的翻译栈中。&lt;/p&gt;&#xA;&lt;p&gt;指针 / 引用：a pointer / reference to&lt;/p&gt;&#xA;&lt;p&gt;数组：an array of&lt;/p&gt;</description>
    </item>
    <item>
      <title>STL-容器</title>
      <link>https://huoxj.github.io/posts/c&#43;&#43;%E6%8B%BE%E9%81%97/stl-%E5%AE%B9%E5%99%A8/</link>
      <pubDate>Sat, 12 Oct 2024 00:00:00 +0000</pubDate>
      <guid>https://huoxj.github.io/posts/c&#43;&#43;%E6%8B%BE%E9%81%97/stl-%E5%AE%B9%E5%99%A8/</guid>
      <description>&lt;h1 id=&#34;序列容器&#34;&gt;序列容器&lt;/h1&gt;&#xA;&lt;p&gt;序列容器实现能按顺序访问的数据结构。&lt;/p&gt;&#xA;&lt;p&gt;有如下容器：&lt;/p&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;&lt;code&gt;vector&lt;/code&gt;：动态数组&lt;/li&gt;&#xA;&lt;li&gt;&lt;code&gt;deque&lt;/code&gt;：双端队列&lt;/li&gt;&#xA;&lt;li&gt;&lt;code&gt;list&lt;/code&gt;：双向链表&lt;/li&gt;&#xA;&lt;li&gt;&lt;code&gt;array&lt;/code&gt;：C 风格的固定大小的数组 &lt;em&gt;C++11&lt;/em&gt;&lt;/li&gt;&#xA;&lt;li&gt;&lt;code&gt;forward_list&lt;/code&gt;：单向链表。性能比 list 略好，基本和 C 中的链表无异 C++11&lt;/li&gt;&#xA;&lt;li&gt;&lt;code&gt;inpalce_vector&lt;/code&gt;：可动态调整大小的固定容量原位连续数组 C++26&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;h2 id=&#34;一般操作&#34;&gt;一般操作&lt;/h2&gt;&#xA;&lt;h3 id=&#34;构造&#34;&gt;构造&lt;/h3&gt;&#xA;&lt;p&gt;省略返回类型以及一些无关紧要的参数类型。&lt;/p&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;&lt;code&gt;()&lt;/code&gt;：默认无参数构造&lt;/li&gt;&#xA;&lt;li&gt;&lt;code&gt;(&amp;amp;&amp;amp; other)&lt;/code&gt;：拷贝构造&lt;/li&gt;&#xA;&lt;li&gt;&lt;code&gt;(it1, it2)&lt;/code&gt;：从另一个 vector 的迭代器构造，得到子 vector&lt;/li&gt;&#xA;&lt;li&gt;&lt;code&gt;(count, T element)&lt;/code&gt;：含 count 个 element&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;h3 id=&#34;赋值&#34;&gt;赋值&lt;/h3&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;赋值号&lt;/li&gt;&#xA;&lt;li&gt;&lt;code&gt;assign&lt;/code&gt; 函数。和构造函数参数是一致的。&lt;/li&gt;&#xA;&lt;li&gt;&lt;code&gt;swap&lt;/code&gt; 交互两个容器。&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;h3 id=&#34;元素访问&#34;&gt;元素访问&lt;/h3&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;&lt;code&gt;operator[]&lt;/code&gt;。数组的访问方式。可以访问任意下标的元素。&lt;/li&gt;&#xA;&lt;li&gt;&lt;code&gt;at(index)&lt;/code&gt;。访问下标 index 处的元素。&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;h3 id=&#34;元素操作&#34;&gt;元素操作&lt;/h3&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;&lt;code&gt;push_front(T e)&lt;/code&gt; &lt;code&gt;push_back(T e)&lt;/code&gt;：头尾部加入元素&lt;/li&gt;&#xA;&lt;li&gt;&lt;code&gt;pop_back()&lt;/code&gt; &lt;code&gt;pop_front()&lt;/code&gt;：尾部删除&lt;/li&gt;&#xA;&lt;li&gt;&lt;code&gt;insert(it, T e) / insert(it, count, T e)&lt;/code&gt;：it 处插入一个或多个 e&lt;/li&gt;&#xA;&lt;li&gt;&lt;code&gt;erase(it) / erase(it1, it2)&lt;/code&gt;：it 处删除 / [it, it2) 处删除&lt;/li&gt;&#xA;&lt;li&gt;&lt;code&gt;clear()&lt;/code&gt;：清空&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;blockquote&gt;&#xA;&lt;p&gt;push_back V.S. emplace_back&#xA;tl dr. 如果传入的是构造参数，后者直接在vector里构造，效率比前者更高。&#xA;如果传入的是一个已经构造好的对象，二者是一样的。&#xA;如果感兴趣，网上有很多详细的解析。&lt;/p&gt;</description>
    </item>
    <item>
      <title>String</title>
      <link>https://huoxj.github.io/posts/c&#43;&#43;%E6%8B%BE%E9%81%97/string/</link>
      <pubDate>Sat, 12 Oct 2024 00:00:00 +0000</pubDate>
      <guid>https://huoxj.github.io/posts/c&#43;&#43;%E6%8B%BE%E9%81%97/string/</guid>
      <description>&lt;h2 id=&#34;前言&#34;&gt;前言&lt;/h2&gt;&#xA;&lt;p&gt;在以前打竞赛的时候，基本都是用字符数组配合&lt;code&gt;string.h&lt;/code&gt;里的函数去处理字符串。现在开始系统地接触C++，所以来记录一下&lt;code&gt;string&lt;/code&gt;类的知识。&lt;/p&gt;&#xA;&lt;h2 id=&#34;简介&#34;&gt;简介&lt;/h2&gt;&#xA;&lt;p&gt;&lt;code&gt;string&lt;/code&gt; 是 C++ 风格的字符串类，也是一种STL容器(根据CppReference说法，string是唯一的&lt;code&gt;伪容器&lt;/code&gt;)。相比于 C 风格的字符串 &lt;code&gt;char[]&lt;/code&gt; ，string 支持自动内存管理，并且拥有很多方便的函数。&lt;/p&gt;&#xA;&lt;p&gt;头文件：&lt;code&gt;string&lt;/code&gt;&lt;/p&gt;&#xA;&lt;h2 id=&#34;构造&#34;&gt;构造&lt;/h2&gt;&#xA;&lt;h3 id=&#34;一般构造&#34;&gt;一般构造&lt;/h3&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;&lt;code&gt;std::string(const char* s)&lt;/code&gt;&lt;/li&gt;&#xA;&lt;li&gt;&lt;code&gt;std::string(const string&amp;amp; s)&lt;/code&gt;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;p&gt;传入一个 C 字符串或者字符串类，变成 C++ string类。没什么好说的。&lt;/p&gt;&#xA;&lt;h3 id=&#34;特殊构造&#34;&gt;特殊构造&lt;/h3&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;直接赋值&lt;code&gt;string str = &amp;quot;...&amp;quot;&lt;/code&gt;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;p&gt;直接将 C 字符串赋值或者类型转换。&lt;/p&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;&lt;code&gt;std::string(size_t n, char c)&lt;/code&gt;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;p&gt;构造一个 n 个 c 的字符串。也就是将 c 重复 n 次。&lt;/p&gt;&#xA;&lt;h2 id=&#34;属性&#34;&gt;属性&lt;/h2&gt;&#xA;&lt;h3 id=&#34;长度&#34;&gt;长度&lt;/h3&gt;&#xA;&lt;p&gt;优先 &lt;code&gt;string.length()&lt;/code&gt;。&lt;/p&gt;&#xA;&lt;p&gt;其他诸如 &lt;code&gt;string.size()&lt;/code&gt; 和 &lt;code&gt;strlen(const &amp;amp;string)&lt;/code&gt;。&lt;/p&gt;&#xA;&lt;h3 id=&#34;是否空&#34;&gt;是否空&lt;/h3&gt;&#xA;&lt;p&gt;和其他 STL 容器一样，判断 string 是否为空：&lt;/p&gt;&#xA;&lt;p&gt;&lt;code&gt;string.empty()&lt;/code&gt;&lt;/p&gt;&#xA;&lt;h2 id=&#34;访问与遍历&#34;&gt;访问与遍历&lt;/h2&gt;&#xA;&lt;h3 id=&#34;索引&#34;&gt;索引&lt;/h3&gt;&#xA;&lt;p&gt;&lt;code&gt;str[i]&lt;/code&gt; 直接得到对应字符。&lt;/p&gt;&#xA;&lt;h3 id=&#34;迭代器&#34;&gt;迭代器&lt;/h3&gt;&#xA;&lt;p&gt;&lt;code&gt;string.begin()&lt;/code&gt;, &lt;code&gt;string.end()&lt;/code&gt; 得到头尾 iterator。&lt;/p&gt;</description>
    </item>
    <item>
      <title>粗浅理解指针、引用与数组</title>
      <link>https://huoxj.github.io/posts/c&#43;&#43;%E6%8B%BE%E9%81%97/%E7%B2%97%E6%B5%85%E7%90%86%E8%A7%A3%E6%8C%87%E9%92%88%E5%BC%95%E7%94%A8%E4%B8%8E%E6%95%B0%E7%BB%84/</link>
      <pubDate>Sat, 12 Oct 2024 00:00:00 +0000</pubDate>
      <guid>https://huoxj.github.io/posts/c&#43;&#43;%E6%8B%BE%E9%81%97/%E7%B2%97%E6%B5%85%E7%90%86%E8%A7%A3%E6%8C%87%E9%92%88%E5%BC%95%E7%94%A8%E4%B8%8E%E6%95%B0%E7%BB%84/</guid>
      <description>&lt;h2 id=&#34;引用&#34;&gt;引用&lt;/h2&gt;&#xA;&lt;h3 id=&#34;引用和指针&#34;&gt;引用和指针&lt;/h3&gt;&#xA;&lt;p&gt;以我的粗浅且可能有很大错误的理解，引用就是有着一些限制、有一些封装的指针，这些限制在编译器层面解决，底层就是以指针形式实现。&lt;/p&gt;&#xA;&lt;p&gt;限制在如下几点：&lt;/p&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;引用创建时需要初始化&lt;/li&gt;&#xA;&lt;li&gt;引用在初始化后无法再改变指向&#xA;&lt;ul&gt;&#xA;&lt;li&gt;所以不存在 &lt;code&gt;const int&amp;amp; &lt;/code&gt;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;p&gt;引用带来的方便：&lt;/p&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;引用的元素可以直接按名访问，不需要解指针&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;h2 id=&#34;指针&#34;&gt;指针&lt;/h2&gt;&#xA;&lt;p&gt;指针是指向一块内存首地址的变量。指针的类型提供了对于这个首地址该如何解释的信息。&lt;/p&gt;&#xA;&lt;h3 id=&#34;智能指针&#34;&gt;智能指针&lt;/h3&gt;&#xA;&lt;blockquote&gt;&#xA;&lt;p&gt;TODO：目前是从 YDJSIR 笔记中复制粘贴的&#xA;智能指针内容繁杂，需要开一篇专门文章&lt;/p&gt;&#xA;&lt;/blockquote&gt;&#xA;&lt;ol&gt;&#xA;&lt;li&gt;&#xA;&lt;p&gt;通过将一些需要的信息进行封装的方法，来保证不管出现什么异常，在退出相应操作部分时，自动调用对象的析构函数来保证不会出现内存泄漏的问题。&lt;/p&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;&#xA;&lt;p&gt;同样的还有句柄类(C++ 异常中有)&lt;/p&gt;&#xA;&lt;/li&gt;&#xA;&lt;/ol&gt;&#xA;&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#d8dee9;background-color:#2e3440;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-c++&#34; data-lang=&#34;c++&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#81a1c1;font-weight:bold&#34;&gt;template&lt;/span&gt; &lt;span style=&#34;color:#81a1c1&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span style=&#34;color:#81a1c1;font-weight:bold&#34;&gt;class&lt;/span&gt; &lt;span style=&#34;color:#8fbcbb&#34;&gt;T&lt;/span&gt;&lt;span style=&#34;color:#81a1c1&#34;&gt;&amp;gt;&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#81a1c1;font-weight:bold&#34;&gt;class&lt;/span&gt; &lt;span style=&#34;color:#8fbcbb&#34;&gt;auto_ptr&lt;/span&gt;&lt;span style=&#34;color:#eceff4&#34;&gt;{&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#81a1c1;font-weight:bold&#34;&gt;public&lt;/span&gt;&lt;span style=&#34;color:#81a1c1&#34;&gt;:&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        auto_ptr&lt;span style=&#34;color:#eceff4&#34;&gt;(&lt;/span&gt;T &lt;span style=&#34;color:#81a1c1&#34;&gt;*&lt;/span&gt;p&lt;span style=&#34;color:#81a1c1&#34;&gt;=&lt;/span&gt;&lt;span style=&#34;color:#b48ead&#34;&gt;0&lt;/span&gt;&lt;span style=&#34;color:#eceff4&#34;&gt;)&lt;/span&gt;&lt;span style=&#34;color:#81a1c1&#34;&gt;:&lt;/span&gt;ptr&lt;span style=&#34;color:#eceff4&#34;&gt;(&lt;/span&gt;p&lt;span style=&#34;color:#eceff4&#34;&gt;)&lt;/span&gt; &lt;span style=&#34;color:#eceff4&#34;&gt;{}&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        &lt;span style=&#34;color:#81a1c1&#34;&gt;~&lt;/span&gt;auto_ptr&lt;span style=&#34;color:#eceff4&#34;&gt;()&lt;/span&gt; &lt;span style=&#34;color:#eceff4&#34;&gt;{&lt;/span&gt; &lt;span style=&#34;color:#81a1c1;font-weight:bold&#34;&gt;delete&lt;/span&gt; ptr&lt;span style=&#34;color:#eceff4&#34;&gt;;&lt;/span&gt; &lt;span style=&#34;color:#eceff4&#34;&gt;}&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        T&lt;span style=&#34;color:#81a1c1&#34;&gt;*&lt;/span&gt; &lt;span style=&#34;color:#81a1c1;font-weight:bold&#34;&gt;operator&lt;/span&gt;&lt;span style=&#34;color:#81a1c1&#34;&gt;-&amp;gt;&lt;/span&gt;&lt;span style=&#34;color:#eceff4&#34;&gt;()&lt;/span&gt;  &lt;span style=&#34;color:#81a1c1;font-weight:bold&#34;&gt;const&lt;/span&gt; &lt;span style=&#34;color:#eceff4&#34;&gt;{&lt;/span&gt; &lt;span style=&#34;color:#81a1c1;font-weight:bold&#34;&gt;return&lt;/span&gt; ptr&lt;span style=&#34;color:#eceff4&#34;&gt;;}&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&#x9;    T&lt;span style=&#34;color:#81a1c1&#34;&gt;&amp;amp;&lt;/span&gt; &lt;span style=&#34;color:#81a1c1;font-weight:bold&#34;&gt;operator&lt;/span&gt; &lt;span style=&#34;color:#81a1c1&#34;&gt;*&lt;/span&gt;&lt;span style=&#34;color:#eceff4&#34;&gt;()&lt;/span&gt;  &lt;span style=&#34;color:#81a1c1;font-weight:bold&#34;&gt;const&lt;/span&gt; &lt;span style=&#34;color:#eceff4&#34;&gt;{&lt;/span&gt; &lt;span style=&#34;color:#81a1c1;font-weight:bold&#34;&gt;return&lt;/span&gt; &lt;span style=&#34;color:#81a1c1&#34;&gt;*&lt;/span&gt;ptr&lt;span style=&#34;color:#eceff4&#34;&gt;;&lt;/span&gt; &lt;span style=&#34;color:#eceff4&#34;&gt;}&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#81a1c1;font-weight:bold&#34;&gt;private&lt;/span&gt;&lt;span style=&#34;color:#81a1c1&#34;&gt;:&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        T&lt;span style=&#34;color:#81a1c1&#34;&gt;*&lt;/span&gt;  ptr&lt;span style=&#34;color:#eceff4&#34;&gt;;&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#eceff4&#34;&gt;};&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#616e87;font-style:italic&#34;&gt;//结合智慧指针使用&#xA;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#616e87;font-style:italic&#34;&gt;&lt;/span&gt;&lt;span style=&#34;color:#81a1c1&#34;&gt;void&lt;/span&gt; &lt;span style=&#34;color:#88c0d0&#34;&gt;processAdoptions&lt;/span&gt;&lt;span style=&#34;color:#eceff4&#34;&gt;(&lt;/span&gt;istream&lt;span style=&#34;color:#81a1c1&#34;&gt;&amp;amp;&lt;/span&gt; dataSource&lt;span style=&#34;color:#eceff4&#34;&gt;){&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#81a1c1;font-weight:bold&#34;&gt;while&lt;/span&gt; &lt;span style=&#34;color:#eceff4&#34;&gt;(&lt;/span&gt;dataSource&lt;span style=&#34;color:#eceff4&#34;&gt;){&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        auto_ptr&lt;span style=&#34;color:#81a1c1&#34;&gt;&amp;lt;&lt;/span&gt;ALA&lt;span style=&#34;color:#81a1c1&#34;&gt;&amp;gt;&lt;/span&gt; pa&lt;span style=&#34;color:#eceff4&#34;&gt;(&lt;/span&gt;readALA&lt;span style=&#34;color:#eceff4&#34;&gt;(&lt;/span&gt;dataSource&lt;span style=&#34;color:#eceff4&#34;&gt;));&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        pa&lt;span style=&#34;color:#81a1c1&#34;&gt;-&amp;gt;&lt;/span&gt;processAdoption&lt;span style=&#34;color:#eceff4&#34;&gt;();&lt;/span&gt;&lt;span style=&#34;color:#616e87;font-style:italic&#34;&gt;//只要对象结束，就会自动delete&#xA;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#616e87;font-style:italic&#34;&gt;&lt;/span&gt;    &lt;span style=&#34;color:#eceff4&#34;&gt;}&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#eceff4&#34;&gt;}&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;h3 id=&#34;函数指针&#34;&gt;函数指针&lt;/h3&gt;&#xA;&lt;p&gt;函数指针能够像传递参数一样传递函数。并且也便于我们实现多态。&lt;/p&gt;&#xA;&lt;p&gt;对于函数指针的简单使用，我还是持开放态度的。但是众所周知，函数指针是能够复杂到令人呕吐的程度的。这种情况还是尽可能不要用函数指针了，要不就用 typedef 定义得好看点。不要恶心自己的同时还恶心他人……&lt;/p&gt;&#xA;&lt;h4 id=&#34;定义函数指针&#34;&gt;定义函数指针&lt;/h4&gt;&#xA;&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#d8dee9;background-color:#2e3440;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-cpp&#34; data-lang=&#34;cpp&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#81a1c1&#34;&gt;int&lt;/span&gt; &lt;span style=&#34;color:#eceff4&#34;&gt;(&lt;/span&gt;&lt;span style=&#34;color:#81a1c1&#34;&gt;*&lt;/span&gt;fp&lt;span style=&#34;color:#eceff4&#34;&gt;)(&lt;/span&gt;&lt;span style=&#34;color:#81a1c1&#34;&gt;int&lt;/span&gt;&lt;span style=&#34;color:#eceff4&#34;&gt;);&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;&lt;code&gt;fp&lt;/code&gt; 就可以存放返回值为 int，参数为一个 int 的函数了。&lt;/p&gt;&#xA;&lt;p&gt;可以这样理解：&lt;code&gt;fp&lt;/code&gt; 是标识符，&lt;code&gt;*fp&lt;/code&gt; 中的 &lt;code&gt;*&lt;/code&gt; 在说这个变量是个指针，最前面的 &lt;code&gt;int&lt;/code&gt; 和后面括号中的 &lt;code&gt;(int)&lt;/code&gt; 说明了这是函数指针，并指明了参数和返回值。&lt;/p&gt;</description>
    </item>
  </channel>
</rss>
