<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>软件测试 on Runz&#39;s Blog</title>
    <link>https://huoxj.github.io/series/%E8%BD%AF%E4%BB%B6%E6%B5%8B%E8%AF%95/</link>
    <description>Recent content in 软件测试 on Runz&#39;s Blog</description>
    <generator>Hugo</generator>
    <language>cn</language>
    <lastBuildDate>Fri, 03 Jan 2025 00:00:00 +0000</lastBuildDate>
    <atom:link href="https://huoxj.github.io/series/%E8%BD%AF%E4%BB%B6%E6%B5%8B%E8%AF%95/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>01-软件测试导览</title>
      <link>https://huoxj.github.io/posts/%E8%BD%AF%E4%BB%B6%E6%B5%8B%E8%AF%95/01-%E8%BD%AF%E4%BB%B6%E6%B5%8B%E8%AF%95%E5%AF%BC%E8%A7%88/</link>
      <pubDate>Fri, 03 Jan 2025 00:00:00 +0000</pubDate>
      <guid>https://huoxj.github.io/posts/%E8%BD%AF%E4%BB%B6%E6%B5%8B%E8%AF%95/01-%E8%BD%AF%E4%BB%B6%E6%B5%8B%E8%AF%95%E5%AF%BC%E8%A7%88/</guid>
      <description>&lt;h2 id=&#34;课程总览&#34;&gt;课程总览&lt;/h2&gt;&#xA;&lt;p&gt;三个部分，&lt;code&gt;经典测试&lt;/code&gt;、&lt;code&gt;移动应用测试&lt;/code&gt;和&lt;code&gt;AI测试&lt;/code&gt;&lt;/p&gt;&#xA;&lt;h2 id=&#34;测试的基本问题&#34;&gt;测试的基本问题&lt;/h2&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;测试设计问题：要问什么问题？&lt;/li&gt;&#xA;&lt;li&gt;测试预言问题：要怎么回答问题？&lt;/li&gt;&#xA;&lt;li&gt;测试终止问题：什么时候终止？&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;h2 id=&#34;pie-模型&#34;&gt;PIE 模型&lt;/h2&gt;&#xA;&lt;p&gt;PIE 模型解释了软件中的 Fault 如何导致 Failure。&lt;/p&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;Execution: The location or locations in the program that contain the fault must be &lt;strong&gt;reached&lt;/strong&gt;&lt;/li&gt;&#xA;&lt;li&gt;Infection : The &lt;strong&gt;state&lt;/strong&gt; of the program must be incorrect&lt;/li&gt;&#xA;&lt;li&gt;Propagation : The infected state must &lt;strong&gt;propagate&lt;/strong&gt; to cause some output of the program to be incorrect&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;h2 id=&#34;测试的局限性&#34;&gt;测试的局限性&lt;/h2&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;输入空间庞大。无法穷举所有输入。&lt;/li&gt;&#xA;&lt;li&gt;实现逻辑复杂。无法想到所有场景。&lt;/li&gt;&#xA;&lt;li&gt;测试预言未知。无法判定测试的预期输出&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;h2 id=&#34;随机测试-大数定律&#34;&gt;⭐随机测试-大数定律&lt;/h2&gt;&#xA;&lt;p&gt;测试&lt;strong&gt;执行次数够多&lt;/strong&gt;，并且测试&lt;strong&gt;数据随机生成&lt;/strong&gt;，总有概率低的&lt;strong&gt;偶然现象发生&lt;/strong&gt;。&lt;/p&gt;</description>
    </item>
    <item>
      <title>02-变异测试</title>
      <link>https://huoxj.github.io/posts/%E8%BD%AF%E4%BB%B6%E6%B5%8B%E8%AF%95/02-%E5%8F%98%E5%BC%82%E6%B5%8B%E8%AF%95/</link>
      <pubDate>Fri, 03 Jan 2025 00:00:00 +0000</pubDate>
      <guid>https://huoxj.github.io/posts/%E8%BD%AF%E4%BB%B6%E6%B5%8B%E8%AF%95/02-%E5%8F%98%E5%BC%82%E6%B5%8B%E8%AF%95/</guid>
      <description>&lt;p&gt;一言以蔽之，变异测试研究如何编写能够&lt;strong&gt;暴露缺陷&lt;/strong&gt;的测试用例，以及如何提升测试&lt;strong&gt;可信度&lt;/strong&gt;。&lt;/p&gt;&#xA;&lt;p&gt;将这些测试用例应用到待测程序中，就很有可能会发现待测程序的缺陷。&lt;/p&gt;&#xA;&lt;h2 id=&#34;概念&#34;&gt;概念&lt;/h2&gt;&#xA;&lt;h3 id=&#34;变异体&#34;&gt;变异体&lt;/h3&gt;&#xA;&lt;p&gt;基于一定的语法（Syntax）变换规则，通过对源程序进行程序变换（Program Transformation）得到的一系列变体。&lt;/p&gt;&#xA;&lt;p&gt;源程序不包含 Defect，变异体包含，那这个 Defect 叫&lt;code&gt;人工缺陷&lt;/code&gt;&lt;/p&gt;&#xA;&lt;h3 id=&#34;变异算子&#34;&gt;变异算子&lt;/h3&gt;&#xA;&lt;p&gt;上面所说的变换规则就是变异算子。&lt;/p&gt;&#xA;&lt;h3 id=&#34;变异存活杀死&#34;&gt;变异存活、杀死&lt;/h3&gt;&#xA;&lt;p&gt;如果一个变异体无法通过测试用例，这个变异体就被这个测试用例杀死了。&lt;/p&gt;&#xA;&lt;h3 id=&#34;变异得分&#34;&gt;变异得分&lt;/h3&gt;&#xA;&lt;p&gt;变异测试对测试套件错误检测能力的量化。&lt;/p&gt;&#xA;&lt;p&gt;是对于一个测试用例而言的。score 是&lt;strong&gt;所有变异体&lt;/strong&gt;在这个测试用例上&lt;strong&gt;运行失败&lt;/strong&gt;的比例。&lt;/p&gt;&#xA;&lt;p&gt;下标 k 代表变体 killed，被检测到了；s 代表 survived，没有被检测到。&lt;/p&gt;&#xA;&lt;p&gt;$$&#xA;score=\frac{mut_k}{mut_s+mut_k}\times100%&#xA;$$&lt;/p&gt;&#xA;&lt;h3 id=&#34;假设&#34;&gt;假设&lt;/h3&gt;&#xA;&lt;p&gt;基于这些假设，我们可以认为变异测试有效：&lt;/p&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;缺陷是&lt;strong&gt;简单的、可模拟&lt;/strong&gt;的&#xA;&lt;ul&gt;&#xA;&lt;li&gt;变异体模拟这些缺陷&lt;/li&gt;&#xA;&lt;li&gt;老练程序员假设：一个老练程序员编写的错误程序与正确程序相差不大&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;缺陷可&lt;strong&gt;叠加&lt;/strong&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;复杂变异体可以通过耦合简单变异体得到&lt;/li&gt;&#xA;&lt;li&gt;能够杀死简单变异体的测试用例可以杀死复杂变异体&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;缺陷检测&lt;strong&gt;有效性&lt;/strong&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;能检测人工缺陷的样例，也能检测真实程序的缺陷&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;h2 id=&#34;步骤&#34;&gt;步骤&lt;/h2&gt;&#xA;&lt;h3 id=&#34;1-变异体筛选&#34;&gt;1. 变异体筛选&lt;/h3&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;对变异体进行筛选&lt;/li&gt;&#xA;&lt;li&gt;通过变异算子筛选&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;h3 id=&#34;2-变异体生成&#34;&gt;2. 变异体生成&lt;/h3&gt;&#xA;&lt;p&gt;将选中的变异体通过算子实例化。&lt;/p&gt;&#xA;&lt;h3 id=&#34;3-变异体优化&#34;&gt;3. 变异体优化&lt;/h3&gt;&#xA;&lt;p&gt;去除等价和无效变异体。&lt;/p&gt;&#xA;&lt;p&gt;目的：减小开销、提高变异得分可信度&lt;/p&gt;&#xA;&lt;p&gt;形式：静态分析&lt;/p&gt;&#xA;&lt;h3 id=&#34;4-变异体执行&#34;&gt;4. 变异体执行&lt;/h3&gt;&#xA;&lt;p&gt;最昂贵的阶段。&lt;/p&gt;&#xA;&lt;h3 id=&#34;5-变异得分计算&#34;&gt;5. 变异得分计算&lt;/h3&gt;&#xA;&lt;p&gt;计算被杀死的变异体数量，进而得到变异得分、量化测试的充分性。&lt;/p&gt;&#xA;&lt;h2 id=&#34;应用与研究&#34;&gt;应用与研究&lt;/h2&gt;&#xA;&lt;h3 id=&#34;传统方向&#34;&gt;传统方向&lt;/h3&gt;&#xA;&lt;p&gt;测试优化、测试生成、调试辅助&lt;/p&gt;&#xA;&lt;h3 id=&#34;非传统&#34;&gt;非传统&lt;/h3&gt;&#xA;&lt;p&gt;非确定系统、行为建模、算子定义&lt;/p&gt;&#xA;&lt;h2 id=&#34;总结&#34;&gt;总结&lt;/h2&gt;&#xA;&lt;p&gt;这张图给个好评！&lt;/p&gt;&#xA;&lt;p&gt;&lt;img src=&#34;https://runzblog.oss-cn-hangzhou.aliyuncs.com/postimg/202501031720816.png&#34; alt=&#34;&#34;&gt;&lt;/p&gt;</description>
    </item>
    <item>
      <title>03-模糊测试</title>
      <link>https://huoxj.github.io/posts/%E8%BD%AF%E4%BB%B6%E6%B5%8B%E8%AF%95/03-%E6%A8%A1%E7%B3%8A%E6%B5%8B%E8%AF%95/</link>
      <pubDate>Fri, 03 Jan 2025 00:00:00 +0000</pubDate>
      <guid>https://huoxj.github.io/posts/%E8%BD%AF%E4%BB%B6%E6%B5%8B%E8%AF%95/03-%E6%A8%A1%E7%B3%8A%E6%B5%8B%E8%AF%95/</guid>
      <description></description>
    </item>
    <item>
      <title>04-测试用例优先级</title>
      <link>https://huoxj.github.io/posts/%E8%BD%AF%E4%BB%B6%E6%B5%8B%E8%AF%95/04-%E6%B5%8B%E8%AF%95%E7%94%A8%E4%BE%8B%E4%BC%98%E5%85%88%E7%BA%A7/</link>
      <pubDate>Fri, 03 Jan 2025 00:00:00 +0000</pubDate>
      <guid>https://huoxj.github.io/posts/%E8%BD%AF%E4%BB%B6%E6%B5%8B%E8%AF%95/04-%E6%B5%8B%E8%AF%95%E7%94%A8%E4%BE%8B%E4%BC%98%E5%85%88%E7%BA%A7/</guid>
      <description>&lt;h2 id=&#34;回归测试&#34;&gt;回归测试&lt;/h2&gt;&#xA;&lt;p&gt;测试用例优先级是解决回归测试的一些问题的。&lt;/p&gt;&#xA;&lt;p&gt;&lt;strong&gt;回归测试&lt;/strong&gt;：版本迭代之后，重新运行之前的测试用例&lt;/p&gt;&#xA;&lt;p&gt;但是，之前的测试用例：&lt;/p&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;用例庞大。太多了&lt;/li&gt;&#xA;&lt;li&gt;用例冗余&lt;/li&gt;&#xA;&lt;li&gt;用例失效。更新之后某些接口发生改变，原来的测试没法测&lt;/li&gt;&#xA;&lt;li&gt;用例缺失。新的模块需要新用例&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;h2 id=&#34;优化回归测试&#34;&gt;优化回归测试&lt;/h2&gt;&#xA;&lt;p&gt;要优化回归测试，就要优化测试用例集合。有如下方法&lt;/p&gt;&#xA;&lt;ol&gt;&#xA;&lt;li&gt;修复&lt;/li&gt;&#xA;&lt;li&gt;选择⭐&lt;/li&gt;&#xA;&lt;li&gt;扩充&lt;/li&gt;&#xA;&lt;li&gt;缩减&lt;/li&gt;&#xA;&lt;li&gt;优先级⭐&lt;/li&gt;&#xA;&lt;/ol&gt;&#xA;&lt;h2 id=&#34;测试用例优先级-tcp&#34;&gt;测试用例优先级 TCP&lt;/h2&gt;&#xA;&lt;p&gt;依照某种策略，给测试用例赋予&lt;strong&gt;优先级&lt;/strong&gt;。优先级高的用例先执行。&lt;/p&gt;&#xA;&lt;p&gt;即给定一堆测试用例，我们要确定一个用例序列，然后按顺序执行这些测试用例。&lt;/p&gt;&#xA;&lt;p&gt;好处：提高测试用例集的故障检测率&lt;/p&gt;&#xA;&lt;h3 id=&#34;流程&#34;&gt;流程⭐&lt;/h3&gt;&#xA;&lt;ol&gt;&#xA;&lt;li&gt;特征提取。对特使用例进行特征表示&#xA;&lt;ul&gt;&#xA;&lt;li&gt;代码覆盖：语句、分支、函数&lt;/li&gt;&#xA;&lt;li&gt;基于文本特征&lt;/li&gt;&#xA;&lt;li&gt;基于缺陷特征&lt;/li&gt;&#xA;&lt;li&gt;基于模型特征&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;基于 TCP 策略排序&#xA;&lt;ul&gt;&#xA;&lt;li&gt;贪心&lt;/li&gt;&#xA;&lt;li&gt;相似性&lt;/li&gt;&#xA;&lt;li&gt;搜索&lt;/li&gt;&#xA;&lt;li&gt;机器学习&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;评估准则&#xA;&lt;ul&gt;&#xA;&lt;li&gt;错误检测率&lt;/li&gt;&#xA;&lt;li&gt;时间开销&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;/ol&gt;&#xA;&lt;h3 id=&#34;类型&#34;&gt;类型&lt;/h3&gt;&#xA;&lt;p&gt;通用测试用例优先级：版本越新，用例优先级越高&#xA;特定于版本的测试用例优先级：根据不同版本的特性分配优先级。爱怎么分怎么分。&lt;/p&gt;&#xA;&lt;h3 id=&#34;优先级策略&#34;&gt;⭐优先级策略&lt;/h3&gt;&#xA;&lt;h4 id=&#34;基于贪心的-tcp&#34;&gt;基于贪心的 TCP&lt;/h4&gt;&#xA;&lt;blockquote&gt;&#xA;&lt;p&gt;基本是必考吧&lt;/p&gt;&#xA;&lt;/blockquote&gt;&#xA;&lt;p&gt;贪心的对象一般来说是测试用例代码单元&lt;strong&gt;覆盖率&lt;/strong&gt;。至于代码单元，有时候是语句，有时候是分支。&lt;/p&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;全局贪心：每一轮都选覆盖最多代码单元的测试用例&lt;/li&gt;&#xA;&lt;li&gt;增量贪心：每一轮选覆盖了最多的&lt;strong&gt;当前还未覆盖的&lt;/strong&gt;代码单元的测试用例&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;p&gt;每一轮中，覆盖率相同的用例，随机选择。&lt;/p&gt;&#xA;&lt;p&gt;&lt;img src=&#34;https://runzblog.oss-cn-hangzhou.aliyuncs.com/postimg/202501031609361.png&#34; alt=&#34;&#34;&gt;&lt;/p&gt;&#xA;&lt;h4 id=&#34;基于相似性的-tcp&#34;&gt;基于相似性的 TCP&lt;/h4&gt;&#xA;&lt;blockquote&gt;&#xA;&lt;p&gt;每轮优先与已选择测试用例集差异性最大的测试用例。让测试用例均匀地分布在输入域中。&lt;/p&gt;&#xA;&lt;/blockquote&gt;&#xA;&lt;p&gt;定义两个用例 $t_1, t_2$ 间的距离：&lt;/p&gt;&#xA;&lt;p&gt;$$&#xA;Jaccard(t_1,t_2)=1-\frac{|U(t_1)\cap U(t_2)|}{|U(t_1)\cup U(t_2)|}&#xA;$$&lt;/p&gt;&#xA;&lt;p&gt;就是两个用例覆盖代码的&lt;strong&gt;交并比&lt;/strong&gt;。&lt;/p&gt;&#xA;&lt;p&gt;而一个用例到用例集的距离，分别使用最大距离、最小距离和平均距离&lt;/p&gt;&#xA;&lt;h4 id=&#34;基于搜索的-tcp&#34;&gt;基于搜索的 TCP&lt;/h4&gt;&#xA;&lt;blockquote&gt;&#xA;&lt;p&gt;探索用例优先级排序组合的状态空间，以此找到检测错误更快的用例序列。&lt;/p&gt;&#xA;&lt;/blockquote&gt;&#xA;&lt;p&gt;这个方法使用了&lt;strong&gt;遗传&lt;/strong&gt;的思想。&lt;/p&gt;&#xA;&lt;ol&gt;&#xA;&lt;li&gt;种群构造。每一个个体是一个测试用例序列，比如我们随机生成两个个体：&lt;/li&gt;&#xA;&lt;/ol&gt;&#xA;&lt;p&gt;表中的 1 ~ 6 是测试用例在个体中的顺序编号。&lt;/p&gt;</description>
    </item>
    <item>
      <title>05-测试预言问题</title>
      <link>https://huoxj.github.io/posts/%E8%BD%AF%E4%BB%B6%E6%B5%8B%E8%AF%95/05-%E6%B5%8B%E8%AF%95%E9%A2%84%E8%A8%80%E9%97%AE%E9%A2%98/</link>
      <pubDate>Fri, 03 Jan 2025 00:00:00 +0000</pubDate>
      <guid>https://huoxj.github.io/posts/%E8%BD%AF%E4%BB%B6%E6%B5%8B%E8%AF%95/05-%E6%B5%8B%E8%AF%95%E9%A2%84%E8%A8%80%E9%97%AE%E9%A2%98/</guid>
      <description>&lt;p&gt;测试预言，是一个描述输出与预期是否相符的概念。&lt;/p&gt;&#xA;&lt;p&gt;预言有啥问题了？&lt;strong&gt;复杂的预言难以构建，容易构建的预言效果差&lt;/strong&gt;。&lt;/p&gt;&#xA;&lt;p&gt;解决方案，有一种叫使用不完全/有偏测试预言。也看不懂什么意思，反正就是来引出下面的蜕变测试和差分测试的。&lt;/p&gt;&#xA;&lt;h2 id=&#34;蜕变测试&#34;&gt;蜕变测试&lt;/h2&gt;&#xA;&lt;h3 id=&#34;动机&#34;&gt;动机&lt;/h3&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;可靠测试集问题（测试的生成与扩增）&lt;/li&gt;&#xA;&lt;li&gt;预言问题 （正确性验证）&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;h3 id=&#34;假设&#34;&gt;假设&lt;/h3&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;不能通过成功测试用例排除程序存在缺陷的可能&lt;/li&gt;&#xA;&lt;li&gt;利用多个相关的成功测试用例所展现出的测试输入和预期输出之间的关系来协助后续测试&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;h3 id=&#34;本质&#34;&gt;本质&lt;/h3&gt;&#xA;&lt;p&gt;充分利用成功测试用例。对成功测试用例表现出的&lt;strong&gt;必要属性&lt;/strong&gt;进行复用。&lt;/p&gt;&#xA;&lt;h3 id=&#34;要素&#34;&gt;要素&lt;/h3&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;蜕变关系（MR, Metamorphic Relation）：一组待测算法/功能的必要属性，蜕变测试的核心&lt;/li&gt;&#xA;&lt;li&gt;蜕变集合（Metamorphic Group）：由表达了蜕变关系的一组测试输入组成的集合&lt;/li&gt;&#xA;&lt;li&gt;蜕变测试过程：应用蜕变关系和蜕变集合进行测试的一般流程&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;h2 id=&#34;差分测试&#34;&gt;差分测试&lt;/h2&gt;&#xA;&lt;h3 id=&#34;定义&#34;&gt;定义&lt;/h3&gt;&#xA;&lt;p&gt;利用相似/竞品软件系统进行测试&lt;/p&gt;&#xA;&lt;p&gt;通过向一系列&lt;strong&gt;类似&lt;/strong&gt;的应用程序 （或同一应用程序的不同实现）提供&lt;strong&gt;相同的输入&lt;/strong&gt;，根据这些相似程序执行结果&lt;strong&gt;是否存在差异&lt;/strong&gt;来判定是否&lt;strong&gt;检测到缺陷&lt;/strong&gt;。&lt;/p&gt;</description>
    </item>
    <item>
      <title>06-移动应用自动化 GUI 测试</title>
      <link>https://huoxj.github.io/posts/%E8%BD%AF%E4%BB%B6%E6%B5%8B%E8%AF%95/06-%E7%A7%BB%E5%8A%A8%E5%BA%94%E7%94%A8%E8%87%AA%E5%8A%A8%E5%8C%96-gui-%E6%B5%8B%E8%AF%95/</link>
      <pubDate>Fri, 03 Jan 2025 00:00:00 +0000</pubDate>
      <guid>https://huoxj.github.io/posts/%E8%BD%AF%E4%BB%B6%E6%B5%8B%E8%AF%95/06-%E7%A7%BB%E5%8A%A8%E5%BA%94%E7%94%A8%E8%87%AA%E5%8A%A8%E5%8C%96-gui-%E6%B5%8B%E8%AF%95/</guid>
      <description>&lt;h2 id=&#34;测试脚本&#34;&gt;测试脚本&lt;/h2&gt;&#xA;&lt;p&gt;传统的脚本驱动的自动化 GUI 测试。代表工具是 &lt;code&gt;selenium&lt;/code&gt; 和 &lt;code&gt;appium&lt;/code&gt;&lt;/p&gt;&#xA;&lt;h3 id=&#34;存在的问题&#34;&gt;存在的问题&lt;/h3&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;脚本执行&lt;strong&gt;依赖&lt;/strong&gt; OS 接口&lt;/li&gt;&#xA;&lt;li&gt;定位控件&lt;strong&gt;依赖&lt;/strong&gt;移动应用的 UI 层&lt;/li&gt;&#xA;&lt;li&gt;人工编写脚本开销大，&lt;strong&gt;成本高&lt;/strong&gt;&lt;/li&gt;&#xA;&lt;li&gt;脚本随应用迭代，可&lt;strong&gt;维护性不强&lt;/strong&gt;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;p&gt;即便是基于简单的图像匹配，还是存在依赖、适配、成本的问题。&lt;/p&gt;&#xA;&lt;h2 id=&#34;基于图像理解&#34;&gt;基于图像理解⭐&lt;/h2&gt;&#xA;&lt;p&gt;挑战⭐：&lt;/p&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;移动应用碎片化问题=&amp;gt;测试难度大&lt;/li&gt;&#xA;&lt;li&gt;页面包含动态内容=&amp;gt;相似控件难识别&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;p&gt;解决⭐：基于图像理解技术，录制和回放跨平台的测试脚本&lt;/p&gt;&#xA;&lt;p&gt;步骤⭐：&lt;/p&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;GUI 测试脚本录制&#xA;&lt;ul&gt;&#xA;&lt;li&gt;基于坐标&lt;/li&gt;&#xA;&lt;li&gt;基于控件树&lt;/li&gt;&#xA;&lt;li&gt;基于图像&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;GUI 脚本回放&#xA;&lt;ul&gt;&#xA;&lt;li&gt;图像特征比对&lt;/li&gt;&#xA;&lt;li&gt;布局刻画&lt;/li&gt;&#xA;&lt;li&gt;坐标校正&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;p&gt;局限性：&lt;/p&gt;&#xA;&lt;ol&gt;&#xA;&lt;li&gt;无法感知异形屏幕对 UI 控件的遮挡&lt;/li&gt;&#xA;&lt;li&gt;难以模拟真实场景下人的交互操作&lt;/li&gt;&#xA;&lt;li&gt;仍依赖操作系统接口执行测试操作&lt;/li&gt;&#xA;&lt;/ol&gt;</description>
    </item>
    <item>
      <title>08-移动应用众包测试</title>
      <link>https://huoxj.github.io/posts/%E8%BD%AF%E4%BB%B6%E6%B5%8B%E8%AF%95/08-%E7%A7%BB%E5%8A%A8%E5%BA%94%E7%94%A8%E4%BC%97%E5%8C%85%E6%B5%8B%E8%AF%95/</link>
      <pubDate>Fri, 03 Jan 2025 00:00:00 +0000</pubDate>
      <guid>https://huoxj.github.io/posts/%E8%BD%AF%E4%BB%B6%E6%B5%8B%E8%AF%95/08-%E7%A7%BB%E5%8A%A8%E5%BA%94%E7%94%A8%E4%BC%97%E5%8C%85%E6%B5%8B%E8%AF%95/</guid>
      <description>&lt;p&gt;跳过了 07-Web 测试，因为不考。&lt;/p&gt;&#xA;&lt;h2 id=&#34;概念&#34;&gt;概念&lt;/h2&gt;&#xA;&lt;p&gt;众包：利用群体力量来完成传统方法中成本高昂或耗时的大规模任务&lt;/p&gt;&#xA;&lt;p&gt;&lt;strong&gt;众包测试&lt;/strong&gt;：利用群体力量完成移动应用测试任务&lt;/p&gt;&#xA;&lt;h2 id=&#34;流程&#34;&gt;流程&lt;/h2&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;&lt;strong&gt;申请上传&lt;/strong&gt;：用户上传自己要测的应用到众测平台，指定测试任务等信息&lt;/li&gt;&#xA;&lt;li&gt;&lt;strong&gt;任务选择和环境设置&lt;/strong&gt;：众测人员选择任务，配置环境&lt;/li&gt;&#xA;&lt;li&gt;&lt;strong&gt;提交报告&lt;/strong&gt;：众测人员测试，并提交缺陷报告&lt;/li&gt;&#xA;&lt;li&gt;&lt;strong&gt;生成最终测试报告&lt;/strong&gt;：平台收集补充信息，生成最终的缺陷报告&lt;/li&gt;&#xA;&lt;li&gt;&lt;strong&gt;报告验证&lt;/strong&gt;：验证报告，并发酬劳&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;h2 id=&#34;挑战&#34;&gt;挑战⭐&lt;/h2&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;任务分配&lt;/li&gt;&#xA;&lt;li&gt;任务奖励&lt;/li&gt;&#xA;&lt;li&gt;众测过程引导&lt;/li&gt;&#xA;&lt;li&gt;测试报告质量控制&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;h2 id=&#34;机制&#34;&gt;机制⭐&lt;/h2&gt;&#xA;&lt;h3 id=&#34;众测报告聚合&#34;&gt;众测报告聚合&lt;/h3&gt;&#xA;&lt;p&gt;Aggregator：将报告做聚类。&lt;/p&gt;&#xA;&lt;p&gt;Summarizer：一个类汇总，总结并报告给开发者&lt;/p&gt;&#xA;&lt;h3 id=&#34;众测报告排序&#34;&gt;众测报告排序&lt;/h3&gt;&#xA;&lt;p&gt;报告排序原则：bug 越早发现，修复成本更低&lt;/p&gt;&#xA;&lt;p&gt;方法：文本+图片结合分析的方法&lt;/p&gt;&#xA;&lt;p&gt;当前研究的局限：&lt;/p&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;主要着眼于文本的分析理解&lt;/li&gt;&#xA;&lt;li&gt;仅引入简单的截图分析以辅助文本&lt;/li&gt;&#xA;&lt;li&gt;简单地将文本与图片拼接起来进行分析&lt;/li&gt;&#xA;&lt;/ul&gt;</description>
    </item>
  </channel>
</rss>
