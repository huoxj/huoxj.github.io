<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>操作系统设计与实现 on Runz&#39;s Blog</title>
    <link>https://huoxj.github.io/series/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0/</link>
    <description>Recent content in 操作系统设计与实现 on Runz&#39;s Blog</description>
    <generator>Hugo</generator>
    <language>cn</language>
    <lastBuildDate>Wed, 04 Sep 2024 00:00:00 +0000</lastBuildDate>
    <atom:link href="https://huoxj.github.io/series/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>实模式到保护模式</title>
      <link>https://huoxj.github.io/posts/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0/%E5%AE%9E%E6%A8%A1%E5%BC%8F%E5%88%B0%E4%BF%9D%E6%8A%A4%E6%A8%A1%E5%BC%8F/</link>
      <pubDate>Wed, 04 Sep 2024 00:00:00 +0000</pubDate>
      <guid>https://huoxj.github.io/posts/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0/%E5%AE%9E%E6%A8%A1%E5%BC%8F%E5%88%B0%E4%BF%9D%E6%8A%A4%E6%A8%A1%E5%BC%8F/</guid>
      <description>&lt;h1 id=&#34;开机-实模式到保护模式&#34;&gt;开机-实模式到保护模式&lt;/h1&gt;&#xA;&lt;p&gt;实模式到保护模式这个过程已经接触过很多次了。最早从软院OS实验的例行检查里背过相关内容，然后便不无意外地忘掉了。这次在OSDI课上又涉及到了这部分内容，趁此机会重温一下并写一个通俗易懂的笔记，以便以后查阅(可能并不会)。&lt;/p&gt;&#xA;&lt;h2 id=&#34;实模式&#34;&gt;实模式&lt;/h2&gt;&#xA;&lt;h3 id=&#34;摆龙门阵&#34;&gt;摆龙门阵&lt;/h3&gt;&#xA;&lt;p&gt;Intel为了兼容8086搞出来的玩意，在8、90年代很有用，但是对于现在来说还是太old-school了，所以新的&lt;a href=&#34;https://learn.microsoft.com/zh-cn/windows-hardware/drivers/bringup/boot-and-uefi&#34;&gt;UEFI启动&lt;/a&gt;方式已经渐渐取代了原来的BIOS，尽管我的装机U盘上的PE系统还保留了&lt;code&gt;Legacy&lt;/code&gt;启动。&lt;/p&gt;&#xA;&lt;p&gt;这里还有个&lt;a href=&#34;https://zhuanlan.zhihu.com/p/436122944&#34;&gt;UEFI和BIOS的区别 - 知乎&lt;/a&gt;专栏，有时间再看。&lt;/p&gt;&#xA;&lt;p&gt;我想，实模式作为入门OS的很大原因在于UEFI比较复杂，大学计算机课程只能以BIOS为框架进行教学，所以绕不开这个实模式到保护模式的转换。并且这个转换的过程能体现操作系统内存虚拟化的很多芝士，比如段页式内存管理。所以这一部分内容的理解还是有助于成为操作系统领域大神的www。&lt;/p&gt;&#xA;&lt;h3 id=&#34;实模式小介绍&#34;&gt;实模式小介绍&lt;/h3&gt;&#xA;&lt;blockquote&gt;&#xA;&lt;p&gt;摘自课程助教编写的实验文档&lt;/p&gt;&#xA;&lt;/blockquote&gt;&#xA;&lt;p&gt;在QEMU中，&lt;code&gt;i386&lt;/code&gt;为了保持向后兼容性，一开机并不是我们熟悉的&lt;code&gt;保护模式&lt;/code&gt;，而是&lt;code&gt;实模式&lt;/code&gt;。&lt;/p&gt;&#xA;&lt;p&gt;实模式简单来说就是一个16位的CPU，和保护模式相比，最主要有三点区别：&lt;/p&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;&#xA;&lt;p&gt;一是&lt;strong&gt;寄存器&lt;/strong&gt;&lt;/p&gt;&#xA;&lt;p&gt;不一样，实模式里只会用我们熟悉的寄存器的低16位，所以名字就少了前缀“E”，具体地有：&lt;/p&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;通用寄存器（16 位）：AX，BX，CX，DX，SP，BP，DI，SI&lt;/li&gt;&#xA;&lt;li&gt;段寄存器（16 位）：CS，DS，SS，ES&lt;/li&gt;&#xA;&lt;li&gt;状态和控制寄存器（16 位）： FLAGS，IP&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;&#xA;&lt;p&gt;二是&lt;strong&gt;寻址方式&lt;/strong&gt;不一样，在实模式里，虽然有段寄存器，但没有保护模式里的段表，更没有页表，物理地址就是 &lt;strong&gt;(段寄存器&amp;laquo;4) + 偏移地址&lt;/strong&gt; 。段寄存器16位，偏移地址也是16位，所以寻址空间就是2^20=1MiB。&lt;/p&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;&#xA;&lt;p&gt;三是&lt;strong&gt;中断处理&lt;/strong&gt;不一样，不过我们现在也不关心这个东西，有兴趣的话可以去搜索一下实模式的中断向量表，现在只需要大概知道中断都是由BIOS代办的就行了。&lt;/p&gt;&#xA;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;h2 id=&#34;bios执行过程以及两个模式&#34;&gt;BIOS执行过程以及两个模式&lt;/h2&gt;&#xA;&lt;p&gt;启动的第一条指令地址是&lt;code&gt;0xffff0&lt;/code&gt;。这个地址是BIOS ROM地址的最后，指令跳到ROM稍微靠前的地址&lt;code&gt;[CS:IP] 0f000:E05Bh&lt;/code&gt;。这个地址开始执行BIOS POST。&lt;/p&gt;&#xA;&lt;p&gt;这里会立马发生很重要的一个&lt;strong&gt;转换&lt;/strong&gt;，就是从实模式转成保护模式。&lt;/p&gt;&#xA;&lt;p&gt;原因是POST需要在保护下执行，否则实模式那点空间不够。&lt;/p&gt;&#xA;&lt;p&gt;自检完后通过&lt;code&gt;INT 19h&lt;/code&gt;开始自举。&lt;/p&gt;&#xA;&lt;p&gt;自举就是依次把每个磁盘的0扇区加载到&lt;code&gt;0x7c00&lt;/code&gt;然后看是不是MBR，即看扇区尾巴是不是&lt;code&gt;0x55&lt;/code&gt;和&lt;code&gt;0xaa&lt;/code&gt;，是的话自举滴任务就完成辣！&lt;/p&gt;&#xA;&lt;p&gt;其实还没有，自举谢幕前还要进行重要的一步，就是&lt;strong&gt;转换&lt;/strong&gt;回实模式。&lt;/p&gt;&#xA;&lt;p&gt;原因是要向后提供兼容。不是i386之前的架构的请自觉转到保护模式。&lt;/p&gt;&#xA;&lt;p&gt;总结为如下图：&lt;/p&gt;&#xA;&lt;p&gt;&lt;img src=&#34;https://runzblog.oss-cn-hangzhou.aliyuncs.com/postimg/202409271713413.png&#34; alt=&#34;image-20240904112540022&#34;&gt;&lt;/p&gt;&#xA;&lt;h2 id=&#34;实模式到保护模式&#34;&gt;实模式到保护模式&lt;/h2&gt;&#xA;&lt;p&gt;这部分是写本文最主要的目的，所以单独拉一个标题来写。&lt;/p&gt;&#xA;&lt;p&gt;实模式到保护模式主要是两步：设置段表GDT，再将CR0寄存器最低位置1。&lt;/p&gt;&#xA;&lt;p&gt;现在先只涉及GDT，LDT不管。&lt;/p&gt;&#xA;&lt;h3 id=&#34;保护模式的寻址怎么实现&#34;&gt;保护模式的寻址怎么实现&lt;/h3&gt;&#xA;&lt;p&gt;保护模式比实模式牛的地方之一就是实现了段式内存管理。我们都知道段式内存管理本质就是个二维寻址。&lt;/p&gt;&#xA;&lt;p&gt;保护模式下的&lt;strong&gt;寻址方式&lt;/strong&gt;如下：&lt;/p&gt;&#xA;&lt;p&gt;$$逻辑地址 = 段选择子_{16bits} \implies 段基址_{32bits} + 段内偏移_{32bits}$$&lt;/p&gt;&#xA;&lt;p&gt;&lt;code&gt;段选择子&lt;/code&gt;，可以根据字面意思理解记忆，就是记录选择了哪个段的东西。它存放在&lt;code&gt;段寄存器&lt;/code&gt;中。&lt;/p&gt;&#xA;&lt;p&gt;所以怎么从&lt;code&gt;段选择子&lt;/code&gt;拿到&lt;code&gt;段基址&lt;/code&gt;呢？这就要靠**&lt;code&gt;段表&lt;/code&gt;**了。&lt;/p&gt;&#xA;&lt;p&gt;段表细节见后面小标题，这里只需要知道通过&lt;code&gt;段选择子&lt;/code&gt;能找到段表中正确的项，而这个项(有名字，叫&lt;code&gt;段描述符&lt;/code&gt;)含有我们想要的很多信息，主要就是&lt;code&gt;段基址&lt;/code&gt;。&lt;/p&gt;&#xA;&lt;blockquote&gt;&#xA;&lt;p&gt;实验中提到了&amp;quot;扁平模式&amp;quot;，即将段基址全置0，这样偏移量就直接是逻辑地址了。&lt;/p&gt;&#xA;&lt;/blockquote&gt;&#xA;&lt;p&gt;这样就实现了保护模式的寻址。&lt;/p&gt;&#xA;&lt;h3 id=&#34;段表&#34;&gt;段表&lt;/h3&gt;&#xA;&lt;p&gt;&lt;code&gt;段表&lt;/code&gt;是个一位线性表。表项是前面说的&lt;code&gt;段描述符&lt;/code&gt;，一个&lt;code&gt;段描述符&lt;/code&gt;有64位，下面粗略说一下段描述符有哪些信息。&lt;/p&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;段基址：最主要的信息之一。占32位。&lt;/li&gt;&#xA;&lt;li&gt;段限长：段的长度，保证内存访问不会越界。也比较重要，占20位。&lt;/li&gt;&#xA;&lt;li&gt;其他控制位。包括段限长粒度、特权位等。&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;p&gt;详细来说，如下&lt;/p&gt;&#xA;&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;DESCRIPTORS USED FOR APPLICATIONS CODE AND DATA SEGMENTS&#xD;&#xA;&#xD;&#xA;  31                23                15                7               0&#xD;&#xA; +-----------------+-+-+-+-+---------+-+-----+-+-----+-+-----------------+&#xD;&#xA; |                 | | | |A|         | |     | |     | |                 |&#xD;&#xA; |   BASE 31..24   |G|X|O|V| LIMIT   |P| DPL |S| TYPE|A|  BASE 23..16    | 4&#xD;&#xA; |                 | | | |L| 19..16  | |     | |     | |                 |&#xD;&#xA; |-----------------+-+-+-+-+---------+-+-----+-+-----+-+-----------------|&#xD;&#xA; |                                   |                                   |&#xD;&#xA; |        SEGMENT BASE 15..0         |       SEGMENT LIMIT 15..0         | 0&#xD;&#xA; |                                   |                                   |&#xD;&#xA; +-----------------------------------+-----------------------------------+&#xD;&#xA;&#xD;&#xA;           A      - ACCESSED&#xD;&#xA;           AVL    - AVAILABLE FOR USE BY SYSTEMS PROGRAMMERS&#xD;&#xA;           DPL    - DESCRIPTOR PRIVILEGE LEVEL&#xD;&#xA;           G      - GRANULARITY&#xD;&#xA;           P      - SEGMENT PRESENT&#xA;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;具体大致看一下就行了，毕竟真要用到也不会有人记得清的。&lt;/p&gt;</description>
    </item>
  </channel>
</rss>
